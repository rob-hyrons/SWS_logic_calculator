<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Shutter Motor Calculator</title>
    <!-- xlsx.js for data reading (existing) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ExcelJS for image extraction (new) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <!-- Papa Parse for CSV importing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f4f9; color: #333; display: flex; justify-content: center;
            align-items: flex-start; min-height: 100vh; margin: 0; padding: 2em;
        }
        #logo-image {
            position: absolute;
            top: 2em;
            right: 2em;
            width: 10vw;
            max-width: 150px;
            height: auto;
            z-index: 10;
        }
        .container {
            background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1000px; 
            display: flex; flex-direction: row;
            align-items: stretch;
        }
        .content-area {
            padding: 2em;
            flex-grow: 1;
            border-left: 1px solid #dee2e6;
        }
        h1 { color: #1a1a1a; text-align: center; margin-bottom: 1em; }
        .form-group { margin-bottom: 1.5em; }
        .form-row {
            display: flex;
            gap: 1.5em; /* Spacing between columns */
        }
        .form-col {
            flex: 1; /* Each column takes up equal space */
        }
        label { display: block; margin-bottom: 0.5em; font-weight: 600; }
        input[type="number"], input[type="file"], select, input[type="checkbox"] {
            width: 100%; padding: 0.8em; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
        }
        input[type="checkbox"] { width: auto; }
        input[type="file"] { padding: 0.5em; }
        .radio-group label { display: inline-block; margin-right: 15px; font-weight: 500;}
        .radio-group input[type="radio"] { margin-right: 5px; }
        .results {
            margin-top: 1.5em; background-color: #f8f9fa; padding: 1.5em; border-radius: 6px; border-left: 5px solid #007bff;
        }
        .results h3 { margin-top: 0; color: #0056b3; }
        .results h4 { margin-top: 1em; margin-bottom: 0.5em; color: #495057;}
        .results p { font-size: 1.1em; margin: 0.5em 0; line-height: 1.5; }
        .results span { font-weight: bold; color: #1a1a1a; }
        #import-status { margin-top: 0.5em; font-style: italic; color: #555; }
        
        .tabs {
            display: flex;
            flex-direction: column;
            background-color: #f1f3f5;
            flex-shrink: 0;
            width: 55px;
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
        }
        .tab-button {
            height: 120px;
            padding: 0.5em;
            border: none;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #555;
            border-left: 5px solid transparent;
            transition: all 0.2s ease-in-out;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            text-align: center;
        }
        .tab-button:hover {
            filter: brightness(75%);
        }
        .tab-button.active {
            font-weight: 700;
            color: #000;
            border-left-color: #0d6efd;
        }
        /* Tab Colors */
        .tab-button:nth-child(1) { background-color: #e3f2fd; }
        .tab-button:nth-child(2) { background-color: #e8f5e9; }
        .tab-button:nth-child(3) { background-color: #fff3e0; }
        .tab-button:nth-child(4) { background-color: #fce4ec; }
        .tab-button:nth-child(5) { background-color: #ede7f6; }
        .tab-button:nth-child(6) { background-color: #e0f7fa; }
        .tab-button:nth-child(7) { background-color: #e9ecef; } /* Admin Tab Color */

        .tab-button.active:nth-child(1) { background-color: #cce5ff; }
        .tab-button.active:nth-child(2) { background-color: #d1e7dd; }
        .tab-button.active:nth-child(3) { background-color: #ffe5b4; }
        .tab-button.active:nth-child(4) { background-color: #f8d7da; }
        .tab-button.active:nth-child(5) { background-color: #dcd0ff; }
        .tab-button.active:nth-child(6) { background-color: #b2ebf2; }
        .tab-button.active:nth-child(7) { background-color: #ced4da; } /* Admin Tab Active Color */
        
        .tab-pane { display: block; }
        .tab-pane:not(.active) { display: none; }
        .tab-pane.active { display: block; padding-bottom: 2em; }
        .warning-text, p .warning-text, span.warning-text { color: #d93025 !important; font-weight: bold; }
        
        .width-validation-warning {
            color: #d93025;
            font-weight: 500;
            font-size: 0.9em;
            margin-top: 0.5em;
            display: none; /* Hidden by default */
        }

        #recommendation-box {
            display: none; margin-top: 1em; padding: 1em; background-color: #fffbe6;
            border: 1px solid #ffe58f; border-radius: 4px; color: #d46b08; font-weight: bold;
        }
        .graph-container { margin-top: 1.5em; width: 100%; }
        #axle-cross-section-container, 
        #endplate-graphic-container {
            min-width: 450px;
            max-width: 550px;
            margin-left: auto;
            margin-right: auto;
        }
        .calculation-explainer {
            margin-top: 2em;
            padding: 1em;
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        .calculation-explainer h4 { margin-top: 0; color: #495057; }
        .calculation-explainer span { font-weight: bold; color: #0056b3; }
        
        /* SVG Styles */
        .beam-path { stroke: #adb5bd; stroke-width: 2; fill: none; }
        .deflected-path { stroke: #007bff; stroke-width: 4; fill: none; transition: d 0.3s ease-out; }
        .deflected-path.warning { stroke: #d93025; }
        .graph-text { font-family: sans-serif; font-size: 12px; fill: #343a40; text-anchor: middle; }
        .axis-line { stroke: #ced4da; stroke-width: 1; }
        .torque-bar { fill: #007bff; transition: all 0.2s ease-out; }
        .torque-bar:hover { fill: #0056b3; }
        .graph-data-label { font-size: 10px; text-anchor: middle; fill: #495057; }
        
        .support-symbol { fill: #868e96; stroke: #495057; stroke-width: 1; }
        .coil-wrap-graphic { fill: none; stroke: #adb5bd; stroke-width: 0.5; }
        
        .option-pass {
            color: #1e8e3e; /* Green */
            font-weight: bold;
        }
        .option-fail {
            color: #d93025; /* Red */
        }

        #shutter-graphic-container, #wicket-graphic-container {
            margin-top: 1.5em;
            width: 100%;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            background-color: #f8f9fa;
        }
        .shutter-axle-graphic { fill: #6c757d; stroke: #495057; stroke-width: 0.5; }
        .shutter-lath-graphic { fill: #e9ecef; stroke: #adb5bd; stroke-width: 0.5; }
        .shutter-bottomlath-graphic { fill: #ced4da; stroke: #495057; stroke-width: 0.5; }
        .wicket-door-graphic { fill: #a5d6a7; stroke: #388e3c; stroke-width: 1; }
        .shutter-vision-lath-graphic { fill: #a7d8f0; stroke: #6bafd2; stroke-width: 0.5; }
        .endlock-graphic { fill: #000000; }
        .wind-endlock-graphic { fill: #555555; } /* Dark Grey */
        .endplate-box-graphic {
            fill: rgba(255, 193, 7, 0.2); /* Semi-transparent yellow */
            stroke: #ffc107;
            stroke-width: 1;
            stroke-dasharray: 4, 2;
        }
        
        .axle-centerline-graphic { stroke: #d93025; stroke-width: 1; stroke-dasharray: 4, 2; }
        .dimension-line { stroke: #343a40; stroke-width: 1; }
        .leader-line { stroke: #343a40; stroke-width: 0.5; stroke-dasharray: 2,2; }
        .dimension-text { font-family: sans-serif; font-size: 5px; fill: #343a40; text-anchor: middle; }
        .large-dimension-text { font-family: sans-serif; font-size: 10px; fill: #343a40; text-anchor: middle; }
        .shutter-overlay-text {
            font-family: sans-serif;
            font-size: 10px;
            font-weight: bold;
            fill: #343a40;
            text-anchor: middle;
            pointer-events: none;
        }

        .print-container {
            display: flex;
            justify-content: flex-end;
            padding: 0;
            margin-bottom: 1em;
        }
        #printButton {
            padding: 0.8em 1.5em;
            font-size: 0.9em;
            font-weight: 600;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color: 0.2s;
        }
        #printButton:hover {
            background-color: #0056b3;
        }

        /* Admin Page Styles */
        .admin-section {
            margin-bottom: 2em;
            padding: 1.5em;
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }
        .admin-section h3 {
            margin-top: 0;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0.5em;
        }
        .admin-section h4 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #495057;
        }
        .admin-controls, .report-filter-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1em;
            margin-top: 1em;
        }
        .admin-control-item label {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .admin-button-group {
            display: flex;
            gap: 1em;
            margin-bottom: 1.5em;
        }
        .admin-button-group button, #importCsvButton, #generateCsvButton {
            padding: 0.5em 1em;
            font-size: 0.8em;
            font-weight: 500;
            color: #fff;
            background-color: #6c757d;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .admin-button-group button:hover, #importCsvButton:hover, #generateCsvButton:hover {
            background-color: #5a6268;
        }
        #importCsvButton { background-color: #28a745; }
        #importCsvButton:hover { background-color: #218838; }
        #generateCsvButton { background-color: #007bff; font-size: 0.9em; padding: 0.8em 1.2em; }
        #generateCsvButton:hover { background-color: #0056b3; }

        .report-controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1em;
            margin-bottom: 1.5em;
        }
        .report-filter-container {
             max-height: 200px;
             overflow-y: auto;
             padding: 1em;
             border: 1px solid #dee2e6;
             border-radius: 4px;
        }

        /* Axle Shape Toggle Styles */
        .shape-toggle {
            display: flex;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
        }
        .shape-toggle input[type="radio"] {
            display: none;
        }
        .shape-toggle label {
            flex: 1;
            text-align: center;
            padding: 0.8em;
            margin: 0;
            cursor: pointer;
            background-color: #f8f9fa;
            color: #495057;
            transition: background-color 0.2s;
            font-weight: 500;
        }
        .shape-toggle input[type="radio"]:checked + label {
            background-color: #007bff;
            color: white;
            font-weight: 600;
        }


        @media print {
            body {
                font-family: Arial, sans-serif; background-color: #fff; padding: 0; margin: 0;
            }
            @page {
                size: A4; margin: 15mm;
            }
            .tabs, .form-group, .print-container, .calculation-explainer, hr, #import-status, #recommendation-box, #admin-content, #logo-image {
                display: none !important;
            }
            .tab-pane {
                display: block !important;
                padding-top: 1em;
            }
            .page-break-before-print {
                page-break-before: always;
            }
            .container {
                 display: block;
                 box-shadow: none; border: none; width: 100%; max-width: 100%; padding: 0;
            }
            .content-area {
                padding: 0;
                border-left: none;
            }
            * { color: #000 !important; }
            h1 {
                font-size: 20pt; text-align: center !important; border: none; margin-bottom: 1.5em;
            }
            h2 {
                font-size: 15pt; border-bottom: 2px solid #ccc; padding-bottom: 4px;
                margin-top: 1.5em; margin-bottom: 1em;
            }
            .tab-pane > h2:first-of-type {
                margin-top: 0;
            }
            .results {
                border: 1px solid #ccc; border-left: none; page-break-inside: avoid;
                margin-top: 1em; padding: 1em;
            }
            .graph-container, #shutter-graphic-container, #wicket-graphic-container {
                width: 100% !important; max-width: 450px;
                margin-left: auto; margin-right: auto; page-break-inside: avoid;
            }
            #lath-image-container, #vision-lath-image-container, #safety-brake-image-container {
                page-break-inside: avoid;
                text-align: center;
                padding: 1em 0;
            }
            #lath-image-container img, #vision-lath-image-container img, #safety-brake-image-container img {
                max-height: 80px;
            }
            svg { width: 100% !important; }
        }

    </style>
</head>
<body>
    <img src="https://raw.githubusercontent.com/rob-hyrons/SWS_logic_calculator/main/swslogo.svg" alt="SWS Logo" id="logo-image">
    <div class="container">
        <div class="tabs">
            <button class="tab-button active" data-tab="inputs-content">Inputs</button>
            <button class="tab-button" data-tab="axle-content">Axle</button>
            <button class="tab-button" data-tab="motor-content">Motor</button>
            <button class="tab-button" data-tab="endplate-content">Endplate</button>
            <button class="tab-button" data-tab="safety-brake-content">Safety Brake</button>
            <button class="tab-button" data-tab="wicket-content">Wicket Door</button>
            <button class="tab-button" data-tab="admin-content">Admin</button>
        </div>
        <div class="content-area">
            <h1>Complete Shutter Calculator</h1>
            
            <div class="print-container">
                <button id="printButton">Print Report to PDF</button>
            </div>

            <div class="tab-content">
                <!-- Inputs Tab -->
                <div id="inputs-content" class="tab-pane active">
                    <h2>Shutter Specification</h2>
                    <div class="form-group" data-admin-label="File Import Status">
                         <div id="import-status">Attempting to load data from repository...</div>
                    </div>
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Curtain Width">
                            <label for="width">Curtain Width (mm)</label>
                            <input type="number" id="width" placeholder="e.g., 3000">
                            <div id="width-warning" class="width-validation-warning"></div>
                        </div>
                        <div class="form-group form-col" data-admin-label="Curtain Height">
                            <label for="height">Curtain Height (Floor to Axle Centre, mm)</label>
                            <input type="number" id="height" placeholder="e.g., 4000">
                        </div>
                    </div>
                     <div class="form-group" data-admin-label="Additional Axle Width">
                        <label for="additionalLength">Additional Axle Width (Total, mm)</label>
                        <input type="number" id="additionalLength" placeholder="e.g., 100" value="100">
                    </div>
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Lath Type">
                            <label for="lathType">Lath Type</label>
                            <select id="lathType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div class="form-group form-col" data-admin-label="Endlock Type">
                            <label for="endlockType">Endlock Type</label>
                            <select id="endlockType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                    </div>
                     <!-- NEW CUSTOM LATH SECTION -->
                    <div class="form-group" data-admin-label="Custom Lath Option">
                        <label for="useCustomLath" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="useCustomLath" style="width: auto; margin-right: 8px; vertical-align: middle;">Use Custom Lath
                        </label>
                    </div>
                    <div id="custom-lath-options" data-admin-label="Custom Lath Weight" style="display: none; padding-left: 20px; border-left: 3px solid #e9ecef; margin-bottom: 1.5em; margin-top: -1em;">
                        <div class="form-group">
                            <label for="customLathWeight">Custom Lath Weight (kg/m²)</label>
                            <input type="number" id="customLathWeight" placeholder="e.g., 9.5">
                            <small style="font-size: 0.8em; color: #555;">Note: Other properties (thickness, height) will be based on the lath selected above.</small>
                        </div>
                    </div>
                    <!-- END NEW SECTION -->
                    <div id="lath-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                        <img id="lathImageDisplay" src="" alt="Lath Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                    </div>
                    <div class="form-group" data-admin-label="Powder Coated Option">
                        <label for="powderCoated" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="powderCoated" style="width: auto; margin-right: 8px; vertical-align: middle;">Powder Coated (+1 kg/m²)
                        </label>
                    </div>
                    <div class="form-group" data-admin-label="Bottom Lath Type">
                        <label for="bottomLathType">Bottom Lath Type</label>
                        <select id="bottomLathType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div class="form-group" data-admin-label="Add Vision Slats Option">
                        <label for="addVision" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="addVision" style="width: auto; margin-right: 8px; vertical-align: middle;">Add Vision Slats
                        </label>
                    </div>
                    <div id="vision-slat-options" data-admin-label="Vision Slat Details" style="display: none; padding-left: 20px; border-left: 3px solid #e9ecef; margin-bottom: 1.5em; margin-top: -1em;">
                        <div class="form-group">
                            <label for="visionLathType">Vision Lath Type</label>
                            <select id="visionLathType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div id="vision-lath-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                            <img id="visionLathImageDisplay" src="" alt="Vision Lath Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                        </div>
                        <div class="form-group">
                            <label for="visionStartHeight">Height to Vision Start (from floor, mm)</label>
                            <input type="number" id="visionStartHeight" placeholder="e.g., 1000">
                            <small style="font-size: 0.8em; color: #555;">This will be adjusted to the nearest lath.</small>
                        </div>
                        <div class="form-group">
                            <label for="visionPanelHeight">Vision Panel Height (mm)</label>
                            <input type="number" id="visionPanelHeight" placeholder="e.g., 500">
                            <small style="font-size: 0.8em; color: #555;">This will be adjusted to the nearest lath.</small>
                        </div>
                    </div>

                    <div class="results">
                        <h3>Shutter Details</h3>
                        <p>Total Shutter Weight: <span id="weight-kg">0.00</span> kgs</p>
                        <p>Curtain Weight (for Torque): <span id="torque-weight-kg">0.00</span> kgs</p>
                        <p>Total Endlock Weight: <span id="endlock-weight">0.00</span> kgs</p>
                        <p>Total Curtain Area (Material): <span id="curtain-area">0.00</span> m²</p>
						<p>Curtain Area to Lift (Coverage): <span id="lifted-curtain-area">0.00</span> m²</p>
                        <p id="vision-area-m2-para" style="display: none;">Total Vision Area: <span id="vision-area-m2">0.00</span> m²</p>
                        <p id="vision-percentage-para" style="display: none;">Overall Vision Percentage: <span id="vision-percentage">0.00</span> %</p>
                        <p>Total Number of Laths: <span id="lath-count">0</span></p>
                        <p>Laths to Lift: <span id="laths-to-lift">0</span></p>
                        <p>Uncompressed Curtain Height: <span id="curtain-height-extended">0</span> mm</p>
                        <p>Compressed Curtain Height: <span id="curtain-height-compressed">0</span> mm</p>
                        <!-- NEW MOTOR INFO SECTION -->
                        <h4 style="margin-top: 1em; margin-bottom: 0.5em; color: #495057;">Motor Recommendation</h4>
                        <p>Max Required Torque: <span id="max-torque-inputs">0.0</span> Nm</p>
                        <p>Selected Motor: <span id="motor-name-inputs">N/A</span></p>
                        <p id="motor-torque-line-inputs">Motor Torque Range: <span id="motor-torque-inputs">0</span> Nm</p>
                        <!-- END NEW SECTION -->
                    </div>
                    <div id="shutter-graphic-container"></div>
                </div>

                <!-- Axle Analysis Tab -->
                <div id="axle-content" class="tab-pane">
                    <h2>Axle Deflection Analysis</h2>
                    
                    <div class="form-group" data-admin-label="Axle Shape">
                        <label>Axle Shape</label>
                        <div class="shape-toggle">
                            <input type="radio" id="shapeCircular" name="axleShape" value="circular" checked>
                            <label for="shapeCircular">Circular</label>
                            <input type="radio" id="shapeOctagonal" name="axleShape" value="octagonal">
                            <label for="shapeOctagonal">Octagonal</label>
                        </div>
                    </div>
                    
                    <div class="form-group" data-admin-label="Axle Type Selector">
                        <label for="axleType">Axle Section (Auto-Selected)</label>
                        <select id="axleType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="collar-size-group" data-admin-label="Collar Size" style="display: none;">
                        <label for="collarSize">Collar Size (mm)</label>
                        <input type="number" id="collarSize" placeholder="e.g., 150" value="0">
                    </div>

                    <div id="deflection-graphic-container" class="graph-container" style="height: 150px;"></div>
                    <div id="axle-cross-section-container" class="graph-container" style="height: 250px; margin-top: 2.5em;"></div>
                    <div class="results">
                        <h3>Axle Performance</h3>
                        <p>Total Axle Length: <span id="total-axle-length">0</span> mm</p>
                        <p>Axle Weight: <span id="axle-weight">0.00</span> kgs</p>
                        <p>Total Weight (for Deflection): <span id="total-deflection-weight">0.00</span> kgs</p>
                        <p>Material Grade: <span id="axle-material-grade">N/A</span></p>
                        <p>Moment of Inertia (I): <span id="moment-of-inertia">0.00</span> mm⁴</p>
                        <p>Calculated Deflection: <span id="axle-deflection">0.00</span> mm</p>
                        <p id="ratio-paragraph">Deflection Ratio: <span id="deflection-ratio">N/A</span></p>
                        <p>Safety Factor: <span id="axle-safety-factor">N/A</span></p>
                    </div>
                    <div id="recommendation-box"></div>
                </div>

                <!-- Motor Tab -->
                <div id="motor-content" class="tab-pane">
                    <h2>Motor & Torque Analysis</h2>
                     <div class="form-group" data-admin-label="Motor Manufacturer">
                        <label for="motorManufacturerFilter">Motor Manufacturer</label>
                        <select id="motorManufacturerFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                     <div class="form-group" data-admin-label="Motor Voltage">
                        <label for="motorVoltageFilter">Motor Voltage</label>
                        <select id="motorVoltageFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Motor Mounting Type">
                        <label for="motorMountingType">Motor Mounting Type</label>
                        <select id="motorMountingType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Lath Friction Allowance">
                        <label for="friction">Lath Friction Allowance (%)</label>
                        <input type="number" id="friction" value="10" title="Automatically updated from Lath data. Can be overridden.">
                    </div>
                    <div id="torque-graph-container" class="graph-container" style="height: 280px;"></div>
                    <div class="results">
                        <h3>Torque Calculation</h3>
                        <p>Max Required Torque: <span id="max-torque">0.0</span> Nm</p>
                        <p>Total Revolutions: <span id="total-revolutions">0.0</span></p>
                        <hr>
                        <div class="form-group" data-admin-label="Motor Selector">
                            <label for="motorSelector">Select Motor</label>
                            <select id="motorSelector" disabled>
                                <option>-- First select a mounting type --</option>
                            </select>
                        </div>
                        <h3>Selected Motor Details</h3>
                        <p>Motor Name: <span id="motor-name">N/A</span></p>
                        <p id="motor-torque-line">Motor Torque Range: <span id="motor-torque">0</span> Nm</p>
                        <p>Motor Speed: <span id="motor-rpm">0</span> RPM</p>
                        <p>Opening Time: <span id="opening-time">0</span> seconds</p>
                        <p>Power Consumed per Cycle: <span id="power-consumed">0.0000</span> kWh</p>
                    </div>
                </div>
                
                <div id="endplate-content" class="tab-pane page-break-before-print">
                    <h2>Endplate Selection</h2>
                     <div class="form-group" data-admin-label="Endplate Material">
                        <label>Endplate Material</label>
                        <div class="radio-group">
                            <input type="radio" id="matSteel" name="material" value="Steel" checked>
                            <label for="matSteel">Steel</label>
                            <input type="radio" id="matAluminium" name="material" value="Aluminium">
                            <label for="matAluminium">Aluminium</label>
                        </div>
                    </div>
                    <div class="form-group" data-admin-label="Include Deflection in Sizing">
                        <label for="includeDeflectionInSizing" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="includeDeflectionInSizing" style="width: auto; margin-right: 8px; vertical-align: middle;">Include Axle Deflection in Coil Sizing
                        </label>
                    </div>
                    <div class="form-group" data-admin-label="Endplate Selector">
                        <label for="endplateSelector">Select Endplate (Auto-Selected)</label>
                        <select id="endplateSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="results" style="border-left-color: #ffc107;">
                        <h3 style="color: #c79100;">Sizing Details</h3>
                        <p>Maximum Coil Diameter: <span id="max-coil-diameter">0.0</span> mm</p>
                        <p id="effective-coil-para" style="display: none;">Effective Sizing Diameter (inc. deflection): <span id="effective-coil-diameter">0.0</span> mm</p>
                        <hr>
                        <h3>Selected Endplate</h3>
                        <p>Name: <span id="endplate-name">N/A</span></p>
                        <p>Size: <span id="endplate-size">0</span> mm</p>
                        <p>Material: <span id="endplate-material">N/A</span></p>
                        <hr>
                        <h4>Curtain Height Limits by Endplate</h4>
                        <p>For Next Size Down (<span id="prev-endplate-name">N/A</span>): <span id="prev-endplate-height">N/A</span> mm</p>
                        <p>For Next Size Up (<span id="next-endplate-name">N/A</span>): <span id="next-endplate-height">N/A</span> mm</p>
                    </div>
                    <div id="endplate-graphic-container" class="graph-container"></div>
                    <div class="results page-break-before-print" style="border-left-color: #6f42c1; margin-top: 2em;">
                        <h3 style="color: #5a32a3;">Fixing Forces Analysis (Per Endplate, inc. 20% Safety Factor)</h3>
                        <p>Total Downward Shear Force: <span id="endplate-downward-force">0</span> N</p>
                        <p>Resultant Pull-out Force (on top fixing): <span id="endplate-pullout-force">0</span> N</p>
                    </div>
                    <div id="endplate-force-diagram-container" class="graph-container" style="height: 250px; margin-top: 1.5em;"></div>
                </div>

                <!-- Safety Brake Tab -->
                <div id="safety-brake-content" class="tab-pane">
                    <h2>Safety Brake Force Analysis</h2>
                    
                    <div class="form-group" data-admin-label="Safety Brake Selector">
                        <label for="safetyBrakeSelector">Available Safety Brakes (Auto-Selected)</label>
                        <select id="safetyBrakeSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div id="safety-brake-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                        <img id="safetyBrakeImageDisplay" src="" alt="Safety Brake Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                    </div>

                    <div class="results" style="border-left-color: #d93025;">
                        <h3 style="color: #d93025;">Worst-Case Impact</h3>
                        <p>Selected Safety Brake: <span id="safety-brake-name">N/A</span></p>
                        <p>Brake Max Torque Capacity: <span id="safety-brake-capacity">N/A</span> Nm</p>
                        <p>Driveshaft Diameter: <span id="safety-brake-driveshaft">N/A</span> mm</p>
                        <p>Worst-Case Activation Height (from floor): <span id="sb-activation-height">0.00</span> m</p>
                        <p>Impact Torque on Axle (inc. 20% factor): <span id="safety-brake-torque">0.00</span> Nm</p>
                        <p>Linear Impact Force: <span id="safety-brake-force-kn">0.00</span> kN</p>
                        <p>Equivalent Linear Force: <span id="safety-brake-force-kg">0.00</span> kgf</p>
                    </div>

                    <div class="calculation-explainer">
                        <h4>Calculation Explained</h4>
                        This calculates the shock load if the shutter free-falls from a worst-case height of <strong>1000mm</strong> from the floor. The fall distance before brake engagement is assumed to be <strong>1/8th of the coil's circumference</strong> at that height. A <strong>20% safety factor</strong> is applied to the calculated torque before selecting a brake.
                        <br><br>
                        <strong>Principle:</strong> Potential Energy (from fall) = Work Done (by brake)
                        <br>
                        <code>Force = (Mass × g × Fall Distance) / Stop Distance</code>
                        <br>
                        <code>Torque = Force × Axle Radius</code>
                        <br><br>
                        <strong>Values Used:</strong>
                        <ul>
                            <li>Mass at worst-case height: <span id="sb-mass">0.00</span> kg</li>
                            <li>Fall Distance: <span id="sb-fall-dist">0.000</span> m</li>
                            <li>Gravity (g): <span>9.81</span> m/s²</li>
                            <li>Stop Distance: <span id="sb-stop-dist">0.010</span> m</li>
                        </ul>
                        <span id="sb-activation-height-explainer" style="display: none;"></span>
                    </div>
                </div>
                
                <div id="wicket-content" class="tab-pane">
                    <h2>Wicket Door Selection</h2>
                    <div class="form-group" data-admin-label="Wicket Door Selector">
                        <label for="wicketDoorSelector">Available Wicket Doors</label>
                        <select id="wicketDoorSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="results" style="border-left-color: #00bcd4;">
                        <h3 style="color: #00838f;">Selected Wicket Door</h3>
                        <p>Name: <span id="wicket-door-name">N/A</span></p>
                        <p>Height: <span id="wicket-door-height">0</span> mm</p>
                        <p>Width: <span id="wicket-door-width">0</span> mm</p>
                        <hr>
                        <p>Laths Level with Wicket Door: <span id="laths-at-wicket">0</span></p>
                        <p>Height to Top of Wicket Laths: <span id="wicket-lath-height">0</span> mm</p>
                        <h3 style="margin-top: 1.5em;">Adjusted Motor Torque</h3>
                        <p>Max Required Torque (with Wicket): <span id="wicket-max-torque">0.0</span> Nm</p>
                    </div>
                    <div id="wicket-graphic-container"></div>
                    <div id="wicket-torque-graph-container" class="graph-container" style="height: 280px;"></div>
                </div>

                <!-- Admin Tab -->
                <div id="admin-content" class="tab-pane">
                    <h2>Admin Controls</h2>
                    
                    <div class="admin-section">
                        <h3>Import from CSV</h3>
                        <div class="form-group" style="display: flex; align-items: center; gap: 1em;">
                            <input type="file" id="csvFileInput" accept=".csv" style="flex-grow: 1;">
                            <button id="importCsvButton">Import</button>
                        </div>
                        <div id="import-status-admin" style="font-style: italic; color: #555;"></div>
                    </div>

                    <div class="admin-section">
                        <h3>Tab Visibility</h3>
                        <div class="admin-button-group">
                            <button id="tabsSelectAll">Select All</button>
                            <button id="tabsDeselectAll">Deselect All</button>
                        </div>
                        <div id="tab-controls-container" class="admin-controls">
                            <!-- Tab controls will be generated here by JavaScript -->
                        </div>
                    </div>

                    <div class="admin-section">
                        <h3>Input Option Visibility</h3>
                         <div class="admin-button-group">
                            <button id="inputsSelectAll">Select All</button>
                            <button id="inputsDeselectAll">Deselect All</button>
                        </div>
                        <div id="input-controls-container" class="admin-controls">
                            <!-- Input controls will be generated here by JavaScript -->
                        </div>
                    </div>

                    <!-- =================================================================== -->
                    <!-- START: NEW SECTION FOR CSV REPORT GENERATION                        -->
                    <!-- =================================================================== -->
                    <div id="csv-report-section" class="admin-section">
                        <h3>Generate Sizing Report</h3>
                        <p>Configure the report parameters below. This process can take several minutes and may slow down your browser depending on the size of the range selected.</p>
                        
                        <h4>1. Define Size Range (mm)</h4>
                        <div class="report-controls-grid">
                            <div class="form-group">
                                <label for="reportMinWidth">Min Width</label>
                                <input type="number" id="reportMinWidth" value="1000">
                            </div>
                            <div class="form-group">
                                <label for="reportMaxWidth">Max Width</label>
                                <input type="number" id="reportMaxWidth" value="8000">
                            </div>
                             <div class="form-group">
                                <label for="reportInterval">Interval</label>
                                <input type="number" id="reportInterval" value="500">
                            </div>
                            <div class="form-group">
                                <label for="reportMinHeight">Min Height</label>
                                <input type="number" id="reportMinHeight" value="1000">
                            </div>
                            <div class="form-group">
                                <label for="reportMaxHeight">Max Height</label>
                                <input type="number" id="reportMaxHeight" value="6000">
                            </div>
                        </div>

                        <h4>2. Select Lath Types to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportLathSelectAll">Select All</button>
                            <button id="reportLathDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-lath-filter-container" class="report-filter-container">
                            <p>Loading lath data...</p>
                        </div>

                        <h4>3. Select Motor Manufacturers to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportMotorSelectAll">Select All</button>
                            <button id="reportMotorDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>
                        
                        <!-- NEW FILTERS FOR VOLTAGE AND MOUNTING TYPE -->
                        <h4>4. Select Motor Voltages to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportVoltageSelectAll">Select All</button>
                            <button id="reportVoltageDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-voltage-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>

                        <h4>5. Select Motor Mounting Types to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportMountingSelectAll">Select All</button>
                            <button id="reportMountingDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-mounting-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>
                        <!-- END NEW FILTERS -->

                        <div class="admin-button-group" style="margin-top: 1.5em;">
                            <button id="generateCsvButton">Generate and Download CSV Report</button>
                        </div>
                        <div id="csv-generation-status" style="font-style: italic; color: #555;"></div>
                    </div>
                    <!-- =================================================================== -->
                    <!-- END: NEW SECTION FOR CSV REPORT GENERATION                          -->
                    <!-- =================================================================== -->
                </div>

            </div>
        </div>
    </div>
    
    <script>
        let lathData = [], axleData = [], motorData = [], bottomLathData = [], safetyBrakeData = [], endplateData = [], wicketData = [], endlockData = [];
        let lathImageMap = new Map();
        let safetyBrakeImageMap = new Map();
        let currentFilteredMotors = [], currentFilteredEndplates = [];
        let calculatedRotations = 0, maxCoilDiameter = 0;
        let lastTorqueProfile = [];
        let userSelectedAxleIndex = null;
        let visionCalcs = null; 
        
        const dom = {};
        ['width', 'additionalLength', 'height', 'lathType', 'bottomLathType', 'axleType', 'friction', 'import-status', 
         'total-axle-length', 'weight-kg', 'axle-deflection', 'deflection-ratio', 'ratio-paragraph', 
         'recommendation-box', 'deflection-graphic-container', 'torque-graph-container', 'lath-count', 'laths-to-lift',
         'max-torque', 'total-revolutions', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'motorSelector', 'motor-name', 'motor-torque', 'motor-rpm', 
         'opening-time', 'motor-torque-line', 'axle-weight', 'axle-material-grade', 'moment-of-inertia', 'total-deflection-weight',
         'safety-brake-force-kn', 'safety-brake-force-kg', 'safety-brake-torque', 'safety-brake-name', 'sb-mass', 'sb-fall-dist', 'sb-stop-dist',
         'sb-activation-height', 'sb-activation-height-explainer', 'safetyBrakeSelector', 'shutter-graphic-container', 'safety-brake-driveshaft',
         'curtain-height-extended', 'curtain-height-compressed', 'endplateSelector', 'matSteel', 'matAluminium', 'endplate-name', 'endplate-size',
         'endplate-material', 'max-coil-diameter', 'prev-endplate-name', 'prev-endplate-height', 'next-endplate-name', 'next-endplate-height',
         'width-warning', 'curtain-area', 'lifted-curtain-area', 'printButton', 'wicketDoorSelector', 'wicket-door-name', 'wicket-door-height', 'wicket-door-width',
         'wicket-graphic-container', 'laths-at-wicket', 'wicket-lath-height', 'wicket-max-torque', 'wicket-torque-graph-container',
         'addVision', 'vision-slat-options', 'visionLathType', 'visionStartHeight', 'visionPanelHeight', 'axle-safety-factor', 'power-consumed',
         'powderCoated', 'axle-cross-section-container', 'visionLathImageDisplay', 'safety-brake-capacity', 
         'safety-brake-image-container', 'safetyBrakeImageDisplay', 'endplate-graphic-container', 'endplate-downward-force', 
         'endplate-pullout-force', 'endplate-force-diagram-container', 'includeDeflectionInSizing', 'effective-coil-para', 'effective-coil-diameter', 'collarSize',
         'vision-percentage', 'vision-percentage-para', 'vision-area-m2', 'vision-area-m2-para', 'endlockType', 'endlock-weight',
         'admin-content', 'tab-content', 'importCsvButton', 'shapeCircular', 'shapeOctagonal', 'collar-size-group', 'torque-weight-kg',
         'useCustomLath', 'custom-lath-options', 'customLathWeight', 'max-torque-inputs', 'motor-name-inputs', 'motor-torque-inputs', 'motor-torque-line-inputs'
        ].forEach(id => dom[id] = document.getElementById(id));
        
        const tabButtons = document.querySelectorAll('.tab-button');
        
        ['width', 'additionalLength', 'height', 'friction', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'bottomLathType', 'lathType', 'matSteel', 'matAluminium',
         'visionLathType', 'visionStartHeight', 'visionPanelHeight', 'powderCoated', 'includeDeflectionInSizing', 'collarSize', 'endlockType',
         'useCustomLath', 'customLathWeight'
        ].forEach(id => {
            if (dom[id]) dom[id].addEventListener('input', () => {
                userSelectedAxleIndex = null; 
                if (id === 'useCustomLath') {
                    const isChecked = dom.useCustomLath.checked;
                    dom['custom-lath-options'].style.display = isChecked ? 'block' : 'none';
                    dom.lathType.disabled = isChecked;
                }
                if (id === 'lathType' && lathData.length > 0) {
                    const selectedLath = lathData[dom.lathType.value];
                    if (selectedLath) {
                        if (selectedLath['Friction %'] !== undefined) {
                            dom.friction.value = selectedLath['Friction %'];
                        }
                        const lathName = (selectedLath['Name'] || '').toLowerCase();
                        if (lathName.includes('wind')) {
                           const endlockSelect = dom.endlockType;
                           for (let i = 0; i < endlockSelect.options.length; i++) {
                               if (endlockSelect.options[i].text.toLowerCase().includes('75mm cast')) {
                                   endlockSelect.value = endlockSelect.options[i].value;
                                   break;
                               }
                           }
                        }
                    }
                }
                updateAllCalculations();
            });
        });

        dom.addVision.addEventListener('change', () => {
            dom['vision-slat-options'].style.display = dom.addVision.checked ? 'block' : 'none';
            updateAllCalculations();
        });

        ['shapeCircular', 'shapeOctagonal'].forEach(id => {
            if (dom[id]) dom[id].addEventListener('change', handleShapeChange);
        });

        dom.motorSelector.addEventListener('change', updateSelectedMotorInfo);
        dom.endplateSelector.addEventListener('change', updateSelectedEndplateInfo);
        tabButtons.forEach(button => button.addEventListener('click', () => switchTab(button.dataset.tab)));
        dom.safetyBrakeSelector.addEventListener('input', updateSelectedSafetyBrakeInfo);
        dom.axleType.addEventListener('input', handleAxleOverride);
        dom.wicketDoorSelector.addEventListener('input', updateSelectedWicketInfo);
        dom.printButton.addEventListener('click', () => {
            window.print();
        });
        dom.importCsvButton.addEventListener('click', handleCsvImport);

        // Admin Page Logic
        function initializeAdminControls() {
            const tabContainer = document.getElementById('tab-controls-container');
            const inputContainer = document.getElementById('input-controls-container');
            tabContainer.innerHTML = '';
            inputContainer.innerHTML = '';

            // Generate Tab Controls
            document.querySelectorAll('.tab-button').forEach(tab => {
                const tabId = tab.dataset.tab;
                const labelText = tab.textContent.trim();
                const controlItem = document.createElement('div');
                controlItem.className = 'admin-control-item';
                
                const isChecked = tab.style.display !== 'none';

                controlItem.innerHTML = `
                    <label>
                        <input type="checkbox" data-target="${tabId}" ${isChecked ? 'checked' : ''}>
                        ${labelText}
                    </label>
                `;
                tabContainer.appendChild(controlItem);

                controlItem.querySelector('input').addEventListener('change', (e) => {
                    tab.style.display = e.target.checked ? '' : 'none';
                });
            });

            // Generate Input Controls
            document.querySelectorAll('[data-admin-label]').forEach((inputGroup, index) => {
                const labelText = inputGroup.dataset.adminLabel;
                const groupId = `admin-input-${index}`;
                inputGroup.id = groupId; // Ensure the target has an ID

                const controlItem = document.createElement('div');
                controlItem.className = 'admin-control-item';
                controlItem.innerHTML = `
                    <label>
                        <input type="checkbox" data-target="${groupId}" checked>
                        ${labelText}
                    </label>
                `;
                inputContainer.appendChild(controlItem);
                 
                 controlItem.querySelector('input').addEventListener('change', (e) => {
                    inputGroup.style.display = e.target.checked ? '' : 'none';
                });
            });

            const setupBulkActions = (selectAllId, deselectAllId, containerId) => {
                document.getElementById(selectAllId).addEventListener('click', () => {
                    document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(cb => {
                        if (!cb.checked) {
                            cb.checked = true;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });
                });
                document.getElementById(deselectAllId).addEventListener('click', () => {
                    document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(cb => {
                        if (cb.checked) {
                            cb.checked = false;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });
                });
            };

            setupBulkActions('tabsSelectAll', 'tabsDeselectAll', 'tab-controls-container');
            setupBulkActions('inputsSelectAll', 'inputsDeselectAll', 'input-controls-container');
        }

        function handleShapeChange() {
            const selectedShape = document.querySelector('input[name="axleShape"]:checked').value;
            const collarGroup = dom['collar-size-group'];

            if (selectedShape === 'octagonal') {
                collarGroup.style.display = 'block';
            } else {
                collarGroup.style.display = 'none';
                dom.collarSize.value = 0; // Reset value when hidden to avoid calculation errors
            }
            
            userSelectedAxleIndex = null; // Reset user override when shape changes
            updateAllCalculations();
        }

        function handleAxleOverride() {
            if (dom.axleType.value !== "") {
                userSelectedAxleIndex = dom.axleType.value; 
                updateAllCalculations(); 
            }
        }
        
        async function processExcelFile(fileData) {
            userSelectedAxleIndex = null; 
            try {
                const workbook = XLSX.read(new Uint8Array(fileData), { type: 'array' });
                
                const required = {
                    'Lath': ['Name', 'Kgs/ m2', 'Thickness', 'Compressed lath height', 'uncompressed lath height', 'Friction %', 'Max Width', 'Lath image', 'Moment of inertia iy', 'Allowable Bending Stress (MPa)', 'vision percentage'],
                    'Bottom lath': ['Bottom lath name', 'BLath weight / m length', 'BLath height'],
                    'Axles': ['Name', 'Diameter', 'Wall Thickness', 'Material grade', "Density (kg/m3)", 'Shape'],
                    'Motors': ['Name', 'Torque (Nm) min', 'Torque (Nm) max', 'RPM', 'Mounting type', 'Wattage', 'Voltage', 'Manufacturer'],
                    'SafetyB': ['Name', 'Max Safety Torque (Nm)', 'Driveshaft diameter mm', 'Stop distance', 'SB image'],
                    'Endplate': ['Name', 'Size', 'Material', 'Fixing holes'],
                    'Wicket doors': ['Name', 'Height', 'Width'],
                    'Endlock': ['Description', 'Weight in grams', 'end lock offset']
                };

                for (const sheetName in required) {
                    if (!workbook.Sheets[sheetName]) {
                        if (sheetName === 'Wicket doors' || sheetName === 'Endlock') {
                            console.warn(`Optional sheet "${sheetName}" not found.`);
                            if(sheetName === 'Wicket doors') wicketData = [];
                            if(sheetName === 'Endlock') endlockData = [];
                            continue;
                        }
                         const coreRequired = {
                            'Lath': ['Name', 'Kgs/ m2', 'Thickness', 'Compressed lath height', 'uncompressed lath height', 'Moment of inertia iy', 'Allowable Bending Stress (MPa)'],
                            'Bottom lath': ['Bottom lath name', 'BLath weight / m length'],
                            'Axles': ['Name', 'Diameter', 'Wall Thickness'],
                            'Motors': ['Name', 'Torque (Nm) max', 'Mounting type', 'Manufacturer'],
                            'SafetyB': ['Name', 'Max Safety Torque (Nm)'],
                            'Endplate': ['Name', 'Size', 'Material'],
                            'Wicket doors': ['Name', 'Height', 'Width'],
                            'Endlock': ['Description', 'Weight in grams', 'end lock offset']
                        };
                        const sheetData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });
                        if (sheetData.length > 0) {
                            const headerRow = sheetData[0].map(h => String(h).toLowerCase().trim());
                            for (const requiredCol of coreRequired[sheetName]) {
                                if (!headerRow.includes(requiredCol.toLowerCase().trim())) {
                                    throw new Error(`Required column "${requiredCol}" not found in sheet "${sheetName}".`);
                                }
                            }
                        } else {
                           throw new Error(`Required sheet "${sheetName}" not found or is empty in the Excel file.`);
                        }
                    }
                    
                    const objectData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
                    switch (sheetName) {
                        case 'Lath': lathData = objectData; break;
                        case 'Bottom lath': bottomLathData = objectData; break;
                        case 'Axles': axleData = objectData; break;
                        case 'Motors': motorData = objectData; break;
                        case 'SafetyB': safetyBrakeData = objectData; break;
                        case 'Endplate': endplateData = objectData; break;
                        case 'Wicket doors': wicketData = objectData; break;
                        case 'Endlock': endlockData = objectData; break;
                    }
                }

                lathImageMap.clear(); 
                safetyBrakeImageMap.clear();
                const exceljsWorkbook = new ExcelJS.Workbook();
                await exceljsWorkbook.xlsx.load(fileData);

                const lathSheet = exceljsWorkbook.getWorksheet('Lath');
                if (lathSheet) {
                    await extractImagesFromSheet(exceljsWorkbook, lathSheet, 'name', 'lath image', lathImageMap);
                }
                
                const safetyBrakeSheet = exceljsWorkbook.getWorksheet('SafetyB');
                if (safetyBrakeSheet) {
                    await extractImagesFromSheet(exceljsWorkbook, safetyBrakeSheet, 'name', 'sb image', safetyBrakeImageMap);
                }
                
                populateDropdown(dom.lathType, lathData, 'Name');
                const visionSelect = dom.visionLathType;
                visionSelect.innerHTML = `<option value="">-- Select a vision lath --</option>`;
                lathData.forEach((item, index) => {
                    const visionKey = Object.keys(item).find(k => k.toLowerCase().trim() === 'vision percentage');
                    const visionValue = visionKey ? (parseFloat(item[visionKey]) || 0) : 0;
                    if (visionValue > 0) {
                        const option = document.createElement('option');
                        option.value = index;
                        const nameKey = Object.keys(item).find(k => k.toLowerCase().trim() === 'name');
                        option.textContent = item[nameKey];
                        visionSelect.appendChild(option);
                    }
                });
                populateDropdown(dom.bottomLathType, bottomLathData, 'Bottom lath name');
                populateDropdown(dom.endlockType, endlockData, 'Description');
                populateMotorMountingTypes();
                populateMotorVoltageFilter();
                populateMotorManufacturerFilter();
                populateDropdown(dom.wicketDoorSelector, wicketData, 'Name');

                ['lathType', 'bottomLathType', 'visionLathType', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'safetyBrakeSelector', 'axleType', 'endplateSelector', 'wicketDoorSelector', 'endlockType'].forEach(id => {
                    if(dom[id]) dom[id].disabled = false;
                });

                updateSelectedWicketInfo(); 
                dom['import-status'].textContent = 'Successfully loaded data from repository.';
                dom['import-status'].style.color = 'green';
                updateAllCalculations();
                
                // --- NEW: Populate the report filters now that data is loaded ---
                setupReportFilters();

            } catch (error) {
                dom['import-status'].textContent = `Error processing Excel file: ${error.message}`;
                dom['import-status'].style.color = 'red';
                alert(`Error Reading File: ${error.message}`);
                lathData = []; axleData = []; motorData = []; bottomLathData = []; safetyBrakeData = []; endplateData = []; wicketData = []; endlockData = [];
            }
        }

        // CSV Import Logic
        function handleCsvImport() {
            const csvFileInput = document.getElementById('csvFileInput');
            const statusDiv = document.getElementById('import-status-admin');
            
            if (!csvFileInput.files || csvFileInput.files.length === 0) {
                statusDiv.textContent = 'Please select a CSV file first.';
                statusDiv.style.color = 'red';
                return;
            }

            const file = csvFileInput.files[0];
            statusDiv.textContent = 'Importing...';
            statusDiv.style.color = '#555';

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        statusDiv.textContent = `Error parsing CSV: ${results.errors[0].message}`;
                        statusDiv.style.color = 'red';
                        return;
                    }
                    if (results.data.length === 0) {
                        statusDiv.textContent = 'CSV file is empty or contains only headers.';
                        statusDiv.style.color = 'red';
                        return;
                    }
                    
                    populateFieldsFromCsv(results.data[0]);
                    statusDiv.textContent = `Successfully imported data for "${results.data[0].Calculation_ID || 'N/A'}".`;
                    statusDiv.style.color = 'green';
                },
                error: function(err) {
                     statusDiv.textContent = `An error occurred: ${err}`;
                     statusDiv.style.color = 'red';
                }
            });
        }

        function populateFieldsFromCsv(data) {
            const getVal = (key) => (data[key] || '').trim();

            const mappings = {
                'Curtain_Width_mm': { id: 'width', type: 'number' },
                'Curtain_Height_mm': { id: 'height', type: 'number' },
                'Additional_Axle_Width_mm': { id: 'additionalLength', type: 'number' },
                'Collar_Size_mm': { id: 'collarSize', type: 'number' },
                'Friction_Allowance_Percent': { id: 'friction', type: 'number' },
                'Vision_Start_Height_mm': { id: 'visionStartHeight', type: 'number' },
                'Vision_Panel_Height_mm': { id: 'visionPanelHeight', type: 'number' },

                'Is_Powder_Coated': { id: 'powderCoated', type: 'checkbox' },
                'Has_Vision_Slats': { id: 'addVision', type: 'checkbox' },
                'Include_Deflection_In_Sizing': { id: 'includeDeflectionInSizing', type: 'checkbox' },

                'Lath_Type_Name': { id: 'lathType', type: 'select' },
                'Endlock_Type_Name': { id: 'endlockType', type: 'select' },
                'Bottom_Lath_Name': { id: 'bottomLathType', type: 'select' },
                'Vision_Lath_Name': { id: 'visionLathType', type: 'select' },
                'Motor_Mounting_Type': { id: 'motorMountingType', type: 'select' },
                'Wicket_Door_Name': { id: 'wicketDoorSelector', type: 'select' },
                
                'Endplate_Material': { name: 'material', type: 'radio' },
            };

            for (const key in mappings) {
                const value = getVal(key);
                if (value === '') continue;

                const config = mappings[key];
                
                switch (config.type) {
                    case 'number':
                        const numEl = document.getElementById(config.id);
                        if (numEl) numEl.value = value;
                        break;
                    case 'checkbox':
                        const checkEl = document.getElementById(config.id);
                        if (checkEl) checkEl.checked = (value.toLowerCase() === 'true');
                        break;
                    case 'select':
                        const selectEl = document.getElementById(config.id);
                        if (selectEl) {
                            for (let i = 0; i < selectEl.options.length; i++) {
                                if (selectEl.options[i].text.trim() === value.trim()) {
                                    selectEl.value = selectEl.options[i].value;
                                    break;
                                }
                            }
                        }
                        break;
                    case 'radio':
                        const radioEl = document.querySelector(`input[name="${config.name}"][value="${value}"]`);
                        if (radioEl) radioEl.checked = true;
                        break;
                }
            }

            // Manually trigger change events for checkboxes that control visibility
            dom.addVision.dispatchEvent(new Event('change'));

            updateAllCalculations();
            
            // Switch back to the inputs tab to show the user the result
            switchTab('inputs-content');
        }

        async function extractImagesFromSheet(workbook, sheet, nameColHeader, imageColHeader, imageMap) {
            let nameCol = -1, imageCol = -1;
            const headerRow = sheet.getRow(1);
            headerRow.eachCell((cell, colNumber) => {
                const headerText = cell.value ? cell.value.toString().toLowerCase().trim() : '';
                if (headerText === nameColHeader) nameCol = colNumber;
                if (headerText === imageColHeader) imageCol = colNumber;
            });

            if (nameCol > 0 && imageCol > 0) {
                const images = sheet.getImages();
                images.forEach(image => {
                    const imageRowNumber = image.range.tl.row + 1;
                    const nameCell = sheet.getCell(imageRowNumber, nameCol);
                    if (nameCell && nameCell.value) {
                        const name = nameCell.value.toString();
                        const imgData = workbook.getImage(image.imageId);
                        const base64Image = btoa(new Uint8Array(imgData.buffer).reduce((data, byte) => data + String.fromCharCode(byte), ''));
                        const imageSrc = `data:image/${imgData.extension};base64,${base64Image}`;
                        imageMap.set(name, imageSrc);
                    }
                });
            }
        }

        function populateMotorMountingTypes() {
            const mountingTypes = [...new Set(motorData.map(motor => motor['Mounting type']))];
            const select = dom.motorMountingType;
            select.innerHTML = '<option value="">-- All Types --</option>';
            mountingTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                select.appendChild(option);
            });
        }
        
        function populateMotorVoltageFilter() {
            let voltageKey = '';
            if (motorData.length > 0) {
                voltageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'voltage');
            }

            if (!voltageKey) {
                console.warn('Voltage column not found in motor data.');
                dom.motorVoltageFilter.parentElement.style.display = 'none'; // Hide the filter if no data
                return;
            }

            const voltageTypes = [...new Set(motorData.map(motor => motor[voltageKey]).filter(v => v))];
            const select = dom.motorVoltageFilter;
            select.innerHTML = '<option value="">-- All Voltages --</option>';
            voltageTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                select.appendChild(option);
            });
            dom.motorVoltageFilter.parentElement.style.display = 'block';
        }

        function populateMotorManufacturerFilter() {
            let manufacturerKey = '';
            if (motorData.length > 0) {
                manufacturerKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manufacturer');
            }

            if (!manufacturerKey) {
                console.warn('Manufacturer column not found in motor data. The filter will not be displayed.');
                dom.motorManufacturerFilter.parentElement.style.display = 'none';
                return;
            }

            const manufacturers = [...new Set(motorData.map(motor => motor[manufacturerKey]).filter(m => m))];
            const select = dom.motorManufacturerFilter;
            select.innerHTML = '<option value="">-- All Manufacturers --</option>';
            manufacturers.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                select.appendChild(option);
            });
            dom.motorManufacturerFilter.parentElement.style.display = 'block';
        }

        function getLathWithCustomWeight() {
            let selectedLath = lathData[dom.lathType.value];
            if (!selectedLath) return null; // Need a base lath

            if (dom.useCustomLath.checked) {
                const customWeight = parseFloat(dom.customLathWeight.value);
                if (!isNaN(customWeight) && customWeight > 0) {
                    // Create a copy of the selected lath and override its weight
                    let customLath = { ...selectedLath };
                    const weightKey = Object.keys(customLath).find(k => k.toLowerCase().trim() === 'kgs/ m2');
                    if (weightKey) {
                        customLath[weightKey] = customWeight;
                    } else {
                        customLath['Kgs/ m2'] = customWeight;
                    }
                    return customLath;
                }
            }
            return selectedLath;
        }

        function updateAllCalculations() {
            if (lathData.length === 0) {
                return;
            };

            const effectiveLath = getLathWithCustomWeight();

            const lathImageContainer = document.getElementById('lath-image-container');
            const lathImageDisplay = document.getElementById('lathImageDisplay');
            
            if (effectiveLath) {
                const selectedLathName = effectiveLath['Name'];
                if (lathImageMap.has(selectedLathName)) {
                    lathImageDisplay.src = lathImageMap.get(selectedLathName);
                    lathImageContainer.style.display = dom.useCustomLath.checked ? 'none' : 'block';
                } else {
                    lathImageContainer.style.display = 'none';
                }
            } else {
                lathImageContainer.style.display = 'none';
            }

            const visionLathImageContainer = document.getElementById('vision-lath-image-container');
            const visionLathImageDisplay = document.getElementById('visionLathImageDisplay');
            if (dom.addVision.checked) {
                const selectedVisionLathIndex = dom.visionLathType.value;
                 if (selectedVisionLathIndex && lathData[selectedVisionLathIndex]) {
                    const selectedVisionLathName = lathData[selectedVisionLathIndex]['Name'];
                    if (lathImageMap.has(selectedVisionLathName)) {
                        visionLathImageDisplay.src = lathImageMap.get(selectedVisionLathName);
                        visionLathImageContainer.style.display = 'block';
                    } else {
                        visionLathImageContainer.style.display = 'none';
                    }
                } else {
                    visionLathImageContainer.style.display = 'none';
                }
            } else {
                 visionLathImageContainer.style.display = 'none';
            }

            const widthWarningDiv = dom['width-warning'];
            if (effectiveLath) {
                const maxWidthKey = Object.keys(effectiveLath).find(k => k.toLowerCase().trim() === 'max width');
                const maxWidth = maxWidthKey ? parseFloat(effectiveLath[maxWidthKey]) : 0;
                const currentWidth = parseFloat(dom.width.value) || 0;

                if (maxWidth > 0 && currentWidth > maxWidth && !dom.useCustomLath.checked) {
                    widthWarningDiv.textContent = `Warning: The entered width exceeds the maximum of ${maxWidth} mm for this lath type.`;
                    widthWarningDiv.style.display = 'block';
                } else {
                    widthWarningDiv.style.display = 'none';
                }
            } else {
                widthWarningDiv.style.display = 'none';
            }
            
            if (axleData.length === 0 || safetyBrakeData.length === 0) {
                drawDeflectionGraphic(0, 0);
                drawAxleCrossSection(null);
                calculateSafetyBrakeForce();
                drawShutterGraphic(); 
                return;
            };
            
            const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
            
            const estCurtainProps = calculateCurtainProperties(effectiveLath, selectedBottomLath, null);
            const { bestAxle } = findAndSetBestAxle(estCurtainProps.totalWeight);

            const finalCurtainProps = calculateCurtainProperties(effectiveLath, selectedBottomLath, bestAxle);
            const { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData, endlockOffsets } = finalCurtainProps;
            visionCalcs = visionData;
            
            calculateEndplateRecommendation(); 

            const { deflection, totalLength } = findAndSetBestAxle(totalWeight);

            drawDeflectionGraphic(totalLength, deflection);
            calculateMotorRecommendation(torqueWeight, effectiveLath, bestAxle, travelHeight);
            calculateSafetyBrakeForce(totalWeight, effectiveLath, bestAxle, travelHeight, fullCurtainLength);
            
            const selectedEndplateIndex = dom.endplateSelector.value;
            const selectedEndplate = (selectedEndplateIndex !== "" && currentFilteredEndplates[selectedEndplateIndex]) 
                ? currentFilteredEndplates[selectedEndplateIndex] 
                : null;

            drawShutterGraphic(
                parseFloat(dom.width.value),
                parseFloat(dom.additionalLength.value),
                parseInt(dom['lath-count'].textContent),
                effectiveLath,
                selectedBottomLath,
                bestAxle,
                selectedEndplate,
                visionData,
                endlockOffsets
            );
            updateWicketCalculationsAndGraphic(endlockOffsets);
        }
        
        function findAndSetBestAxle(totalWeightKgs) {
            const width = parseFloat(dom.width.value) || 0;
            const additionalLength = parseFloat(dom.additionalLength.value) || 0;
            const totalLength = width + additionalLength;
            dom['total-axle-length'].textContent = totalLength.toFixed(0);

            const selectedShape = document.querySelector('input[name="axleShape"]:checked')?.value || 'circular';

            if (totalLength <= 0 || axleData.length === 0) {
                 ['axle-deflection', 'deflection-ratio', 'axle-weight', 'moment-of-inertia', 'total-deflection-weight', 'axle-safety-factor'].forEach(id => dom[id].textContent = '0.00');
                dom['axle-material-grade'].textContent = 'N/A';
                dom.axleType.innerHTML = '<option>-- No data --</option>';
                drawAxleCrossSection(null);
                return { bestAxle: null, deflection: 0, totalLength: 0 };
            }

            const axlesForShape = axleData
                .map((axle, index) => ({ ...axle, originalIndex: index }))
                .filter(axle => {
                    const axleShapeInSheet = (axle.Shape || 'circular').toLowerCase().trim();
                    return axleShapeInSheet === selectedShape;
                });

            if (axlesForShape.length === 0) {
                dom.axleType.innerHTML = `<option>-- No ${selectedShape} axles available --</option>`;
                ['axle-deflection', 'deflection-ratio', 'axle-weight', 'moment-of-inertia', 'total-deflection-weight', 'axle-safety-factor'].forEach(id => dom[id].textContent = '0.00');
                dom['axle-material-grade'].textContent = 'N/A';
                drawAxleCrossSection(null);
                return { bestAxle: null, deflection: 0, totalLength: 0 };
            }

            let recommendedAxleOriginalIndex = -1;
            const axlePerformances = [];

            axlesForShape.forEach(currentAxle => {
                const perf = performDeflectionCalc(totalWeightKgs, currentAxle, totalLength);
                axlePerformances.push(perf);
                const passesTest = perf.ratio >= 400 && perf.deflection <= 25;
                if (passesTest && recommendedAxleOriginalIndex === -1) {
                    recommendedAxleOriginalIndex = currentAxle.originalIndex;
                }
            });

            if (recommendedAxleOriginalIndex === -1) {
                recommendedAxleOriginalIndex = axlesForShape.length > 0 ? axlesForShape[0].originalIndex : -1;
            }

            let finalSelectedOriginalIndex = userSelectedAxleIndex !== null ? userSelectedAxleIndex : recommendedAxleOriginalIndex;
            
            const isUserSelectionValidForShape = axlesForShape.some(axle => axle.originalIndex == finalSelectedOriginalIndex);
            if (userSelectedAxleIndex !== null && !isUserSelectionValidForShape) {
                finalSelectedOriginalIndex = recommendedAxleOriginalIndex;
            }

            const select = dom.axleType;
            select.innerHTML = '';
            axlesForShape.forEach((axle, index) => {
                const perf = axlePerformances[index];
                const option = document.createElement('option');
                option.value = axle.originalIndex;
                let optionText = axle['Name'];
                if (axle['Alternate name']) optionText += ` (${axle['Alternate name']})`;
                option.textContent = optionText;
                
                const passesTest = perf.ratio >= 400 && perf.deflection <= 25;
                option.classList.toggle('option-pass', passesTest);
                option.classList.toggle('option-fail', !passesTest);
                
                select.appendChild(option);
            });
            
            if (finalSelectedOriginalIndex > -1) {
                select.value = finalSelectedOriginalIndex;
            }
            
            const selectedAxleData = axleData[select.value];
            if (!selectedAxleData) {
                drawAxleCrossSection(null);
                return { bestAxle: null, deflection: 0, totalLength };
            }

            const finalPerformance = performDeflectionCalc(totalWeightKgs, selectedAxleData, totalLength);
            
            dom['axle-weight'].textContent = finalPerformance.axleWeight.toFixed(2);
            const totalDeflectionWeight = totalWeightKgs + finalPerformance.axleWeight;
            dom['total-deflection-weight'].textContent = totalDeflectionWeight.toFixed(2);

            dom['axle-material-grade'].textContent = finalPerformance.materialGradeValue ? `${finalPerformance.materialGradeValue} MPa` : 'N/A';
            dom['moment-of-inertia'].textContent = finalPerformance.inertiaI.toLocaleString(undefined, { maximumFractionDigits: 2 });
            dom['axle-deflection'].textContent = finalPerformance.deflection.toFixed(2);
            dom['deflection-ratio'].textContent = (finalPerformance.ratio !== Infinity) ? `1 : ${Math.round(finalPerformance.ratio)}` : 'N/A';
            dom['axle-safety-factor'].textContent = isFinite(finalPerformance.safetyFactor) ? finalPerformance.safetyFactor.toFixed(2) : 'Very High';

            if (finalPerformance.ratio < 400 || finalPerformance.deflection > 25) {
                dom['ratio-paragraph'].classList.add('warning-text');
                dom['axle-safety-factor'].parentElement.classList.add('warning-text');
                dom['recommendation-box'].style.display = 'block';

                const nextBest = axlesForShape.find(axle => {
                    const perf = performDeflectionCalc(totalWeightKgs, axle, totalLength);
                    return perf.ratio >= 400 && perf.deflection <= 25;
                });

                if (nextBest) {
                    dom['recommendation-box'].innerHTML = `⚠️ <strong>Warning:</strong> Selected axle may fail. Consider using <strong>${nextBest['Name']}</strong>.`;
                } else {
                    dom['recommendation-box'].innerHTML = `⚠️ <strong>Critical Warning:</strong> No available ${selectedShape} axle passes the deflection test for this specification.`;
                }
            } else {
                dom['ratio-paragraph'].classList.remove('warning-text');
                dom['axle-safety-factor'].parentElement.classList.remove('warning-text');
                dom['recommendation-box'].style.display = 'none';
            }

            const collarSize = parseFloat(dom.collarSize.value) || 0;
            drawAxleCrossSection(selectedAxleData, collarSize);
            
            return { bestAxle: selectedAxleData, deflection: finalPerformance.deflection, totalLength };
        }

        function performDeflectionCalc(totalWeightKgs, axle, totalLength) {
            if (!axle) return { deflection: 0, ratio: Infinity, safetyFactor: Infinity, axleWeight: 0, materialGradeValue: 'N/A', inertiaI: 0 };
            
            const outerDia = parseFloat(axle['Diameter']);
            const wallThick = parseFloat(axle['Wall Thickness']);
            const shape = (axle['Shape'] || 'circular').toLowerCase();
            const lengthM = totalLength / 1000;
            const density = parseFloat(axle['Density (kg/m3)']) || 0;
            const materialGradeValue = axle['Material grade'];
            const youngsModulusE = parseFloat(materialGradeValue) || 199000;
            
            let inertiaI = 0;
            let axleWeight = 0;

            if (shape === 'octagonal') {
                const Do = outerDia;
                const Di = Do - 2 * wallThick;
                inertiaI = ((11 + 8 * Math.sqrt(2)) / 192) * (Math.pow(Do, 4) - Math.pow(Di, 4));

                const outerArea = 2 * (Math.sqrt(2) - 1) * Math.pow(Do, 2);
                const innerArea = 2 * (Math.sqrt(2) - 1) * Math.pow(Di, 2);
                const hollowArea_mm2 = outerArea - innerArea;
                const volume_m3 = (hollowArea_mm2 / 1000000) * lengthM;
                axleWeight = volume_m3 * density;
                
            } else { // Circular
                inertiaI = (Math.PI / 64) * (Math.pow(outerDia, 4) - Math.pow(outerDia - 2 * wallThick, 4));
                const outerRadiusM = outerDia / 2 / 1000;
                const innerRadiusM = (outerDia - 2 * wallThick) / 2 / 1000;
                const volumeM3 = Math.PI * (Math.pow(outerRadiusM, 2) - Math.pow(innerRadiusM, 2)) * lengthM;
                axleWeight = volumeM3 * density;
            }
            
            const totalForceW = (totalWeightKgs + axleWeight) * 9.81;
            const deflection = (totalLength > 0 && inertiaI > 0 && youngsModulusE > 0) 
                ? (5 * totalForceW * Math.pow(totalLength, 3)) / (384 * youngsModulusE * inertiaI) 
                : 0;
                
            const ratio = (deflection > 0) ? totalLength / deflection : Infinity;
            const safetyFactor = ratio / 400;

            return { deflection, ratio, safetyFactor, axleWeight, materialGradeValue, inertiaI };
        }
        
        function getEffectiveCoilDiameter(axle) {
            if (!axle) return 0;
            const shape = (axle['Shape'] || 'circular').toLowerCase();
            const diameter = parseFloat(axle['Diameter']) || 0;
            
            if (shape === 'octagonal') {
                return diameter / Math.cos(Math.PI / 8);
            }
            return diameter;
        }
        
        function calculateEndplateRecommendation() {
            if (endplateData.length === 0) return;

            dom['max-coil-diameter'].textContent = maxCoilDiameter.toFixed(1);

            const axleDeflection = parseFloat(dom['axle-deflection'].textContent) || 0;
            let effectiveCoilDiameter = maxCoilDiameter;

            if (dom.includeDeflectionInSizing.checked && axleDeflection > 0) {
                effectiveCoilDiameter += axleDeflection;
                dom['effective-coil-diameter'].textContent = effectiveCoilDiameter.toFixed(1);
                dom['effective-coil-para'].style.display = 'block';
            } else {
                dom['effective-coil-para'].style.display = 'none';
            }
            
            const selectedMaterial = dom.matSteel.checked ? 'Steel' : 'Aluminium';
            currentFilteredEndplates = endplateData
                .filter(plate => plate.Material.toLowerCase() === selectedMaterial.toLowerCase())
                .sort((a, b) => a.Size - b.Size);
            
            const select = dom.endplateSelector;
            select.innerHTML = '';

            if (currentFilteredEndplates.length === 0) {
                select.innerHTML = `<option value="">-- No ${selectedMaterial} plates --</option>`;
                updateSelectedEndplateInfo();
                return;
            }

            let recommendedPlateIndex = -1;
            
            currentFilteredEndplates.forEach((plate, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${plate.Name} (${plate.Size} mm)`;
                
                if (plate.Size >= effectiveCoilDiameter) {
                    option.classList.add('option-pass');
                    if (recommendedPlateIndex === -1) {
                         recommendedPlateIndex = index;
                    }
                } else {
                    option.classList.add('option-fail');
                    option.disabled = true;
                }
                select.appendChild(option);
            });

            if (recommendedPlateIndex !== -1) {
                select.value = recommendedPlateIndex;
            } else {
                 const noPlateOption = document.createElement('option');
                noPlateOption.value = "";
                noPlateOption.textContent = "-- Coil too large for available plates --";
                noPlateOption.selected = true;
                noPlateOption.disabled = true;
                select.prepend(noPlateOption);
                drawEndplateGraphic(null, 0, null, null, 0); 
            }
            updateSelectedEndplateInfo();
        }

        function calculateMaxFloorToAxleHeight(endplateSize, lath, bottomLath, axle) {
            if (!lath || !axle || !bottomLath || !endplateSize || endplateSize <= 0) return 0;
            
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(axle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
            const axleRadius = effectiveStartDiameter / 2;

            const lathThickness = parseFloat(lath['Thickness']);
            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const uncompressedLathHeight = parseFloat(lath['uncompressed lath height']) || lathCompressedHeight;
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;

            if (lathThickness <= 0 || effectiveStartDiameter <= 0 || endplateSize <= effectiveStartDiameter || uncompressedLathHeight <= 0) return 0;

            const maxRevolutions = (endplateSize - effectiveStartDiameter) / (2 * lathThickness);
            if (maxRevolutions <= 0) return 0;
            
            const maxCurtainLength = Math.PI * lathThickness * Math.pow(maxRevolutions, 2) + Math.PI * effectiveStartDiameter * maxRevolutions;
            
            const numLaths = (maxCurtainLength - bottomLathHeight) / uncompressedLathHeight;
            const heightToCoverByLaths = numLaths * lathCompressedHeight;
            const maxFloorToAxleHeight = heightToCoverByLaths + bottomLathHeight - axleRadius;

            return maxFloorToAxleHeight > 0 ? maxFloorToAxleHeight : 0;
        }

        function updateSelectedEndplateInfo() {
            const selectedIndex = parseInt(dom.endplateSelector.value, 10);
            
            const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
            const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
            const selectedBottomLath = bottomLathData.length > 0 ? bottomLathData[dom.bottomLathType.value] : null;
            const numLaths = parseInt(dom['lath-count'].textContent) || 0;

            if (isNaN(selectedIndex) || !currentFilteredEndplates[selectedIndex]) {
                ['endplate-name', 'endplate-size', 'endplate-material'].forEach(id => { dom[id].textContent = 'N/A'; });
                ['prev-endplate-name', 'prev-endplate-height', 'next-endplate-name', 'next-endplate-height'].forEach(id => { dom[id].textContent = 'N/A'; });
                drawEndplateGraphic(null, 0, null, null, 0);
                calculateEndplateForces(null);
                return;
            }

            const plate = currentFilteredEndplates[selectedIndex];
            dom['endplate-name'].textContent = plate.Name;
            dom['endplate-size'].textContent = plate.Size;
            dom['endplate-material'].textContent = plate.Material;

            drawEndplateGraphic(plate, maxCoilDiameter, selectedAxle, selectedLath, numLaths);
            calculateEndplateForces(plate);
            
            const prevPlate = selectedIndex > 0 ? currentFilteredEndplates[selectedIndex - 1] : null;
            if (prevPlate && selectedLath && selectedAxle && selectedBottomLath) {
                dom['prev-endplate-name'].textContent = `${prevPlate.Name} (${prevPlate.Size}mm)`;
                const maxHeight = calculateMaxFloorToAxleHeight(prevPlate.Size, selectedLath, selectedBottomLath, selectedAxle);
                dom['prev-endplate-height'].textContent = maxHeight > 0 ? maxHeight.toFixed(0) : 'Too small';
            } else {
                dom['prev-endplate-name'].textContent = 'N/A';
                dom['prev-endplate-height'].textContent = 'N/A';
            }
            
            const nextPlate = selectedIndex < currentFilteredEndplates.length - 1 ? currentFilteredEndplates[selectedIndex + 1] : null;
            if (nextPlate && selectedLath && selectedAxle && selectedBottomLath) {
                dom['next-endplate-name'].textContent = `${nextPlate.Name} (${nextPlate.Size}mm)`;
                 const maxHeight = calculateMaxFloorToAxleHeight(nextPlate.Size, selectedLath, selectedBottomLath, selectedAxle);
                dom['next-endplate-height'].textContent = maxHeight > 0 ? maxHeight.toFixed(0) : 'N/A';
            } else {
                dom['next-endplate-name'].textContent = 'N/A';
                dom['next-endplate-height'].textContent = 'N/A';
            }
        }

        function calculateEndplateForces(selectedPlate) {
            if (!selectedPlate) {
                dom['endplate-downward-force'].textContent = '0';
                dom['endplate-pullout-force'].textContent = '0';
                drawEndplateForceDiagram(0, 0, 0, 0, 0);
                return;
            }

            const fixingHolesKey = Object.keys(selectedPlate).find(k => k.toLowerCase().trim() === 'fixing holes');
            const fixingHoleSeparation = fixingHolesKey ? parseFloat(selectedPlate[fixingHolesKey]) : 0;
            const fixingHoleSeparationM = fixingHoleSeparation / 1000;

            const curtainWeightKgs = parseFloat(dom['weight-kg'].textContent) || 0;
            const axleWeightKgs = parseFloat(dom['axle-weight'].textContent) || 0;
            const totalStaticWeightKgs = curtainWeightKgs + axleWeightKgs;
            const totalStaticWeightN = totalStaticWeightKgs * 9.81;

            const safetyBrakeImpactN = (parseFloat(dom['safety-brake-force-kn'].textContent) || 0) * 1000;
            const offsetDistanceM = (parseFloat(selectedPlate.Size) / 2) / 1000;

            const staticWeightOnPlateN = totalStaticWeightN / 2;
            const impactOnPlateN = safetyBrakeImpactN / 2;
            const totalDownwardForceOnPlate = staticWeightOnPlateN + impactOnPlateN;
            const moment = staticWeightOnPlateN * offsetDistanceM;
            
            let pulloutForce = 0;
            if (fixingHoleSeparationM > 0) {
                pulloutForce = moment / fixingHoleSeparationM;
            }

            const safetyFactor = 1.20;
            const finalDownwardForce = totalDownwardForceOnPlate * safetyFactor;
            const finalPulloutForce = pulloutForce * safetyFactor;

            dom['endplate-downward-force'].textContent = finalDownwardForce.toFixed(0);
            dom['endplate-pullout-force'].textContent = finalPulloutForce.toFixed(0);

            drawEndplateForceDiagram(finalDownwardForce, finalPulloutForce, offsetDistanceM, fixingHoleSeparation, parseFloat(selectedPlate.Size));
        }

        function selectSafetyBrake(impactTorqueNm) {
            if (safetyBrakeData.length === 0) return null;
            const suitableBrakes = safetyBrakeData
                .map(b => ({ ...b, MaxTorque: parseFloat(b['Max Safety Torque (Nm)']) }))
                .filter(b => b.MaxTorque >= impactTorqueNm)
                .sort((a, b) => a.MaxTorque - b.MaxTorque);
            return suitableBrakes.length > 0 ? suitableBrakes[0] : null;
        }

        function populateSafetyBrakeDropdown(requiredTorque) {
            const select = dom.safetyBrakeSelector;
            select.innerHTML = ''; 
            if (safetyBrakeData.length === 0) {
                select.innerHTML = '<option>-- No brake data --</option>';
                return;
            }

            safetyBrakeData.forEach((brake, index) => {
                const option = document.createElement('option');
                option.value = index;
                const maxTorque = parseFloat(brake['Max Safety Torque (Nm)']);
                option.textContent = `${brake.Name} (${maxTorque} Nm)`;

                if (maxTorque >= requiredTorque) {
                    option.classList.add('option-pass');
                } else {
                    option.classList.add('option-fail');
                    option.disabled = true;
                }
                select.appendChild(option);
            });
        }
        
        function calculateSafetyBrakeForce(totalWeight, lath, axle, travelHeight, fullCurtainLength) {
            if (!axle || !lath || totalWeight <= 0 || !travelHeight || travelHeight <= 0) {
                ['safety-brake-force-kn', 'safety-brake-force-kg', 'safety-brake-torque', 'sb-mass', 'sb-activation-height', 'sb-stop-dist', 'safety-brake-capacity'].forEach(id => dom[id].textContent = 'N/A');
                dom['safety-brake-name'].textContent = 'N/A';
                dom.safetyBrakeSelector.innerHTML = '<option>-- Run calculation first --</option>';
                return;
            }

            let fallDistanceM = 0.1; 
            if (lath && axle && fullCurtainLength > 1000) {
                const collarSize = parseFloat(dom.collarSize.value) || 0;
                const axleCoilDiameter = getEffectiveCoilDiameter(axle);
                const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);

                const lathThickness = parseFloat(lath['Thickness']);
                const rolledUpLength = fullCurtainLength - 1000;
                const a = Math.PI * lathThickness;
                const b = Math.PI * effectiveStartDiameter;
                const c = -rolledUpLength;
                const discriminant = (b * b) - (4 * a * c);
                const revolutions = (discriminant < 0 || a === 0) ? 0 : (-b + Math.sqrt(discriminant)) / (2 * a);
                const diameterAtHeight = effectiveStartDiameter + 2 * revolutions * lathThickness;
                const circumference = Math.PI * diameterAtHeight;
                const calculatedFallDistance = (circumference / 8) / 1000;
                if (calculatedFallDistance > 0) fallDistanceM = calculatedFallDistance;
            }
            
            const activationHeightFromFloorM = 1.0; 
            const heightLiftedM = (travelHeight / 1000) - activationHeightFromFloorM;
            let percentLifted = (heightLiftedM > 0 && travelHeight > 0) ? heightLiftedM / (travelHeight / 1000) : 0;
            percentLifted = Math.max(0, Math.min(1, percentLifted));
            const fallingMass = totalWeight * (1 - percentLifted);
            
            const axleRadiusM = (parseFloat(axle['Diameter']) || 0) / 2 / 1000;
            const g = 9.81;
            
            const preliminaryStopDistanceM = 0.010;
            const potentialEnergy = fallingMass * g * fallDistanceM;
            const impactForceN = (preliminaryStopDistanceM > 0) ? potentialEnergy / preliminaryStopDistanceM : 0;
            const impactTorqueNm = impactForceN * axleRadiusM;
            
            const requiredTorqueWithSafetyFactor = impactTorqueNm * 1.20;

            populateSafetyBrakeDropdown(requiredTorqueWithSafetyFactor);
            const recommendedBrake = selectSafetyBrake(requiredTorqueWithSafetyFactor);

            let finalStopDistanceM = preliminaryStopDistanceM;
            if (recommendedBrake) {
                const stopDistKey = Object.keys(recommendedBrake).find(k => k.toLowerCase().trim() === 'stop distance');
                if (stopDistKey && parseFloat(recommendedBrake[stopDistKey]) > 0) {
                    finalStopDistanceM = parseFloat(recommendedBrake[stopDistKey]) / 1000;
                }
            }

            const finalPotentialEnergy = fallingMass * g * fallDistanceM;
            const finalImpactForceN = (finalStopDistanceM > 0) ? finalPotentialEnergy / finalStopDistanceM : 0;
            const finalImpactTorqueNm = finalImpactForceN * axleRadiusM;

            dom['sb-activation-height'].textContent = activationHeightFromFloorM.toFixed(2);
            dom['safety-brake-torque'].textContent = (finalImpactTorqueNm * 1.20).toFixed(2);
            dom['safety-brake-force-kn'].textContent = (finalImpactForceN / 1000).toFixed(2);
            dom['safety-brake-force-kg'].textContent = (finalImpactForceN / g).toFixed(2);
            dom['sb-mass'].textContent = fallingMass.toFixed(2);
            dom['sb-fall-dist'].textContent = fallDistanceM.toFixed(3);
            dom['sb-stop-dist'].textContent = finalStopDistanceM.toFixed(3); 

            if (recommendedBrake) {
                const originalIndex = safetyBrakeData.findIndex(b => b.Name === recommendedBrake.Name);
                if (originalIndex > -1) dom.safetyBrakeSelector.value = originalIndex;
            } else {
                dom.safetyBrakeSelector.value = "";
            }
            updateSelectedSafetyBrakeInfo();
        }

        function calculateMotorRecommendation(totalWeightKgs, lath, axle, travelHeight) {
            if (!lath || !axle || !travelHeight || travelHeight <= 0 || totalWeightKgs <= 0) {
                ['max-torque', 'total-revolutions', 'max-torque-inputs'].forEach(id => { dom[id].textContent = '0.0'; });
                lastTorqueProfile = [];
                maxCoilDiameter = 0;
                drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
                dom.motorSelector.innerHTML = '<option>-- First select a mounting type --</option>';
                dom.motorSelector.disabled = true;
                updateSelectedMotorInfo();
                return;
            }
            
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(axle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);

            calculatedRotations = calculateTotalRevolutions(travelHeight, effectiveStartDiameter, parseFloat(lath['Thickness']));
            dom['total-revolutions'].textContent = calculatedRotations.toFixed(1);

            const { profileData, finalCoilDiameter } = getTorqueProfile(totalWeightKgs, lath, travelHeight, effectiveStartDiameter);
            maxCoilDiameter = finalCoilDiameter;

            const frictionMultiplier = 1 + (parseFloat(dom.friction.value) || 0) / 100;
            lastTorqueProfile = profileData.map(item => ({...item, torque: item.torque * frictionMultiplier}));
            drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);

            const requiredTorque = lastTorqueProfile.length > 0 ? Math.max(...lastTorqueProfile.map(p => p.torque)) : 0;
            dom['max-torque'].textContent = requiredTorque.toFixed(1);
            dom['max-torque-inputs'].textContent = requiredTorque.toFixed(1);

            const selectedMountType = dom.motorMountingType.value;
            const selectedVoltage = dom.motorVoltageFilter.value;
            const selectedManufacturer = dom.motorManufacturerFilter.value;

            let voltageKey = '', manufacturerKey = '';
            if (motorData.length > 0) {
                voltageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'voltage');
                manufacturerKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manufacturer');
            }

            currentFilteredMotors = motorData.filter(motor => {
                const mountMatch = !selectedMountType || motor['Mounting type'] === selectedMountType;
                const voltageMatch = !selectedVoltage || !voltageKey || String(motor[voltageKey]) === String(selectedVoltage);
                const manufacturerMatch = !selectedManufacturer || !manufacturerKey || motor[manufacturerKey] === selectedManufacturer;
                return mountMatch && voltageMatch && manufacturerMatch;
            });
            
            const select = dom.motorSelector;
            select.innerHTML = ''; 
            select.disabled = false;

            if (currentFilteredMotors.length === 0) {
                select.innerHTML = '<option value="">-- No motors for this type --</option>';
                updateSelectedMotorInfo();
                return;
            }
            
            let recommendedMotorIndexInFilteredList = -1;

            currentFilteredMotors.forEach((motor, index) => {
                const option = document.createElement('option');
                option.value = index;
                
                const motorTorqueMin = parseFloat(motor['Torque (Nm) min']);
                const motorTorqueMax = parseFloat(motor['Torque (Nm) max']);
                option.textContent = `${motor['Name']} (${motorTorqueMin}-${motorTorqueMax} Nm)`;

                const passesTest = requiredTorque >= motorTorqueMin && requiredTorque <= motorTorqueMax;
                
                if (passesTest) {
                    option.classList.add('option-pass');
                    if (recommendedMotorIndexInFilteredList === -1) {
                        recommendedMotorIndexInFilteredList = index;
                    }
                } else {
                    option.classList.add('option-fail');
                    option.disabled = true; 
                }
                select.appendChild(option);
            });

            if (recommendedMotorIndexInFilteredList !== -1) {
                select.value = recommendedMotorIndexInFilteredList;
            } else {
                const noMotorOption = document.createElement('option');
                noMotorOption.value = "";
                noMotorOption.textContent = "-- No suitable motor found --";
                noMotorOption.selected = true;
                noMotorOption.disabled = true;
                select.prepend(noMotorOption);
            }

            updateSelectedMotorInfo();
        }
        
        function updateSelectedSafetyBrakeInfo() {
            const selectedIndex = dom.safetyBrakeSelector.value;
            const imageContainer = dom['safety-brake-image-container'];
            const imageDisplay = dom['safetyBrakeImageDisplay'];

            if (selectedIndex !== "" && safetyBrakeData[selectedIndex]) {
                const selectedBrake = safetyBrakeData[selectedIndex];
                dom['safety-brake-name'].textContent = selectedBrake.Name;
                dom['safety-brake-name'].classList.remove('warning-text');
                
                const driveshaftKey = Object.keys(selectedBrake).find(k => k.toLowerCase().trim() === 'driveshaft diameter mm');
                dom['safety-brake-driveshaft'].textContent = driveshaftKey ? selectedBrake[driveshaftKey] : 'N/A';

                const maxTorque = parseFloat(selectedBrake['Max Safety Torque (Nm)']);
                dom['safety-brake-capacity'].textContent = isNaN(maxTorque) ? 'N/A' : maxTorque.toFixed(2);
                
                const brakeName = selectedBrake.Name;
                if (safetyBrakeImageMap.has(brakeName)) {
                    imageDisplay.src = safetyBrakeImageMap.get(brakeName);
                    imageContainer.style.display = 'block';
                } else {
                    imageContainer.style.display = 'none';
                }

            } else {
                dom['safety-brake-name'].textContent = "No suitable safety brake found!";
                dom['safety-brake-name'].classList.add('warning-text');
                dom['safety-brake-driveshaft'].textContent = 'N/A';
                dom['safety-brake-capacity'].textContent = 'N/A';
                imageContainer.style.display = 'none';
            }
        }

        function updateSelectedMotorInfo() {
            const selectedMotorIndex = dom.motorSelector.value;
            if (selectedMotorIndex === "" || !currentFilteredMotors[selectedMotorIndex]) {
                 ['motor-name','motor-torque','motor-rpm','opening-time', 'power-consumed',
                  'motor-name-inputs', 'motor-torque-inputs'
                 ].forEach(id => { dom[id].textContent = 'N/A'; });
                 dom['motor-torque-line'].classList.remove('warning-text');
                 dom['motor-torque-line-inputs'].classList.remove('warning-text');
                return;
            }

            const selectedMotor = currentFilteredMotors[selectedMotorIndex];
            const motorTorqueMin = parseFloat(selectedMotor['Torque (Nm) min']);
            const motorTorqueMax = parseFloat(selectedMotor['Torque (Nm) max']);
            const motorRPM = parseFloat(selectedMotor['RPM']);
            const motorWattage = parseFloat(selectedMotor['Wattage']);
            
            dom['motor-name'].textContent = selectedMotor['Name'];
            dom['motor-torque'].textContent = `${motorTorqueMin} - ${motorTorqueMax}`; 
            dom['motor-rpm'].textContent = motorRPM;
            
            dom['motor-name-inputs'].textContent = selectedMotor['Name'];
            dom['motor-torque-inputs'].textContent = `${motorTorqueMin} - ${motorTorqueMax}`;

            let openingTimeSec = 0;
            if (motorRPM > 0 && calculatedRotations > 0) {
                openingTimeSec = (calculatedRotations / motorRPM) * 60;
                dom['opening-time'].textContent = openingTimeSec.toFixed(1);
            } else {
                dom['opening-time'].textContent = '0';
            }

            if (motorWattage > 0 && openingTimeSec > 0) {
                const cycleTimeSec = openingTimeSec * 2;
                const wattHours = (motorWattage * cycleTimeSec) / 3600;
                const kiloWattHours = wattHours / 1000;
                dom['power-consumed'].textContent = `${kiloWattHours.toFixed(4)} kWh`;
            } else {
                dom['power-consumed'].textContent = 'N/A';
            }

            const requiredTorque = parseFloat(dom['max-torque'].textContent);
            if (requiredTorque < motorTorqueMin || requiredTorque > motorTorqueMax) {
                dom['motor-torque-line'].classList.add('warning-text');
                dom['motor-torque-line-inputs'].classList.add('warning-text');
            } else {
                dom['motor-torque-line'].classList.remove('warning-text');
                dom['motor-torque-line-inputs'].classList.remove('warning-text');
            }
        }
        
        function updateSelectedWicketInfo() {
            const selectedIndex = dom.wicketDoorSelector.value;
            if (selectedIndex !== "" && wicketData[selectedIndex]) {
                const selectedDoor = wicketData[selectedIndex];
                dom['wicket-door-name'].textContent = selectedDoor.Name || 'N/A';
                dom['wicket-door-height'].textContent = selectedDoor.Height || '0';
                dom['wicket-door-width'].textContent = selectedDoor.Width || '0';
            } else {
                dom['wicket-door-name'].textContent = 'N/A';
                dom['wicket-door-height'].textContent = '0';
                dom['wicket-door-width'].textContent = '0';
            }
            updateWicketCalculationsAndGraphic();
        }

        function updateWicketCalculationsAndGraphic(endlockOffsets = {cast: 0, wind: 0}) {
            const selectedWicketIndex = dom.wicketDoorSelector.value;
            const selectedLathIndex = dom.lathType.value;
            const selectedBottomLathIndex = dom.bottomLathType.value;
            
            const selectedWicket = (wicketData && selectedWicketIndex !== "") ? wicketData[selectedWicketIndex] : null;
            const selectedLath = (lathData && selectedLathIndex !== "") ? lathData[selectedLathIndex] : null;
            const selectedBottomLath = (bottomLathData && selectedBottomLathIndex !== "") ? bottomLathData[selectedBottomLathIndex] : null;
            const selectedAxle = (axleData && dom.axleType.value !== "") ? axleData[dom.axleType.value] : null;

            let lathsAtWicket = 0;
            let wicketLathHeight = 0;

            if (selectedWicket && selectedLath && selectedBottomLath) {
                const wicketHeight = parseFloat(selectedWicket.Height) || 0;
                const bottomLathHeight = parseFloat(selectedBottomLath['BLath height']) || 0;
                const lathCompressedHeight = parseFloat(selectedLath['Compressed lath height']) || 0;

                if (lathCompressedHeight > 0 && wicketHeight > 0) {
                    const wicketGap = 10; // 10mm gap
                    const heightCoveredByWicketZone = wicketHeight + wicketGap;
                    const lathsInZone = Math.ceil(heightCoveredByWicketZone / lathCompressedHeight);
                    lathsAtWicket = lathsInZone;
                    wicketLathHeight = bottomLathHeight + (lathsInZone * lathCompressedHeight);
                }
            }
        
            dom['laths-at-wicket'].textContent = lathsAtWicket;
            dom['wicket-lath-height'].textContent = wicketLathHeight.toFixed(0);
            
            const selectedEndplateIndex = dom.endplateSelector.value;
            const selectedEndplate = (selectedEndplateIndex !== "" && currentFilteredEndplates[selectedEndplateIndex]) 
                ? currentFilteredEndplates[selectedEndplateIndex] 
                : null;
            
            drawWicketGraphic(
                parseFloat(dom.width.value),
                parseFloat(dom.additionalLength.value),
                parseInt(dom['lath-count'].textContent),
                selectedLath,
                selectedBottomLath,
                selectedAxle,
                selectedEndplate,
                selectedWicket,
                wicketLathHeight,
                endlockOffsets
            );
            
            calculateWicketTorque();
        }

        function calculateWicketTorque() {
            const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
            const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
            const selectedWicket = wicketData.length > 0 ? wicketData[dom.wicketDoorSelector.value] : null;
            const totalWeightKgs = parseFloat(dom['torque-weight-kg'].textContent) || 0;
            
            if (!selectedLath || !selectedAxle || !selectedWicket || totalWeightKgs <= 0) {
                dom['wicket-max-torque'].textContent = '0.0';
                drawTorqueGraph([], dom['wicket-torque-graph-container']);
                return;
            }
            
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            const bottomLathHeight = bottomLathData.length > 0 ? (parseFloat(bottomLathData[dom.bottomLathType.value]['BLath height']) || 0) : 0;
            const travelHeight = floorToAxleCenter - bottomLathHeight;

            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(selectedAxle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);

            const { profileData } = getTorqueProfileWithWicket(totalWeightKgs, selectedLath, travelHeight, selectedWicket, effectiveStartDiameter);
            
            const frictionMultiplier = 1 + (parseFloat(dom.friction.value) || 0) / 100;
            const adjustedProfile = profileData.map(item => ({...item, torque: item.torque * frictionMultiplier}));

            const requiredTorque = adjustedProfile.length > 0 ? Math.max(...adjustedProfile.map(p => p.torque)) : 0;
            dom['wicket-max-torque'].textContent = requiredTorque.toFixed(1);

            drawTorqueGraph(adjustedProfile, dom['wicket-torque-graph-container']);
        }

        function getTorqueProfileWithWicket(totalWeightKgs, lath, travelHeight, wicket, effectiveStartDiameter) {
            const profileData = []; 
            let heightLifted = 0; 
            let currentRollDiameter = effectiveStartDiameter;
            const lathThickness = parseFloat(lath['Thickness']);
            
            if (travelHeight <= 0 || totalWeightKgs <= 0) return { profileData: [], finalCoilDiameter: currentRollDiameter };

            const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
            const widthM = (parseFloat(dom.width.value) || 0) / 1000;
            const bottomLathHeight = parseFloat(selectedBottomLath['BLath height']) || 0;
            const bottomLathWeight = widthM * (parseFloat(selectedBottomLath['BLath weight / m length']) || 0);
            const lathsWeight = totalWeightKgs - bottomLathWeight;

            const wicketWidthM = (parseFloat(wicket.Width) || 0) / 1000;
            const wicketHeightM = (parseFloat(wicket.Height) || 0) / 1000;
            
            let lathKgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            if (dom.powderCoated.checked) {
                lathKgsPerM2 += 1;
            }
            
            const wicketWeightReduction = wicketWidthM * wicketHeightM * lathKgsPerM2;

            const wicketStartHeightFromBottomM = (bottomLathHeight / 1000) + (10 / 1000); // Add 10mm gap
            const wicketEndHeightFromBottomM = wicketStartHeightFromBottomM + wicketHeightM;

            while (heightLifted < travelHeight) {
                const percentLifted = heightLifted / travelHeight;
                const remainingLathWeight = lathsWeight * (1 - percentLifted);
                let remainingTotalWeight = remainingLathWeight + bottomLathWeight;
                
                const curtainHangingHeightM = (travelHeight - heightLifted) / 1000;
                
                let reduction = 0;
                if (curtainHangingHeightM >= wicketEndHeightFromBottomM) {
                    reduction = wicketWeightReduction;
                } else if (curtainHangingHeightM > wicketStartHeightFromBottomM) {
                    const hangingPortionHeight = curtainHangingHeightM - wicketStartHeightFromBottomM;
                    reduction = wicketWeightReduction * (hangingPortionHeight / wicketHeightM);
                }
                remainingTotalWeight -= reduction;
                remainingTotalWeight = Math.max(0, remainingTotalWeight);

                const force = remainingTotalWeight * 9.81; 
                const radiusM = (currentRollDiameter / 2) / 1000;
                profileData.push({ torque: force * radiusM, diameter: currentRollDiameter, heightLifted: heightLifted });
                
                const circumference = Math.PI * currentRollDiameter; 
                heightLifted += circumference / 2; 
                currentRollDiameter += lathThickness;
            } 
            return { profileData, finalCoilDiameter: currentRollDiameter };
        };

        function calculateTotalRevolutions(travelHeight, initialDiameter, lathThickness) {
            if (travelHeight <= 0 || initialDiameter <= 0 || lathThickness <= 0) return 0;
            const a = Math.PI * lathThickness;
            const b = Math.PI * initialDiameter;
            const c = -travelHeight;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return 0;
            return (-b + Math.sqrt(discriminant)) / (2 * a);
        }
        
        function getTorqueProfile(totalWeightKgs, lath, travelHeight, effectiveStartDiameter) {
            const profileData = []; 
            let heightLifted = 0; 
            let currentRollDiameter = effectiveStartDiameter;
            const lathThickness = parseFloat(lath['Thickness']);
            
            if (travelHeight <= 0 || totalWeightKgs <= 0) return { profileData: [], finalCoilDiameter: currentRollDiameter };

            const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
            const widthM = (parseFloat(dom.width.value) || 0) / 1000;
            const bottomLathWeight = widthM * (parseFloat(selectedBottomLath['BLath weight / m length']) || 0);
            const lathsWeight = totalWeightKgs - bottomLathWeight;

            while (heightLifted < travelHeight) {
                const percentLifted = heightLifted / travelHeight;
                const remainingLathWeight = lathsWeight * (1 - percentLifted);
                const remainingTotalWeight = remainingLathWeight + bottomLathWeight;
                
                const force = remainingTotalWeight * 9.81; 
                const radiusM = (currentRollDiameter / 2) / 1000;
                profileData.push({ torque: force * radiusM, diameter: currentRollDiameter, heightLifted: heightLifted });
                
                const circumference = Math.PI * currentRollDiameter; 
                heightLifted += circumference / 2; 
                currentRollDiameter += lathThickness;
            } 
            return { profileData, finalCoilDiameter: currentRollDiameter };
        };
        
        function populateDropdown(selectElement, dataArray, nameField) {
            selectElement.innerHTML = `<option value="">-- Select an option --</option>`;
            dataArray.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = index;
                const header = Object.keys(item).find(k => k.toLowerCase().trim() === nameField.toLowerCase().trim());
                option.textContent = item[header];
                selectElement.appendChild(option);
            });
        };
        
        function calculateCurtainProperties(lath, bottomLath, axle) {
            const visionEnabled = dom.addVision.checked;
            if (visionEnabled) {
                return calculateVisionCurtainProperties(lath, bottomLath, axle);
            }
        
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            if (!lath || !bottomLath || floorToAxleCenter <= 0) {
                dom['lath-count'].textContent = '0';
                dom['laths-to-lift'].textContent = '0';
                dom['weight-kg'].textContent = '0.00';
                dom['torque-weight-kg'].textContent = '0.00';
                dom['curtain-height-extended'].textContent = '0';
                dom['curtain-height-compressed'].textContent = '0';
                dom['curtain-area'].textContent = '0.00';
				dom['lifted-curtain-area'].textContent = '0.00';
                dom['vision-percentage-para'].style.display = 'none';
                dom['vision-area-m2-para'].style.display = 'none';
                dom['endlock-weight'].textContent = '0.00';
                return { totalWeight: 0, torqueWeight: 0, travelHeight: 0, fullCurtainLength: 0, visionData: null, endlockOffsets: { cast: 0, wind: 0 } };
            }

            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const uncompressedLathHeight = parseFloat(lath['uncompressed lath height']);
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
            
            let axleRadius = 0;
            if (axle) {
                 const axleCoilDiameter = getEffectiveCoilDiameter(axle);
                axleRadius = axleCoilDiameter / 2;
            } else if (axleData.length > 0) {
                axleRadius = (getEffectiveCoilDiameter(axleData[0])) / 2;
            }

            const heightToCoverByLaths = (floorToAxleCenter - bottomLathHeight) + axleRadius;

            let numLaths = 0;
            if (lathCompressedHeight > 0 && heightToCoverByLaths > 0) {
                numLaths = Math.ceil(heightToCoverByLaths / lathCompressedHeight) + 2;
            }
            dom['lath-count'].textContent = numLaths;
            const numLathsToLift = numLaths >= 3 ? numLaths - 3 : 0;
            dom['laths-to-lift'].textContent = numLathsToLift;

            const compressedCurtainHeight = (numLaths * lathCompressedHeight) + bottomLathHeight;
            const fullCurtainLength = (numLaths * uncompressedLathHeight) + bottomLathHeight;

            dom['curtain-height-extended'].textContent = fullCurtainLength.toFixed(0);
            dom['curtain-height-compressed'].textContent = compressedCurtainHeight.toFixed(0);

            const widthM = (parseFloat(dom.width.value) || 0) / 1000;
            
            let kgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            if (dom.powderCoated.checked) {
                kgsPerM2 += 1;
            }
            
            // Calculate Total MATERIAL Area (uses uncompressed height)
            const totalMaterialAreaM2 = widthM * (fullCurtainLength / 1000);
            dom['curtain-area'].textContent = totalMaterialAreaM2.toFixed(2);
			
			// Calculate Lifted COVERAGE Area (uses compressed height)
			const liftedLathCoverageLength = (numLathsToLift * lathCompressedHeight);
			const liftedCoverageAreaM2 = widthM * (liftedLathCoverageLength / 1000);
			dom['lifted-curtain-area'].textContent = liftedCoverageAreaM2.toFixed(2);

            // Calculate weight based on COVERAGE area, not material area
            const lathWeightBasedOnCoverage = widthM * (numLaths * lathCompressedHeight / 1000) * kgsPerM2;
            const bottomLathWeight = widthM * (parseFloat(bottomLath['BLath weight / m length']) || 0);

            let totalEndlockWeight = 0;
            const lathName = (lath['Name'] || '').toLowerCase();
            const isWindLath = lathName.includes('wind');
            let endlockOffsets = { cast: 0, wind: 0 };
            
            if (numLaths > 0 && endlockData.length > 0) {
                const selectedCastEndlockIndex = dom.endlockType.value;
                let castEndlockWeightG = 0;
                if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const selectedEndlock = endlockData[selectedCastEndlockIndex];
                    const weightKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                    castEndlockWeightG = weightKey ? parseFloat(selectedEndlock[weightKey]) : 0;
                    const offsetKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                    endlockOffsets.cast = offsetKey ? parseFloat(selectedEndlock[offsetKey]) : 0;
                }

                if (isWindLath) {
                    let windEndlockWeightG = 0;
                    const windEndlock = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
                    if (windEndlock) {
                        const weightKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                        windEndlockWeightG = weightKey ? parseFloat(windEndlock[weightKey]) : 0;
                        const offsetKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                        endlockOffsets.wind = offsetKey ? parseFloat(windEndlock[offsetKey]) : 0;
                    }

                    for (let i = 1; i <= numLaths; i++) {
                        if (i % 2 !== 0 && castEndlockWeightG > 0) {
                            totalEndlockWeight += 2 * (castEndlockWeightG / 1000);
                        }
                        const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                        if (isWindLathPosition && windEndlockWeightG > 0) {
                            totalEndlockWeight += 2 * (windEndlockWeightG / 1000);
                        }
                    }
                } else {
                    if (castEndlockWeightG > 0) {
                         const numEndlockPairs = Math.ceil(numLaths / 2);
                         totalEndlockWeight = numEndlockPairs * 2 * (castEndlockWeightG / 1000);
                    }
                }
            }
            dom['endlock-weight'].textContent = totalEndlockWeight.toFixed(2);
            const totalWeight = lathWeightBasedOnCoverage + bottomLathWeight + totalEndlockWeight;
            dom['weight-kg'].textContent = totalWeight.toFixed(2);
            
            // Calculate Torque Weight (Total weight minus 3 buffer laths and their endlocks)
            let torqueWeight = totalWeight;
            if (numLaths >= 3) {
                const bufferLathWeight = 3 * (lathCompressedHeight / 1000) * widthM * kgsPerM2;
                let bufferEndlockWeight = 0;
                // Simplified: assume 3 laths have 2 pairs of cast endlocks.
                const selectedCastEndlockIndex = dom.endlockType.value;
                if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const weightKey = Object.keys(endlockData[selectedCastEndlockIndex]).find(k => k.toLowerCase().trim() === 'weight in grams');
                    const castEndlockWeightG = weightKey ? parseFloat(endlockData[selectedCastEndlockIndex][weightKey]) : 0;
                    if (castEndlockWeightG > 0) {
                        bufferEndlockWeight = 4 * (castEndlockWeightG / 1000); // two pairs
                    }
                }
                torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
            }
            dom['torque-weight-kg'].textContent = torqueWeight.toFixed(2);
            
            const travelHeight = floorToAxleCenter - bottomLathHeight;
            
            const mainLathVisionKey = Object.keys(lath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const mainLathVisionPercent = mainLathVisionKey ? (parseFloat(lath[mainLathVisionKey]) || 0) : 0;

            if (mainLathVisionPercent > 0) {
                const visionArea = totalMaterialAreaM2 * (mainLathVisionPercent / 100);
                dom['vision-area-m2'].textContent = visionArea.toFixed(2);
                dom['vision-percentage'].textContent = mainLathVisionPercent.toFixed(2);
                
                dom['vision-percentage-para'].style.display = 'block';
                dom['vision-area-m2-para'].style.display = 'block';
            } else {
                dom['vision-percentage-para'].style.display = 'none';
                dom['vision-area-m2-para'].style.display = 'none';
            }
            
            return { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData: null, endlockOffsets };
        };
        
        function calculateVisionCurtainProperties(mainLath, bottomLath, axle) {
            const visionLath = lathData[dom.visionLathType.value];
            const widthM = (parseFloat(dom.width.value) || 0) / 1000;
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            const desiredVisionStart = parseFloat(dom.visionStartHeight.value) || 0;
            const desiredVisionPanelHeight = parseFloat(dom.visionPanelHeight.value) || 0;
            let endlockOffsets = { cast: 0, wind: 0 };

            const resetAndReturn = () => {
                dom['lath-count'].textContent = '0';
                dom['laths-to-lift'].textContent = '0';
                dom['weight-kg'].textContent = '0.00';
                dom['torque-weight-kg'].textContent = '0.00';
                dom['curtain-height-extended'].textContent = '0';
                dom['curtain-height-compressed'].textContent = '0';
                dom['curtain-area'].textContent = '0.00';
				dom['lifted-curtain-area'].textContent = '0.00';
                dom['vision-percentage-para'].style.display = 'none';
                dom['vision-area-m2-para'].style.display = 'none';
                dom['endlock-weight'].textContent = '0.00';
                return { totalWeight: 0, torqueWeight: 0, travelHeight: 0, fullCurtainLength: 0, visionData: null, endlockOffsets };
            };

            if (!mainLath || !bottomLath || !visionLath || !axle || floorToAxleCenter <= 0 || widthM <= 0) {
                return resetAndReturn();
            }

            const mainLathCompressed = parseFloat(mainLath['Compressed lath height']);
            const mainLathUncompressed = parseFloat(mainLath['uncompressed lath height']) || mainLathCompressed;
            let mainLathKgsM2 = parseFloat(mainLath['Kgs/ m2']);
            if (dom.powderCoated.checked) {
                mainLathKgsM2 += 1;
            }

            const visionLathCompressed = parseFloat(visionLath['Compressed lath height']);
            const visionLathUncompressed = parseFloat(visionLath['uncompressed lath height']) || visionLathCompressed;
            let visionLathKgsM2 = parseFloat(visionLath['Kgs/ m2']);
            if (dom.powderCoated.checked) {
                visionLathKgsM2 += 1;
            }

            if (isNaN(mainLathCompressed) || isNaN(visionLathCompressed) || mainLathCompressed <= 0 || visionLathCompressed <= 0) {
                 return resetAndReturn();
            }

            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
            const bottomLathWeightPerM = parseFloat(bottomLath['BLath weight / m length']) || 0;
            const axleRadius = getEffectiveCoilDiameter(axle) / 2;
            
            let numLathsBelow = 0;
            if (desiredVisionStart > bottomLathHeight) {
                numLathsBelow = Math.round((desiredVisionStart - bottomLathHeight) / mainLathCompressed);
            }
            
            let numLathsVision = 0;
            if (desiredVisionPanelHeight > 0) {
                numLathsVision = Math.round(desiredVisionPanelHeight / visionLathCompressed);
            }

            const heightCoveredSoFar_compressed = bottomLathHeight + (numLathsBelow * mainLathCompressed) + (numLathsVision * visionLathCompressed);
            const remainingHeightToCover = (floorToAxleCenter + axleRadius) - heightCoveredSoFar_compressed;
            
            let numLathsAbove = 0;
            if (remainingHeightToCover > 0) {
                numLathsAbove = Math.ceil(remainingHeightToCover / mainLathCompressed) + 2;
            }

            const totalNumLaths = numLathsBelow + numLathsVision + numLathsAbove;
            dom['lath-count'].textContent = totalNumLaths;
            const numLathsToLift = totalNumLaths >= 3 ? totalNumLaths - 3 : 0;
            dom['laths-to-lift'].textContent = numLathsToLift;
            
            // Calculate Weights based on COVERAGE area
            const weightBelow = numLathsBelow * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
            const weightVision = numLathsVision * (visionLathCompressed / 1000) * widthM * visionLathKgsM2;
            const weightAbove = numLathsAbove * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
            const bottomLathWeight = widthM * bottomLathWeightPerM;
            
            let totalEndlockWeight = 0;
            const lathName = (mainLath['Name'] || '').toLowerCase();
            const isWindLath = lathName.includes('wind');

            if (totalNumLaths > 0 && endlockData.length > 0) {
                const selectedCastEndlockIndex = dom.endlockType.value;
                let castEndlockWeightG = 0;
                if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const selectedEndlock = endlockData[selectedCastEndlockIndex];
                    const weightKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                    castEndlockWeightG = weightKey ? parseFloat(selectedEndlock[weightKey]) : 0;
                    const offsetKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                    endlockOffsets.cast = offsetKey ? parseFloat(selectedEndlock[offsetKey]) : 0;
                }

                if (isWindLath) {
                    let windEndlockWeightG = 0;
                    const windEndlock = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
                    if (windEndlock) {
                        const weightKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                        windEndlockWeightG = weightKey ? parseFloat(windEndlock[weightKey]) : 0;
                        const offsetKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                        endlockOffsets.wind = offsetKey ? parseFloat(windEndlock[offsetKey]) : 0;
                    }

                    for (let i = 1; i <= totalNumLaths; i++) {
                        if (i % 2 !== 0 && castEndlockWeightG > 0) {
                            totalEndlockWeight += 2 * (castEndlockWeightG / 1000);
                        }
                        const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                        if (isWindLathPosition && windEndlockWeightG > 0) {
                            totalEndlockWeight += 2 * (windEndlockWeightG / 1000);
                        }
                    }
                } else {
                    if (castEndlockWeightG > 0) {
                         const numEndlockPairs = Math.ceil(totalNumLaths / 2);
                         totalEndlockWeight = numEndlockPairs * 2 * (castEndlockWeightG / 1000);
                    }
                }
            }
            dom['endlock-weight'].textContent = totalEndlockWeight.toFixed(2);
            const totalWeight = weightBelow + weightVision + weightAbove + bottomLathWeight + totalEndlockWeight;
            dom['weight-kg'].textContent = totalWeight.toFixed(2);

            // Calculate Torque Weight (Total weight minus 3 buffer laths and their endlocks)
            let torqueWeight = totalWeight;
            if (numLathsAbove >= 3) {
                const bufferLathWeight = 3 * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
                let bufferEndlockWeight = 0;
                const selectedCastEndlockIndex = dom.endlockType.value;
                 if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const weightKey = Object.keys(endlockData[selectedCastEndlockIndex]).find(k => k.toLowerCase().trim() === 'weight in grams');
                    const castEndlockWeightG = weightKey ? parseFloat(endlockData[selectedCastEndlockIndex][weightKey]) : 0;
                    if (castEndlockWeightG > 0) {
                        bufferEndlockWeight = 4 * (castEndlockWeightG / 1000); // two pairs for 3 laths
                    }
                }
                torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
            }
            dom['torque-weight-kg'].textContent = torqueWeight.toFixed(2);

            const compressedCurtainHeight = bottomLathHeight + (numLathsBelow * mainLathCompressed) + (numLathsVision * visionLathCompressed) + (numLathsAbove * mainLathCompressed);
            const fullCurtainLength = bottomLathHeight + (numLathsBelow * mainLathUncompressed) + (numLathsVision * visionLathUncompressed) + (numLathsAbove * mainLathUncompressed);
            
            // Calculate Total MATERIAL Area
            const areaBelowMaterial = numLathsBelow * (mainLathUncompressed / 1000) * widthM;
            const areaVisionMaterial = numLathsVision * (visionLathUncompressed / 1000) * widthM;
            const areaAboveMaterial = numLathsAbove * (mainLathUncompressed / 1000) * widthM;
            const totalMaterialArea = areaBelowMaterial + areaVisionMaterial + areaAboveMaterial;
            dom['curtain-area'].textContent = totalMaterialArea.toFixed(2);

			// Calculate Lifted COVERAGE Area
			const areaBelowCoverage = numLathsBelow * (mainLathCompressed / 1000) * widthM;
			const areaVisionCoverage = numLathsVision * (visionLathCompressed / 1000) * widthM;
			const numLiftedLathsAbove = Math.max(0, numLathsAbove - 3);
			const liftedAreaAboveCoverage = numLiftedLathsAbove * (mainLathCompressed / 1000) * widthM;
			const liftedCoverageArea = areaBelowCoverage + areaVisionCoverage + liftedAreaAboveCoverage;
			dom['lifted-curtain-area'].textContent = liftedCoverageArea.toFixed(2);

            dom['curtain-height-extended'].textContent = fullCurtainLength.toFixed(0);
            dom['curtain-height-compressed'].textContent = compressedCurtainHeight.toFixed(0);

            const travelHeight = floorToAxleCenter - bottomLathHeight;
            
            const actualVisionStartHeight = bottomLathHeight + (numLathsBelow * mainLathCompressed);
            const actualVisionPanelHeight = numLathsVision * visionLathCompressed;

            const mainLathVisionKey = Object.keys(mainLath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const mainLathVisionPercent = mainLathVisionKey ? (parseFloat(mainLath[mainLathVisionKey]) || 0) : 0;
            
            const visionLathVisionKey = Object.keys(visionLath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const visionLathVisionPercent = visionLathVisionKey ? (parseFloat(visionLath[visionLathVisionKey]) || 0) : 0;

            const visionAreaFromMain = (areaBelowMaterial + areaAboveMaterial) * (mainLathVisionPercent / 100);
            const visionAreaFromVisionPanel = areaVisionMaterial * (visionLathVisionPercent / 100);
            const totalActualVisionArea = visionAreaFromMain + visionAreaFromVisionPanel;
            
            const overallVisionPercentage = (totalMaterialArea > 0) ? (totalActualVisionArea / totalMaterialArea) * 100 : 0;
            
            dom['vision-area-m2'].textContent = totalActualVisionArea.toFixed(2);
            dom['vision-percentage'].textContent = overallVisionPercentage.toFixed(2);

            dom['vision-percentage-para'].style.display = 'block';
            dom['vision-area-m2-para'].style.display = 'block';

            const visionData = {
                visionLath,
                numLathsBelow,
                numLathsVision,
                numLathsAbove,
                actualVisionStartHeight,
                actualVisionPanelHeight
            };

            return { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData, endlockOffsets };
        }

        function drawTorqueGraph(profileData, container) {
            container.innerHTML = '';
            if (!profileData || profileData.length === 0) return;
            
            const svgNS = "http://www.w3.org/2000/svg", svg = document.createElementNS(svgNS, "svg");
            let svgWidth = container.clientWidth;
            if (svgWidth === 0) svgWidth = 550; 
            let svgHeight = container.clientHeight;
            if (svgHeight === 0) svgHeight = 280;
            
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const padding = { top: 30, right: 20, bottom: 60, left: 40 }; 
            const graphWidth = svgWidth - padding.left - padding.right;
            const graphHeight = svgHeight - padding.top - padding.bottom;
            const maxTorque = Math.max(...profileData.map(p => p.torque)) * 1.1 || 10;

            const yAxis = document.createElementNS(svgNS, 'line');
            yAxis.setAttribute('x1', padding.left); yAxis.setAttribute('y1', padding.top);
            yAxis.setAttribute('x2', padding.left); yAxis.setAttribute('y2', padding.top + graphHeight);
            yAxis.setAttribute('class', 'axis-line');
            svg.appendChild(yAxis);
            
            const xLabel = document.createElementNS(svgNS, 'text');
            xLabel.setAttribute('class', 'graph-text');
            xLabel.setAttribute('transform', `translate(${svgWidth/2}, ${svgHeight - 15})`);
            xLabel.textContent = 'Coil Diameter (mm) / Revolutions';
            svg.appendChild(xLabel);
            
            const barWidth = Math.max(5, graphWidth / profileData.length * 0.8);
            const barSpacing = Math.max(1, graphWidth / profileData.length * 0.2);

            profileData.forEach((item, index) => {
                const barHeight = (item.torque / maxTorque) * graphHeight;
                const x = padding.left + index * (barWidth + barSpacing);
                const y = padding.top + graphHeight - barHeight;
                const revs = (index + 1) * 0.5;

                const bar = document.createElementNS(svgNS, 'rect');
                bar.setAttribute('x', x);
                bar.setAttribute('y', y);
                bar.setAttribute('width', barWidth);
                bar.setAttribute('height', barHeight);
                bar.setAttribute('class', 'torque-bar');
                
                const title = document.createElementNS(svgNS, 'title');
                title.textContent = `Rev ${revs.toFixed(1)}: ${item.torque.toFixed(1)} Nm | Dia: ${item.diameter.toFixed(0)} mm`;
                bar.appendChild(title);
                svg.appendChild(bar);

                const textX = x + barWidth / 2;

                if (barHeight > 15) {
                    const torqueText = document.createElementNS(svgNS, 'text');
                    torqueText.setAttribute('x', textX);
                    torqueText.setAttribute('y', y - 5); 
                    torqueText.setAttribute('class', 'graph-data-label'); 
                    torqueText.textContent = `${item.torque.toFixed(1)} Nm`;
                    svg.appendChild(torqueText);
                }

                const showAxisLabel = profileData.length < 15 || index % Math.ceil(profileData.length / 15) === 0;
                if (showAxisLabel) {
                    const diaText = document.createElementNS(svgNS, 'text');
                    diaText.setAttribute('x', textX);
                    diaText.setAttribute('y', padding.top + graphHeight + 15); 
                    diaText.setAttribute('class', 'graph-data-label');
                    diaText.textContent = `Ø${item.diameter.toFixed(0)}`;
                    svg.appendChild(diaText);
                
                    const revText = document.createElementNS(svgNS, 'text');
                    revText.setAttribute('x', textX);
                    revText.setAttribute('y', padding.top + graphHeight + 28);
                    revText.setAttribute('class', 'graph-data-label');
                    revText.textContent = `(${revs.toFixed(1)}r)`;
                    svg.appendChild(revText);
                }
            });
            container.appendChild(svg);
        }
        
        function drawDeflectionGraphic(length, deflection, isWarning = false) {
            const container = dom['deflection-graphic-container'];
            container.innerHTML = '';
            
            const svgNS = "http://www.w3.org/2000/svg", svg = document.createElementNS(svgNS, "svg");
            let svgWidth = container.clientWidth;
            if (svgWidth === 0) svgWidth = 550;
            let svgHeight = container.clientHeight;
            if (svgHeight === 0) svgHeight = 150;

            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            const padding = 30, beamY = svgHeight / 2 + 10;
            const maxVisualDeflection = svgHeight * 0.3;
            const numericDeflection = parseFloat(deflection) || 0;
            const visualDeflection = Math.min(maxVisualDeflection, numericDeflection * (maxVisualDeflection / 25));

            const startX = padding, endX = svgWidth - padding;
            
            const refPath = document.createElementNS(svgNS, 'path');
            refPath.setAttribute('d', `M ${startX} ${beamY} H ${endX}`);
            refPath.setAttribute('class', 'beam-path');
            svg.appendChild(refPath);

            const deflectedPath = document.createElementNS(svgNS, 'path');
            const controlX = svgWidth / 2, controlY = beamY + visualDeflection;
            deflectedPath.setAttribute('d', `M ${startX},${beamY} Q ${controlX},${controlY} ${endX},${beamY}`);
            deflectedPath.setAttribute('class', 'deflected-path');
            
            const ratio = (numericDeflection > 0) ? length / numericDeflection : Infinity;
            if (isWarning || numericDeflection > 25 || ratio < 400) {
                 deflectedPath.classList.add('warning');
            }
            svg.appendChild(deflectedPath);

            const supportSize = 10;
            const leftSupport = document.createElementNS(svgNS, 'path');
            leftSupport.setAttribute('d', `M ${startX} ${beamY} l -${supportSize/2} ${supportSize} h ${supportSize} z`);
            leftSupport.setAttribute('class', 'support-symbol');
            svg.appendChild(leftSupport);
            
            const rightSupport = document.createElementNS(svgNS, 'path');
            rightSupport.setAttribute('d', `M ${endX} ${beamY} l -${supportSize/2} ${supportSize} h ${supportSize} z`);
            rightSupport.setAttribute('class', 'support-symbol');
            svg.appendChild(rightSupport);

            if (numericDeflection > 0.1) {
                const text = document.createElementNS(svgNS, 'text');
                text.setAttribute('x', controlX);
                text.setAttribute('y', controlY + 15);
                text.setAttribute('class', 'graph-text');
                text.textContent = `${numericDeflection.toFixed(2)} mm`;
                svg.appendChild(text);
            }
            container.appendChild(svg);
        }

        function drawEndplateForceDiagram(downwardForce, pulloutForce, offsetM, fixingSeparation, endplateSize) {
            const container = dom['endplate-force-diagram-container'];
            container.innerHTML = '';
            if (downwardForce <= 0 && pulloutForce <= 0) return;

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 550;
            const svgHeight = 250;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            const defs = document.createElementNS(svgNS, 'defs');
            const createMarker = (id, color) => {
                const marker = document.createElementNS(svgNS, 'marker');
                marker.setAttribute('id', id);
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '10');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '6');
                marker.setAttribute('markerHeight', '6');
                marker.setAttribute('orient', 'auto');
                const arrowPath = document.createElementNS(svgNS, 'path');
                arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
                arrowPath.setAttribute('fill', color);
                marker.appendChild(arrowPath);
                return marker;
            };

            defs.appendChild(createMarker('arrow-force-red', '#d93025'));
            defs.appendChild(createMarker('arrow-force-blue', '#007bff'));
            defs.appendChild(createMarker('arrow-dim', '#343a40'));
            svg.appendChild(defs);
            
            const createElem = (type, attrs) => {
                const el = document.createElementNS(svgNS, type);
                for (const key in attrs) el.setAttribute(key, attrs[key]);
                return el;
            };

            const wallX = 150;
            const wallTop = 20;
            const wallBottom = svgHeight - 40;
            
            svg.appendChild(createElem('line', { x1: wallX, y1: wallTop, x2: wallX, y2: wallBottom, stroke: '#343a40', 'stroke-width': '4' }));
            const wallLabel = createElem('text', { x: wallX - 10, y: wallBottom, class: 'dimension-text', 'text-anchor': 'end' });
            wallLabel.textContent = "Wall";
            svg.appendChild(wallLabel);

            const plateWidth = 20;
            const plateHeight = 160;
            const plateY = (svgHeight - plateHeight) / 2;
            svg.appendChild(createElem('rect', { x: wallX, y: plateY, width: plateWidth, height: plateHeight, fill: '#adb5bd', stroke: '#495057', 'stroke-width': '1' }));

            const plateCenterY = plateY + plateHeight / 2;
            const scaledFixingSep = Math.min(plateHeight * 0.7, fixingSeparation * 0.4); 
            const topFixingY = plateCenterY - scaledFixingSep / 2;
            const bottomFixingY = plateCenterY + scaledFixingSep / 2;
            const fixingX = wallX + plateWidth / 2;
            svg.appendChild(createElem('circle', { cx: fixingX, cy: topFixingY, r: 4, fill: '#495057' }));
            svg.appendChild(createElem('circle', { cx: fixingX, cy: bottomFixingY, r: 4, fill: '#495057' }));

            const coilCenterX = wallX + plateWidth + (offsetM * 1000 * 0.4);
            const coilCenterY = plateCenterY;
            const coilRadius = 40;
            svg.appendChild(createElem('circle', { cx: coilCenterX, cy: coilCenterY, r: coilRadius, fill: '#e9ecef', stroke: '#adb5bd', 'stroke-width': '2', 'stroke-dasharray': '4,2' }));
            svg.appendChild(createElem('circle', { cx: coilCenterX, cy: coilCenterY, r: 5, fill: '#6c757d' }));

            const redForceArrow = { stroke: '#d93025', 'stroke-width': '2', 'marker-end': 'url(#arrow-force-red)' };
            const redForceText = { fill: '#d93025', 'font-size': '11px', 'font-weight': 'bold' };
            const blueForceArrow = { stroke: '#007bff', 'stroke-width': '2', 'marker-end': 'url(#arrow-force-blue)' };
            const blueForceText = { fill: '#007bff', 'font-size': '11px', 'font-weight': 'bold' };
            const dimLineStyle = { class: 'dimension-line', 'marker-start': 'url(#arrow-dim)', 'marker-end': 'url(#arrow-dim)' };

            const mainForceYEnd = coilCenterY + coilRadius + 40;
            svg.appendChild(createElem('line', { x1: coilCenterX, y1: coilCenterY, x2: coilCenterX, y2: mainForceYEnd, ...redForceArrow }));
            const mainForceTextEl = createElem('text', { x: coilCenterX + 5, y: mainForceYEnd, 'text-anchor': 'start', ...redForceText });
            mainForceTextEl.textContent = `Shear Force on Plate: ${downwardForce.toFixed(0)} N`;
            svg.appendChild(mainForceTextEl);
            
            const pulloutXEnd = wallX - 50;
            svg.appendChild(createElem('line', { x1: wallX, y1: topFixingY, x2: pulloutXEnd, y2: topFixingY, ...redForceArrow }));
            const pulloutTextEl = createElem('text', { x: pulloutXEnd - 5, y: topFixingY - 5, 'text-anchor': 'end', ...redForceText });
            pulloutTextEl.textContent = `Pull-out: ${pulloutForce.toFixed(0)} N`;
            svg.appendChild(pulloutTextEl);

            const compressionXStart = wallX - 50;
            svg.appendChild(createElem('line', { x1: compressionXStart, y1: bottomFixingY, x2: wallX, y2: bottomFixingY, ...blueForceArrow }));
            const compressionTextEl = createElem('text', { x: compressionXStart - 5, y: bottomFixingY - 5, 'text-anchor': 'end', ...blueForceText });
            compressionTextEl.textContent = `Compression: ${pulloutForce.toFixed(0)} N`;
            svg.appendChild(compressionTextEl);

            const shearForce = downwardForce / 2;
            const shearYEnd = 40;
            svg.appendChild(createElem('line', { x1: fixingX, y1: topFixingY, x2: fixingX, y2: topFixingY + shearYEnd, ...redForceArrow }));
            svg.appendChild(createElem('line', { x1: fixingX, y1: bottomFixingY, x2: fixingX, y2: bottomFixingY + shearYEnd, ...redForceArrow }));
            const shearTextEl = createElem('text', { x: fixingX + 5, y: bottomFixingY + shearYEnd, 'text-anchor': 'start', ...redForceText });
            shearTextEl.textContent = `Shear (each): ${shearForce.toFixed(0)} N`;
            svg.appendChild(shearTextEl);
            
            const fixDimX = wallX + plateWidth + 25;
            svg.appendChild(createElem('line', { x1: fixDimX, y1: topFixingY, x2: fixDimX, y2: bottomFixingY, ...dimLineStyle }));
            const fixTextEl = createElem('text', { x: fixDimX + 8, y: plateCenterY, class: 'dimension-text', 'dominant-baseline': 'middle', 'text-anchor': 'middle', transform: `rotate(-90, ${fixDimX + 8}, ${plateCenterY})` });
            fixTextEl.textContent = `${fixingSeparation.toFixed(0)} mm`;
            svg.appendChild(fixTextEl);

            const offsetDimY = wallBottom + 15;
            svg.appendChild(createElem('line', { x1: wallX, y1: offsetDimY, x2: coilCenterX, y2: offsetDimY, ...dimLineStyle }));
            const offsetTextEl = createElem('text', { x: wallX + (coilCenterX - wallX)/2, y: offsetDimY + 12, class: 'dimension-text' });
            offsetTextEl.textContent = `Offset: ${(offsetM * 1000).toFixed(0)} mm`;
            svg.appendChild(offsetTextEl);

            container.appendChild(svg);
        }

        function drawEndplateGraphic(endplate, coilDiameter, axle, lath, numLaths) {
            const container = dom['endplate-graphic-container'];
            container.innerHTML = '';
            if (!endplate || !coilDiameter || !axle || !lath || !numLaths || coilDiameter <= 0) {
                return;
            }

            const endplateSize = parseFloat(endplate.Size);
            const lathThickness = parseFloat(lath['Thickness']);
            if (isNaN(endplateSize) || isNaN(lathThickness) || endplateSize <= 0) return;

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 550;
            const svgHeight = 250;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', 'arrow-endplate');
            marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '1');
            marker.setAttribute('refY', '5');
            marker.setAttribute('markerWidth', '5');
            marker.setAttribute('markerHeight', '5');
            marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path');
            arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
            arrowPath.setAttribute('fill', '#343a40');
            marker.appendChild(arrowPath);
            defs.appendChild(marker);
            svg.appendChild(defs);

            const padding = { top: 20, right: 120, bottom: 40, left: 20 };
            const graphHeight = svgHeight - padding.top - padding.bottom;
            
            const scale = graphHeight / endplateSize;
            const scaledBoxSize = endplateSize * scale;
            
            const boxX = padding.left;
            const boxY = padding.top + (graphHeight - scaledBoxSize) / 2;
            const centerX = boxX + scaledBoxSize / 2;
            const centerY = boxY + scaledBoxSize / 2;

            const createElem = (type, attrs) => {
                const el = document.createElementNS(svgNS, type);
                for (const key in attrs) el.setAttribute(key, attrs[key]);
                return el;
            };

            // Draw Endplate Box
            svg.appendChild(createElem('rect', {
                x: boxX, y: boxY, width: scaledBoxSize, height: scaledBoxSize,
                fill: '#f8f9fa', stroke: '#ced4da', 'stroke-width': '1'
            }));

            // Draw Axle
            const axleDiameter = getEffectiveCoilDiameter(axle);
            const scaledAxleRadius = (axleDiameter / 2) * scale;
            svg.appendChild(createElem('circle', {
                cx: centerX, cy: centerY, r: scaledAxleRadius,
                class: 'shutter-axle-graphic'
            }));

            // Draw each lath wrap based on total laths
            for (let i = 1; i <= numLaths; i++) {
                const currentRadius = (axleDiameter / 2) + (i * lathThickness);
                if (currentRadius * 2 > coilDiameter) break; // Don't draw outside the final calculated diameter
                svg.appendChild(createElem('circle', {
                    cx: centerX, cy: centerY, r: currentRadius * scale,
                    class: 'coil-wrap-graphic'
                }));
            }
            
            // Draw Final Coil Outline
            const scaledCoilRadius = (coilDiameter / 2) * scale;
            svg.appendChild(createElem('circle', {
                cx: centerX, cy: centerY, r: scaledCoilRadius,
                fill: 'none', stroke: '#007bff', 'stroke-width': '2'
            }));

            // Dimensions
            const dimLineX = boxX + scaledBoxSize + 25;
            svg.appendChild(createElem('line', { x1: boxX, y1: boxY, x2: dimLineX, y2: boxY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: boxX, y1: boxY + scaledBoxSize, x2: dimLineX, y2: boxY + scaledBoxSize, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: dimLineX, y1: boxY, x2: dimLineX, y2: boxY + scaledBoxSize, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
            const boxSizeTextX = dimLineX + 12;
            const boxSizeText = createElem('text', { x: boxSizeTextX, y: centerY, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${boxSizeTextX}, ${centerY})` });
            boxSizeText.textContent = `${endplateSize.toFixed(0)} mm`;
            svg.appendChild(boxSizeText);
            
            const coilDimY = boxY + scaledBoxSize + 20;
            svg.appendChild(createElem('line', { x1: centerX - scaledCoilRadius, y1: centerY, x2: centerX - scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: centerX + scaledCoilRadius, y1: centerY, x2: centerX + scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: centerX - scaledCoilRadius, y1: coilDimY, x2: centerX + scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
            const coilDimText = createElem('text', { x: centerX, y: coilDimY + 15, class: 'large-dimension-text' });
            coilDimText.textContent = `Ø ${coilDiameter.toFixed(1)} mm`;
            svg.appendChild(coilDimText);

            const clearance = (endplateSize - coilDiameter) / 2;
            if (clearance > 1) {
                const clearanceDimX = dimLineX + 40;
                const topY = boxY;
                const coilTopY = centerY - scaledCoilRadius;
                svg.appendChild(createElem('line', { x1: centerX, y1: topY, x2: clearanceDimX, y2: topY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
                svg.appendChild(createElem('line', { x1: centerX, y1: coilTopY, x2: clearanceDimX, y2: coilTopY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
                svg.appendChild(createElem('line', { x1: clearanceDimX, y1: topY, x2: clearanceDimX, y2: coilTopY, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
                const clearanceTextX = clearanceDimX + 12;
                const clearanceText = createElem('text', { x: clearanceTextX, y: topY + (coilTopY - topY) / 2, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${clearanceTextX}, ${topY + (coilTopY - topY) / 2})` });
                clearanceText.textContent = `${clearance.toFixed(1)} mm`;
                svg.appendChild(clearanceText);
            }
            
            container.appendChild(svg);
        }

        function drawAxleCrossSection(axle, collarSize = 0) {
            const container = dom['axle-cross-section-container'];
            container.innerHTML = '';
            if (!axle) return;

            const outerDia = parseFloat(axle['Diameter']);
            const wallThick = parseFloat(axle['Wall Thickness']);
            const shape = (axle['Shape'] || 'circular').toLowerCase();

            if (isNaN(outerDia) || isNaN(wallThick) || outerDia <= 0 || wallThick <= 0) return;
            
            const innerDia = outerDia - (2 * wallThick);

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 550;
            const svgHeight = 250;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            const padding = { top: 20, right: 100, bottom: 20, left: 100 };
            const graphSize = Math.min(svgWidth - padding.left - padding.right, svgHeight - padding.top - padding.bottom) * 0.75;
            
            const displayDiameter = collarSize > outerDia ? collarSize : outerDia;
            const scale = graphSize / displayDiameter;
            const cx = svgWidth / 2;
            const cy = svgHeight / 2;

            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', 'arrow');
            marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '1');
            marker.setAttribute('refY', '5');
            marker.setAttribute('markerWidth', '5');
            marker.setAttribute('markerHeight', '5');
            marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path');
            arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
            arrowPath.setAttribute('fill', '#343a40');
            marker.appendChild(arrowPath);
            defs.appendChild(marker);
            svg.appendChild(defs);

            if (shape === 'octagonal') {
                const createOctagon = (flatToFlat, style) => {
                    const circumRadius = (flatToFlat / 2) / Math.cos(Math.PI / 8);
                    const points = [];
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 8) + i * (Math.PI / 4);
                        const x = cx + (circumRadius * scale) * Math.cos(angle);
                        const y = cy - (circumRadius * scale) * Math.sin(angle);
                        points.push(`${x},${y}`);
                    }
                    const polygon = document.createElementNS(svgNS, 'polygon');
                    polygon.setAttribute('points', points.join(' '));
                    for (const key in style) polygon.setAttribute(key, style[key]);
                    return polygon;
                };
                const polyStyle = { stroke: '#343a40', 'stroke-width': '1', fill: 'none' };
                svg.appendChild(createOctagon(outerDia, polyStyle));
                svg.appendChild(createOctagon(innerDia, polyStyle));

            } else { // Circular
                const createCircle = (diameter, style) => {
                    const circle = document.createElementNS(svgNS, 'circle');
                    circle.setAttribute('cx', cx);
                    circle.setAttribute('cy', cy);
                    circle.setAttribute('r', (diameter / 2) * scale);
                    for (const key in style) circle.setAttribute(key, style[key]);
                    return circle;
                };
                const circleStyle = { stroke: '#343a40', 'stroke-width': '1', fill: 'none' };
                svg.appendChild(createCircle(outerDia, circleStyle));
                svg.appendChild(createCircle(innerDia, circleStyle));
            }
            
            if (collarSize > outerDia) {
                const collarRadius = (collarSize / 2) * scale;
                const collarCircle = document.createElementNS(svgNS, 'circle');
                collarCircle.setAttribute('cx', cx);
                collarCircle.setAttribute('cy', cy);
                collarCircle.setAttribute('r', collarRadius);
                collarCircle.setAttribute('stroke', 'black');
                collarCircle.setAttribute('stroke-width', '3');
                collarCircle.setAttribute('fill', 'none');
                svg.appendChild(collarCircle);
            }

            const createElem = (type, attrs) => {
                const el = document.createElementNS(svgNS, type);
                for (const key in attrs) el.setAttribute(key, attrs[key]);
                return el;
            };

            const outerRadiusScaled = (outerDia / 2) * scale;
            const innerRadiusScaled = (innerDia / 2) * scale;

            const od_dim_x = cx + outerRadiusScaled + 40;
            svg.appendChild(createElem('line', { x1: cx, y1: cy - outerRadiusScaled, x2: od_dim_x, y2: cy - outerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: cx, y1: cy + outerRadiusScaled, x2: od_dim_x, y2: cy + outerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: od_dim_x, y1: cy - outerRadiusScaled, x2: od_dim_x, y2: cy + outerRadiusScaled, class: 'dimension-line', 'marker-start': 'url(#arrow)', 'marker-end': 'url(#arrow)' }));
            const odTextX = od_dim_x + 15;
            const odText = createElem('text', { x: odTextX, y: cy, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${odTextX}, ${cy})` });
            odText.textContent = `${outerDia.toFixed(1)}`;
            svg.appendChild(odText);

            const id_dim_x = cx + innerRadiusScaled + 15;
            svg.appendChild(createElem('line', { x1: cx, y1: cy - innerRadiusScaled, x2: id_dim_x, y2: cy - innerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: cx, y1: cy + innerRadiusScaled, x2: id_dim_x, y2: cy + innerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: id_dim_x, y1: cy - innerRadiusScaled, x2: id_dim_x, y2: cy + innerRadiusScaled, class: 'dimension-line', 'marker-start': 'url(#arrow)', 'marker-end': 'url(#arrow)' }));
            const idTextX = id_dim_x + 15;
            const idText = createElem('text', { x: idTextX, y: cy, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${idTextX}, ${cy})` });
            idText.textContent = `${innerDia.toFixed(1)}`;
            svg.appendChild(idText);

            const angle = 135 * Math.PI / 180;
            const arrowTipX = cx + outerRadiusScaled * Math.cos(angle);
            const arrowTipY = cy - outerRadiusScaled * Math.sin(angle);
            const leaderElbowX = cx - outerRadiusScaled - 20;
            const leaderElbowY = cy - outerRadiusScaled - 20;

            svg.appendChild(createElem('line', {
                x1: leaderElbowX, y1: leaderElbowY,
                x2: arrowTipX, y2: arrowTipY,
                class: 'dimension-line',
                'marker-end': 'url(#arrow)'
            }));

            const textLineStartX = leaderElbowX - 30;
            svg.appendChild(createElem('line', {
                x1: leaderElbowX, y1: leaderElbowY,
                x2: textLineStartX, y2: leaderElbowY,
                class: 'dimension-line'
            }));
            
            const wtText = createElem('text', {
                x: textLineStartX + (leaderElbowX - textLineStartX) / 2,
                y: leaderElbowY - 8,
                class: 'large-dimension-text'
            });
            wtText.textContent = `${wallThick.toFixed(1)}`;
            svg.appendChild(wtText);

            container.appendChild(svg);
        }

        function drawShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, visionData = null, endlockOffsets = {cast: 0, wind: 0}) {
            const container = dom['shutter-graphic-container'];
            container.innerHTML = '';
            const graphic = createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, { visionOptions: visionData, endlockOffsets: endlockOffsets }, 'shutter');
            if(graphic) container.appendChild(graphic);
        }
        
        function drawWicketGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, wicket, wicketLathHeight, endlockOffsets = {cast: 0, wind: 0}) {
            const container = dom['wicket-graphic-container'];
            container.innerHTML = '';
            const graphic = createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, { wicket: wicket, endlockOffsets: endlockOffsets }, 'wicket');
            if(graphic) container.appendChild(graphic);
        }

        function createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, options = {}, idSuffix = 'default') {
            const svgNS = "http://www.w3.org/2000/svg";

            if (!realWidth || !lath || !bottomLath || !axle) {
                return null;
            }

            const { 
                wicket = null, 
                visionOptions = null,
                endlockOffsets = { cast: 0, wind: 0 }
            } = options;

            const selectedEndlockIndex = dom.endlockType.value;
            const endlocksSelected = selectedEndlockIndex !== "" && endlockData[selectedEndlockIndex];

            const svg = document.createElementNS(svgNS, "svg");
            
            const basePadding = { top: 25, right: 120, bottom: 60, left: 120 };
            const topDimClearance = 35; // Extra space for top dimension
            const totalTopPadding = basePadding.top + topDimClearance;
            const svgWidth = 600; 

            const mainLathHeight = parseFloat(lath['Compressed lath height']);
            const bottomLathHeight = parseFloat(bottomLath['BLath height'] || mainLathHeight);
            const axleDiameter = parseFloat(axle['Diameter']);

            let totalRealCompressedHeight = parseFloat(dom['curtain-height-compressed'].textContent) + axleDiameter;

            const totalRealAxleWidth = realWidth + (additionalLength || 0);
            if (totalRealCompressedHeight <= 0 || totalRealAxleWidth <= 0) return null;

            const graphWidth = svgWidth - basePadding.left - basePadding.right;
            const scale = graphWidth / totalRealAxleWidth;
            const graphHeight = totalRealCompressedHeight * scale;
            const svgHeight = graphHeight + totalTopPadding + basePadding.bottom;
            
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);

            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', `dim-arrow-${idSuffix}`);
            marker.setAttribute('viewBox', '0 0 10 10');
            marker.setAttribute('refX', '5');
            marker.setAttribute('refY', '5');
            marker.setAttribute('markerWidth', '5');
            marker.setAttribute('markerHeight', '5');
            marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path');
            arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
            arrowPath.setAttribute('fill', '#343a40');
            marker.appendChild(arrowPath);
            defs.appendChild(marker);
            svg.appendChild(defs);

            const scaledTotalAxleWidth = totalRealAxleWidth * scale;
            const scaledShutterWidth = realWidth * scale;
            const startX = basePadding.left;
            const lathStartX = startX + (scaledTotalAxleWidth - scaledShutterWidth) / 2;
            const scaledCastOffset = endlockOffsets.cast * scale;
            const scaledWindOffset = endlockOffsets.wind * scale;

            const createLeaderLine = (x1, y1, x2, y2) => {
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.setAttribute('class', 'leader-line');
                svg.appendChild(line);
            };

            const drawDimensionLine = (x1, y1, x2, y2, label, orientation = 'horizontal', textSide = 'right') => {
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.setAttribute('class', 'dimension-line');
                line.setAttribute('marker-start', `url(#dim-arrow-${idSuffix})`);
                line.setAttribute('marker-end', `url(#dim-arrow-${idSuffix})`);
                svg.appendChild(line);

                const text = document.createElementNS(svgNS, 'text');
                text.textContent = label;
                text.setAttribute('class', 'dimension-text');

                if (orientation === 'horizontal') {
                    text.setAttribute('x', x1 + (x2 - x1) / 2);
                    text.setAttribute('y', y1 - 4);
                } else { // vertical
                    const textY = y1 + (y2 - y1) / 2;
                    let textX;
                    if (textSide === 'left') {
                        textX = x1 - 4;
                        text.setAttribute('text-anchor', 'end');
                    } else {
                        textX = x1 + 4;
                        text.setAttribute('text-anchor', 'start');
                    }
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('transform', `rotate(-90, ${textX}, ${textY})`);
                }
                svg.appendChild(text);
            };
            
            const drawAnnotation = (startY, endY, label) => {
                const lineX = basePadding.left - 55;
                const textX = lineX - 8;
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', lineX); line.setAttribute('y1', startY);
                line.setAttribute('x2', lineX); line.setAttribute('y2', endY);
                line.setAttribute('class', 'dimension-line');
                line.setAttribute('marker-start', `url(#dim-arrow-${idSuffix})`);
                line.setAttribute('marker-end', `url(#dim-arrow-${idSuffix})`);
                svg.appendChild(line);

                const text = document.createElementNS(svgNS, 'text');
                text.setAttribute('x', textX);
                text.setAttribute('class', 'dimension-text');
                text.setAttribute('text-anchor', 'end');
                
                const charLimit = 14;
                const words = label.split(' ');
                let currentLine = '';
                words.forEach(word => {
                    if ((currentLine + ' ' + word).length > charLimit && currentLine.length > 0) {
                        const tspan = document.createElementNS(svgNS, 'tspan');
                        tspan.setAttribute('x', textX);
                        tspan.setAttribute('dy', '1.2em');
                        tspan.textContent = word;
                        text.appendChild(tspan);
                        currentLine = word;
                    } else {
                        if (currentLine.length > 0) currentLine += ' ';
                        currentLine += word;
                        if (text.childElementCount === 0) {
                             text.textContent = currentLine;
                        } else {
                            text.lastChild.textContent = currentLine;
                        }
                    }
                });

                const numLines = 1 + text.querySelectorAll('tspan').length;
                const middleY = startY + (endY - startY) / 2;
                const lineHeight = 6; 
                const startYForBlock = middleY - ((numLines - 1) * lineHeight / 2);
                text.setAttribute('y', startYForBlock);

                svg.appendChild(text);
            };

            // Drawing starts from a new top position to account for padding
            const scaledAxleHeight = axleDiameter * scale;
            const axleY = totalTopPadding;
            const axleCenterlineY = axleY + scaledAxleHeight / 2;
            const bottomY = totalTopPadding + graphHeight;
            let currentY = bottomY;

            let endplateTopY = axleY; // Default to top of axle if no endplate
            if (selectedEndplate) {
                const endplateSize = parseFloat(selectedEndplate.Size) || 0;
                if (endplateSize > 0) {
                    const scaledEndplateHeight = endplateSize * scale;
                    endplateTopY = axleCenterlineY - (scaledEndplateHeight / 2);
                }
            }

            // --- DRAW CURTAIN FROM BOTTOM UP ---
            const scaledBottomLathHeight = bottomLathHeight * scale;
            currentY -= scaledBottomLathHeight;
            const bottomLathRect = document.createElementNS(svgNS, 'rect');
            bottomLathRect.setAttribute('x', lathStartX);
            bottomLathRect.setAttribute('y', currentY);
            bottomLathRect.setAttribute('width', scaledShutterWidth);
            bottomLathRect.setAttribute('height', scaledBottomLathHeight);
            bottomLathRect.setAttribute('class', 'shutter-bottomlath-graphic');
            svg.appendChild(bottomLathRect);
            const bottomLathTopY = currentY;

            const drawEndlocks = (lathY, lathH, leftOffset = 0) => {
                const endlockSide = lathH * 0.8;
                const endlockY = lathY + (lathH - endlockSide) / 2;
                
                const leftEndlock = document.createElementNS(svgNS, 'rect');
                leftEndlock.setAttribute('x', lathStartX + leftOffset - scaledCastOffset);
                leftEndlock.setAttribute('y', endlockY);
                leftEndlock.setAttribute('width', endlockSide);
                leftEndlock.setAttribute('height', endlockSide);
                leftEndlock.setAttribute('class', 'endlock-graphic');
                svg.appendChild(leftEndlock);
                
                const rightEndlock = document.createElementNS(svgNS, 'rect');
                const curtainRightEdge = lathStartX + scaledShutterWidth;
                rightEndlock.setAttribute('x', curtainRightEdge + scaledCastOffset - endlockSide);
                rightEndlock.setAttribute('y', endlockY);
                rightEndlock.setAttribute('width', endlockSide);
                rightEndlock.setAttribute('height', endlockSide);
                rightEndlock.setAttribute('class', 'endlock-graphic');
                svg.appendChild(rightEndlock);
            };

            const drawWindEndlocks = (lathY, lathH) => {
                const endlockHeight = lathH * 0.8;
                const endlockWidth = endlockHeight * 2.5;
                const endlockY = lathY + (lathH - endlockHeight) / 2;

                const leftEndlock = document.createElementNS(svgNS, 'rect');
                leftEndlock.setAttribute('x', lathStartX - scaledWindOffset);
                leftEndlock.setAttribute('y', endlockY);
                leftEndlock.setAttribute('width', endlockWidth);
                leftEndlock.setAttribute('height', endlockHeight);
                leftEndlock.setAttribute('class', 'wind-endlock-graphic');
                svg.appendChild(leftEndlock);
                
                const rightEndlock = document.createElementNS(svgNS, 'rect');
                const curtainRightEdge = lathStartX + scaledShutterWidth;
                rightEndlock.setAttribute('x', curtainRightEdge + scaledWindOffset - endlockWidth);
                rightEndlock.setAttribute('y', endlockY);
                rightEndlock.setAttribute('width', endlockWidth);
                rightEndlock.setAttribute('height', endlockHeight);
                rightEndlock.setAttribute('class', 'wind-endlock-graphic');
                svg.appendChild(rightEndlock);
            };

            let lathVisualCounter = 1;
            const isWindLath = (lath['Name'] || '').toLowerCase().includes('wind');

            if (visionOptions && visionOptions.visionLath) {
                 const vo = visionOptions;
                const visionLathCompHeight = parseFloat(vo.visionLath['Compressed lath height']);
                const scaledMainLathHeight = mainLathHeight * scale;
                const scaledVisionLathHeight = visionLathCompHeight * scale;

                let sectionBottomY = currentY;
                for (let i = 0; i < vo.numLathsBelow; i++) {
                    currentY -= scaledMainLathHeight;
                    const lathRect = document.createElementNS(svgNS, 'rect');
                    lathRect.setAttribute('x', lathStartX); lathRect.setAttribute('y', currentY);
                    lathRect.setAttribute('width', scaledShutterWidth);
                    lathRect.setAttribute('height', scaledMainLathHeight);
                    lathRect.setAttribute('class', 'shutter-lath-graphic');
                    svg.appendChild(lathRect);

                    if (isWindLath) {
                        if (lathVisualCounter % 2 !== 0) drawEndlocks(currentY, scaledMainLathHeight);
                        const isWindPos = (lathVisualCounter === 2 || lathVisualCounter === 4 || lathVisualCounter === 6 || lathVisualCounter === 8) || (lathVisualCounter > 8 && lathVisualCounter % 8 === 0);
                        if (isWindPos) drawWindEndlocks(currentY, scaledMainLathHeight);
                    } else if (endlocksSelected && lathVisualCounter % 2 !== 0) {
                        drawEndlocks(currentY, scaledMainLathHeight);
                    }
                    lathVisualCounter++;
                }
                if (vo.numLathsBelow > 0) drawAnnotation(currentY, sectionBottomY, `${lath['Name']} (x${vo.numLathsBelow})`);

                sectionBottomY = currentY;
                for (let i = 0; i < vo.numLathsVision; i++) {
                    currentY -= scaledVisionLathHeight;
                    const lathRect = document.createElementNS(svgNS, 'rect');
                    lathRect.setAttribute('x', lathStartX); lathRect.setAttribute('y', currentY);
                    lathRect.setAttribute('width', scaledShutterWidth);
                    lathRect.setAttribute('height', scaledVisionLathHeight);
                    lathRect.setAttribute('class', 'shutter-vision-lath-graphic');
                    svg.appendChild(lathRect);
                    
                    if (isWindLath) {
                        if (lathVisualCounter % 2 !== 0) drawEndlocks(currentY, scaledVisionLathHeight);
                        const isWindPos = (lathVisualCounter === 2 || lathVisualCounter === 4 || lathVisualCounter === 6 || lathVisualCounter === 8) || (lathVisualCounter > 8 && lathVisualCounter % 8 === 0);
                        if (isWindPos) drawWindEndlocks(currentY, scaledVisionLathHeight);
                    } else if (endlocksSelected && lathVisualCounter % 2 !== 0) {
                        drawEndlocks(currentY, scaledVisionLathHeight);
                    }
                    lathVisualCounter++;
                }
                if (vo.numLathsVision > 0) drawAnnotation(currentY, sectionBottomY, `${vo.visionLath['Name']} (x${vo.numLathsVision})`);
                
                sectionBottomY = currentY;
                for (let i = 0; i < vo.numLathsAbove; i++) {
                    currentY -= scaledMainLathHeight;
                    const lathRect = document.createElementNS(svgNS, 'rect');
                    lathRect.setAttribute('x', lathStartX); lathRect.setAttribute('y', currentY);
                    lathRect.setAttribute('width', scaledShutterWidth);
                    lathRect.setAttribute('height', scaledMainLathHeight);
                    lathRect.setAttribute('class', 'shutter-lath-graphic');
                    svg.appendChild(lathRect);

                    if (isWindLath) {
                        if (lathVisualCounter % 2 !== 0) drawEndlocks(currentY, scaledMainLathHeight);
                        const isWindPos = (lathVisualCounter === 2 || lathVisualCounter === 4 || lathVisualCounter === 6 || lathVisualCounter === 8) || (lathVisualCounter > 8 && lathVisualCounter % 8 === 0);
                        if (isWindPos) drawWindEndlocks(currentY, scaledMainLathHeight);
                    } else if (endlocksSelected && lathVisualCounter % 2 !== 0) {
                        drawEndlocks(currentY, scaledMainLathHeight);
                    }
                    lathVisualCounter++;
                }
                if (vo.numLathsAbove > 0) drawAnnotation(currentY, sectionBottomY, `${lath['Name']} (x${vo.numLathsAbove})`);

            } else if (numLaths > 0) {
                 const scaledLathHeight = mainLathHeight * scale;
                 for (let i = 0; i < numLaths; i++) {
                    currentY -= scaledLathHeight;
                    const lathNumber = i + 1;

                    const lathRect = document.createElementNS(svgNS, 'rect');
                    lathRect.setAttribute('x', lathStartX);
                    lathRect.setAttribute('y', currentY);
                    lathRect.setAttribute('width', scaledShutterWidth);
                    lathRect.setAttribute('height', scaledLathHeight);
                    lathRect.setAttribute('class', 'shutter-lath-graphic');
                    svg.appendChild(lathRect);
                    
                    if (isWindLath) {
                        if (lathNumber % 2 !== 0) {
                           drawEndlocks(currentY, scaledLathHeight);
                        }
                        const isWindLathPosition = (lathNumber === 2 || lathNumber === 4 || lathNumber === 6 || lathNumber === 8) || (lathNumber > 8 && lathNumber % 8 === 0);
                        if (isWindLathPosition) {
                            drawWindEndlocks(currentY, scaledLathHeight);
                        }
                    } else if (endlocksSelected && lathNumber % 2 !== 0) {
                        drawEndlocks(currentY, scaledLathHeight);
                    }
                }
                drawAnnotation(currentY, bottomLathTopY, `${lath['Name']} (x${numLaths})`);
            }
            
            if (selectedEndplate) {
                const endplateSize = parseFloat(selectedEndplate.Size) || 0;
                if (endplateSize > 0) {
                    const scaledEndplateHeight = endplateSize * scale;
                    // endplateTopY is already calculated
                    const endplateBox = document.createElementNS(svgNS, 'rect');
                    endplateBox.setAttribute('x', startX);
                    endplateBox.setAttribute('y', endplateTopY);
                    endplateBox.setAttribute('width', scaledTotalAxleWidth);
                    endplateBox.setAttribute('height', scaledEndplateHeight);
                    endplateBox.setAttribute('class', 'endplate-box-graphic');
                    svg.appendChild(endplateBox);
                }
            }

            const axleRect = document.createElementNS(svgNS, 'rect');
            axleRect.setAttribute('x', startX);
            axleRect.setAttribute('y', axleY);
            axleRect.setAttribute('width', scaledTotalAxleWidth);
            axleRect.setAttribute('height', scaledAxleHeight);
            axleRect.setAttribute('class', 'shutter-axle-graphic');
            svg.appendChild(axleRect);
            
            const centerline = document.createElementNS(svgNS, 'line');
            centerline.setAttribute('x1', startX); centerline.setAttribute('y1', axleCenterlineY);
            centerline.setAttribute('x2', startX + scaledTotalAxleWidth); centerline.setAttribute('y2', axleCenterlineY);
            centerline.setAttribute('class', 'axle-centerline-graphic');
            svg.appendChild(centerline);

            if (wicket) {
                const wicketRealHeight = parseFloat(wicket.Height) || 0;
                const wicketRealWidth = parseFloat(wicket.Width) || 0;
                const scaledWicketHeight = wicketRealHeight * scale;
                const scaledWicketWidth = wicketRealWidth * scale;
                const wicketGap = 10;
                const scaledWicketGap = wicketGap * scale;

                const wicketY = bottomLathTopY - scaledWicketGap - scaledWicketHeight;

                const wicketRect = document.createElementNS(svgNS, 'rect');
                wicketRect.setAttribute('x', lathStartX);
                wicketRect.setAttribute('y', wicketY);
                wicketRect.setAttribute('width', scaledWicketWidth);
                wicketRect.setAttribute('height', scaledWicketHeight);
                wicketRect.setAttribute('class', 'wicket-door-graphic');
                svg.appendChild(wicketRect);
            }

            // --- Draw Dimensions ---
            const totalWidthDimY = basePadding.top;
            drawDimensionLine(startX, totalWidthDimY, startX + scaledTotalAxleWidth, totalWidthDimY, `${totalRealAxleWidth.toFixed(0)} mm Axle Width`, 'horizontal');
            createLeaderLine(startX, totalWidthDimY, startX, axleY);
            createLeaderLine(startX + scaledTotalAxleWidth, totalWidthDimY, startX + scaledTotalAxleWidth, axleY);
            
            const widthDimLineY = bottomY + 15;
            drawDimensionLine(lathStartX, widthDimLineY, lathStartX + scaledShutterWidth, widthDimLineY, `${realWidth.toFixed(0)} mm Cut Curtain Width`, 'horizontal');
            createLeaderLine(lathStartX, widthDimLineY, lathStartX, bottomY);
            createLeaderLine(lathStartX + scaledShutterWidth, widthDimLineY, lathStartX + scaledShutterWidth, bottomY);

            const maxOffset = Math.max(endlockOffsets.cast, endlockOffsets.wind);
            if (maxOffset > 0) {
                const scaledMaxOffset = maxOffset * scale;
                const endlockWidthDimY = bottomY + 28;
                const overallWidth = realWidth + (2 * maxOffset);
                const overallStartX = lathStartX - scaledMaxOffset;
                const overallEndX = lathStartX + scaledShutterWidth + scaledMaxOffset;
                drawDimensionLine(overallStartX, endlockWidthDimY, overallEndX, endlockWidthDimY, `${overallWidth.toFixed(0)} mm Overall Endlock Width`, 'horizontal');
                createLeaderLine(overallStartX, endlockWidthDimY, overallStartX, bottomY - (scaledBottomLathHeight/2));
                createLeaderLine(overallEndX, endlockWidthDimY, overallEndX, bottomY - (scaledBottomLathHeight/2));
            }
            
            const rightDimX_Inner = startX + scaledTotalAxleWidth + 40;
            const rightDimX_Outer = rightDimX_Inner - 15;
            
            if (selectedEndplate) {
                const endplateSize = parseFloat(selectedEndplate.Size) || 0;
                if(endplateSize > 0) {
                    const endplateBottomY = endplateTopY + (endplateSize * scale);
                    const heightToUnderside = parseFloat(dom.height.value) - (endplateSize / 2);
                    drawDimensionLine(rightDimX_Inner, endplateBottomY, rightDimX_Inner, bottomY, `${heightToUnderside.toFixed(0)} mm to underside of box`, 'vertical', 'left');
                    createLeaderLine(rightDimX_Inner, endplateBottomY, startX + scaledTotalAxleWidth, endplateBottomY);
                    createLeaderLine(rightDimX_Inner, bottomY, startX + scaledTotalAxleWidth, bottomY);
                }
            }

            drawDimensionLine(rightDimX_Outer, axleCenterlineY, rightDimX_Outer, bottomY, `${parseFloat(dom.height.value).toFixed(0)} mm to Centre of Axle`, 'vertical', 'left');
            createLeaderLine(rightDimX_Outer, axleCenterlineY, startX + scaledTotalAxleWidth, axleCenterlineY);
            createLeaderLine(rightDimX_Outer, bottomY, startX + scaledTotalAxleWidth, bottomY);
            
            const leftDimX_Inner = basePadding.left - 15;
            const leftDimX_Outer = basePadding.left - 55;
            if (selectedEndplate) {
                 const endplateSize = parseFloat(selectedEndplate.Size) || 0;
                 if (endplateSize > 0) {
                    const scaledEndplateHeight = endplateSize * scale;
                    const endplateBottomY = endplateTopY + scaledEndplateHeight;
                    drawDimensionLine(leftDimX_Inner, endplateTopY, leftDimX_Inner, endplateBottomY, `${endplateSize.toFixed(0)} mm Endplate`, 'vertical', 'left');
                    createLeaderLine(leftDimX_Inner, endplateTopY, startX, endplateTopY);
                    createLeaderLine(leftDimX_Inner, endplateBottomY, startX, endplateBottomY);
                 }
            }

            if (bottomLathHeight > 0) {
                drawDimensionLine(leftDimX_Outer, bottomLathTopY, leftDimX_Outer, bottomY, `${bottomLathHeight.toFixed(0)} mm`, 'vertical', 'left');
                createLeaderLine(leftDimX_Outer, bottomLathTopY, lathStartX, bottomLathTopY);
                createLeaderLine(leftDimX_Outer, bottomY, lathStartX, bottomY);
            }

            return svg;
        }

        function switchTab(targetTabId) {
            document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
            tabButtons.forEach(b => b.classList.remove('active'));
            document.getElementById(targetTabId).classList.add('active');
            document.querySelector(`.tab-button[data-tab="${targetTabId}"]`).classList.add('active');

            if (targetTabId === 'axle-content') {
                const length = parseFloat(dom['total-axle-length'].textContent) || 0;
                const deflection = parseFloat(dom['axle-deflection'].textContent) || 0;
                drawDeflectionGraphic(length, deflection);

                const selectedAxleIndex = dom.axleType.value;
                if(selectedAxleIndex !== "" && axleData[selectedAxleIndex]) {
                    const collarSize = parseFloat(dom.collarSize.value) || 0;
                    drawAxleCrossSection(axleData[selectedAxleIndex], collarSize);
                } else {
                    drawAxleCrossSection(null);
                }
            } else if (targetTabId === 'motor-content') {
                drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
            } else if(targetTabId === 'wicket-content') {
                 updateWicketCalculationsAndGraphic();
            } else if (targetTabId === 'endplate-content') {
                const selectedIndex = parseInt(dom.endplateSelector.value, 10);
                const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
                const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
                const numLaths = parseInt(dom['lath-count'].textContent) || 0;
                if (!isNaN(selectedIndex) && currentFilteredEndplates[selectedIndex]) {
                    const plate = currentFilteredEndplates[selectedIndex];
                    drawEndplateGraphic(plate, maxCoilDiameter, selectedAxle, selectedLath, numLaths);
                    calculateEndplateForces(plate);
                } else {
                    drawEndplateGraphic(null, 0, null, null, 0);
                    calculateEndplateForces(null);
                }
            }
        };
        
        updateAllCalculations();
    </script>

    <script>
        window.addEventListener('load', () => {
            // Set default hidden tabs
            ['endplate-content', 'safety-brake-content', 'wicket-content'].forEach(tabId => {
                const tabButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
                if(tabButton) {
                    tabButton.style.display = 'none';
                }
            });

            initializeAdminControls(); 

            const excelFileUrl = 'https://raw.githubusercontent.com/rob-hyrons/SWS_logic_calculator/main/Calculations%20gfa.xlsx';
            const statusDiv = document.getElementById('import-status');
            
            statusDiv.textContent = 'Loading data from repository...';
            statusDiv.style.color = '#555';

            fetch(excelFileUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.statusText}`);
                    }
                    return response.arrayBuffer();
                })
                .then(fileData => {
                    processExcelFile(fileData);
                })
                .catch(error => {
                    statusDiv.textContent = 'Failed to fetch the Excel file from the repository. Please check the console for details.';
                    statusDiv.style.color = 'red';
                    console.error('There has been a problem with the fetch operation:', error);
                });
        });
    </script>
    
    <!-- =================================================================== -->
    <!-- START: CODE FOR CSV REPORT GENERATION (FIXED & IMPROVED)            -->
    <!-- =================================================================== -->
    <script>
        // This function sets up the filter checkboxes once the main data is loaded
        function setupReportFilters() {
            // Lath Filter Setup
            const lathContainer = document.getElementById('report-lath-filter-container');
            lathContainer.innerHTML = ''; // Clear "Loading..." message
            lathData.forEach((lath, index) => {
                const controlItem = document.createElement('div');
                controlItem.className = 'admin-control-item';
                controlItem.innerHTML = `<label><input type="checkbox" class="report-lath-checkbox" value="${index}" checked> ${lath.Name}</label>`;
                lathContainer.appendChild(controlItem);
            });

            // Motor Filters Setup
            let manufacturerKey = '', voltageKey = '', mountingKey = '';
            if (motorData.length > 0) {
                const firstMotor = motorData[0];
                manufacturerKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'manufacturer');
                voltageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'voltage');
                mountingKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'mounting type');
            }

            const setupFilterGroup = (containerId, key, data, className) => {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                if (key) {
                    const uniqueValues = [...new Set(data.map(item => item[key]).filter(val => val))];
                    uniqueValues.sort().forEach(value => {
                        const controlItem = document.createElement('div');
                        controlItem.className = 'admin-control-item';
                        controlItem.innerHTML = `<label><input type="checkbox" class="${className}" value="${value}" checked> ${value}</label>`;
                        container.appendChild(controlItem);
                    });
                } else {
                    container.innerHTML = `<p><em>Column not found in data.</em></p>`;
                }
            };
            
            setupFilterGroup('report-motor-filter-container', manufacturerKey, motorData, 'report-motor-checkbox');
            setupFilterGroup('report-motor-voltage-filter-container', voltageKey, motorData, 'report-voltage-checkbox');
            setupFilterGroup('report-motor-mounting-filter-container', mountingKey, motorData, 'report-mounting-checkbox');


            // Add event listeners for Select/Deselect All buttons
            document.getElementById('reportLathSelectAll').addEventListener('click', () => document.querySelectorAll('.report-lath-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportLathDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-lath-checkbox').forEach(cb => cb.checked = false));
            document.getElementById('reportMotorSelectAll').addEventListener('click', () => document.querySelectorAll('.report-motor-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportMotorDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-motor-checkbox').forEach(cb => cb.checked = false));
            document.getElementById('reportVoltageSelectAll').addEventListener('click', () => document.querySelectorAll('.report-voltage-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportVoltageDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-voltage-checkbox').forEach(cb => cb.checked = false));
            document.getElementById('reportMountingSelectAll').addEventListener('click', () => document.querySelectorAll('.report-mounting-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportMountingDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-mounting-checkbox').forEach(cb => cb.checked = false));


            // Bind the main generation function to the button
            document.getElementById('generateCsvButton').addEventListener('click', generateCsvReport);
        }

        // --- Headless Calculation Functions ---
        function calculateCurtainPropertiesHeadless(lath, bottomLath, width_mm, height_mm) {
            if (!lath || !bottomLath || height_mm <= 0) {
                return { totalWeight: 0, torqueWeight: 0, travelHeight: 0 };
            }
            const axleRadius = 60; 
            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
            
            const heightToCoverByLaths = (height_mm - bottomLathHeight) + axleRadius;
            let numLaths = (lathCompressedHeight > 0 && heightToCoverByLaths > 0)
                ? Math.ceil(heightToCoverByLaths / lathCompressedHeight) + 2
                : 0;

            const widthM = width_mm / 1000;
            let kgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            const lathWeightBasedOnCoverage = widthM * (numLaths * lathCompressedHeight / 1000) * kgsPerM2;
            const bottomLathWeight = widthM * (parseFloat(bottomLath['BLath weight / m length']) || 0);
            
            const totalWeight = lathWeightBasedOnCoverage + bottomLathWeight;
            
            let torqueWeight = totalWeight;
            if (numLaths >= 3) {
                const bufferLathWeight = 3 * (lathCompressedHeight / 1000) * widthM * kgsPerM2;
                torqueWeight = totalWeight - bufferLathWeight;
            }
            const travelHeight = height_mm - bottomLathHeight;
            return { totalWeight, torqueWeight, travelHeight };
        }

        function findBestAxleHeadless(totalWeightKgs, totalLength) {
             if (totalLength <= 0 || axleData.length === 0) {
                return { name: 'null', status: 'N/A', axleObj: null };
            }
            const axlesForShape = axleData.filter(axle => (axle.Shape || 'circular').toLowerCase().trim() === 'circular');
            if (axlesForShape.length === 0) return { name: 'null', status: 'N/A', axleObj: null };

            let bestAxle = null;
            for (const axle of axlesForShape) {
                const perf = performDeflectionCalc(totalWeightKgs, axle, totalLength);
                if (perf.ratio >= 400 && perf.deflection <= 25) {
                    bestAxle = axle;
                    break;
                }
            }

            if (bestAxle) {
                return { name: bestAxle.Name, status: 'Pass', axleObj: bestAxle };
            } else {
                return { name: axlesForShape[0].Name, status: 'Fail', axleObj: axlesForShape[0] };
            }
        }
        
        function calculateTorqueHeadless(torqueWeight, lath, travelHeight, axle, width_mm, bottomLath, friction_percent) {
            if (!lath || !axle || !bottomLath || travelHeight <= 0 || torqueWeight <= 0) return 0;
            
            const effectiveStartDiameter = getEffectiveCoilDiameter(axle);
            const bottomLathWeight = (width_mm / 1000) * (parseFloat(bottomLath['BLath weight / m length']) || 0);
            const lathsWeight = torqueWeight - bottomLathWeight;

            const force = (lathsWeight + bottomLathWeight) * 9.81;
            const radiusM = (effectiveStartDiameter / 2) / 1000;
            const maxTorque = force * radiusM;

            const frictionMultiplier = 1 + (friction_percent || 0) / 100;
            return maxTorque * frictionMultiplier;
        }

        async function generateCsvReport() {
            const statusDiv = document.getElementById('csv-generation-status');
            statusDiv.textContent = 'Starting report generation... Please wait.';
            statusDiv.style.color = 'blue';

            // Get user-defined parameters
            const minWidth = parseInt(document.getElementById('reportMinWidth').value);
            const maxWidth = parseInt(document.getElementById('reportMaxWidth').value);
            const minHeight = parseInt(document.getElementById('reportMinHeight').value);
            const maxHeight = parseInt(document.getElementById('reportMaxHeight').value);
            const interval = parseInt(document.getElementById('reportInterval').value);
            
            const getSelectedValues = (className) => Array.from(document.querySelectorAll(`.${className}:checked`)).map(cb => cb.value);
            const selectedLathIndices = getSelectedValues('report-lath-checkbox').map(v => parseInt(v));
            const selectedManufacturers = getSelectedValues('report-motor-checkbox');
            const selectedVoltages = getSelectedValues('report-voltage-checkbox');
            const selectedMountings = getSelectedValues('report-mounting-checkbox');

            if (selectedLathIndices.length === 0 || selectedManufacturers.length === 0 || selectedVoltages.length === 0 || selectedMountings.length === 0) {
                statusDiv.textContent = 'Error: Please select at least one option from each filter category.';
                statusDiv.style.color = 'red';
                return;
            }
            
            // Find the correct column keys
            let manufacturerKey = '', voltageKey = '', mountingKey = '';
            if (motorData.length > 0) {
                const firstMotor = motorData[0];
                manufacturerKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'manufacturer');
                voltageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'voltage');
                mountingKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'mounting type');
            }

            // Build scenarios and headers
            const scenarios = [];
            for (const man of selectedManufacturers) {
                for (const vol of selectedVoltages) {
                    for (const mou of selectedMountings) {
                        const header = `Motor: ${man} (${vol}, ${mou})`;
                        scenarios.push({ manufacturer: man, voltage: vol, mounting: mou, header: header });
                    }
                }
            }

            const csvHeaders = ["Lath Name", "Curtain Width (mm)", "Curtain Height (mm)", "Total Weight (kg)", "Required Axle Name", "Axle Deflection Status", "Max Required Torque (Nm)", ...scenarios.map(s => s.header)];
            const csvData = [csvHeaders];
            
            const defaultBottomLath = bottomLathData[0];
            const defaultAdditionalLength = 100;

            // Main loop
            for (const lathIndex of selectedLathIndices) {
                const lath = lathData[lathIndex];

                for (let width = minWidth; width <= maxWidth; width += interval) {
                    for (let height = minHeight; height <= maxHeight; height += interval) {
                        statusDiv.textContent = `Processing: ${lath.Name} at ${width}x${height}...`;
                        await new Promise(resolve => setTimeout(resolve, 0));

                        const props = calculateCurtainPropertiesHeadless(lath, defaultBottomLath, width, height);
                        const totalLength = width + defaultAdditionalLength;
                        const axleResult = findBestAxleHeadless(props.totalWeight, totalLength);
                        const defaultFriction = parseFloat(lath['Friction %']) || 10;
                        const requiredTorque = calculateTorqueHeadless(props.torqueWeight, lath, props.travelHeight, axleResult.axleObj, width, defaultBottomLath, defaultFriction);

                        const rowData = [
                            lath.Name, width, height,
                            props.totalWeight.toFixed(2),
                            axleResult.name, axleResult.status,
                            requiredTorque > 0 ? requiredTorque.toFixed(1) : 'null'
                        ];

                        for (const scenario of scenarios) {
                            const suitableMotors = motorData
                                .filter(m => 
                                    m[manufacturerKey] == scenario.manufacturer &&
                                    String(m[voltageKey]) == String(scenario.voltage) &&
                                    m[mountingKey] == scenario.mounting &&
                                    requiredTorque > 0 && 
                                    requiredTorque >= parseFloat(m['Torque (Nm) min']) && 
                                    requiredTorque <= parseFloat(m['Torque (Nm) max'])
                                )
                                .sort((a,b) => parseFloat(a['Torque (Nm) max']) - parseFloat(b['Torque (Nm) max']));
                            
                            rowData.push(suitableMotors.length > 0 ? suitableMotors[0].Name : 'null');
                        }
                        csvData.push(rowData);
                    }
                }
            }

            downloadCsv(csvData);
            statusDiv.textContent = 'Report generation complete. Download has started.';
            statusDiv.style.color = 'green';
        }

        function downloadCsv(data) {
            let csvContent = "data:text/csv;charset=utf-8,";
            data.forEach(function(rowArray) {
                let row = rowArray.map(item => `"${String(item).replace(/"/g, '""')}"`).join(",");
                csvContent += row + "\r\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "shutter_calculator_report.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
    <!-- =================================================================== -->
    <!-- END:   CODE FOR CSV REPORT GENERATION                               -->
    <!-- =================================================================== -->
</body>
</html>
