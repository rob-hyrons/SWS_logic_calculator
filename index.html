<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Shutter Motor Calculator</title>
    <!-- xlsx.js for data reading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ExcelJS for image extraction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <!-- Papa Parse for CSV importing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f4f9; color: #333; display: flex; justify-content: center;
            align-items: flex-start; min-height: 100vh; margin: 0; padding: 2em;
        }
        #logo-image {
            position: absolute; top: 2em; right: 2em; width: 10vw; max-width: 150px; height: auto; z-index: 10;
        }
        .container {
            background: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%; max-width: 1000px; display: flex; flex-direction: row; align-items: stretch;
        }
        .content-area {
            padding: 2em; flex-grow: 1; border-left: 1px solid #dee2e6;
        }
        h1 { color: #1a1a1a; text-align: center; margin-bottom: 1em; }
        .form-group { margin-bottom: 1.5em; }
        .form-row { display: flex; gap: 1.5em; }
        .form-col { flex: 1; }
        label { display: block; margin-bottom: 0.5em; font-weight: 600; }
        input[type="number"], input[type="file"], select, input[type="checkbox"] {
            width: 100%; padding: 0.8em; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
        }
        input[type="checkbox"] { width: auto; }
        input[type="file"] { padding: 0.5em; }
        .radio-group label { display: inline-block; margin-right: 15px; font-weight: 500;}
        .radio-group input[type="radio"] { margin-right: 5px; }
        .results {
            margin-top: 1.5em; background-color: #f8f9fa; padding: 1.5em; border-radius: 6px; border-left: 5px solid #007bff;
        }
        .results h3 { margin-top: 0; color: #0056b3; }
        .results h4 { margin-top: 1em; margin-bottom: 0.5em; color: #495057;}
        .results p { font-size: 1.1em; margin: 0.5em 0; line-height: 1.5; }
        .results span { font-weight: bold; color: #1a1a1a; }
        #import-status { margin-top: 0.5em; font-style: italic; color: #555; }
        
        .tabs {
            display: flex; flex-direction: column; background-color: #f1f3f5; flex-shrink: 0; width: 55px;
            border-top-left-radius: 8px; border-bottom-left-radius: 8px;
        }
        .tab-button {
            height: 120px; padding: 0.5em; border: none; cursor: pointer; font-size: 1em; font-weight: 600; color: #555;
            border-left: 5px solid transparent; transition: all 0.2s ease-in-out; writing-mode: vertical-rl;
            transform: rotate(180deg); text-align: center;
        }
        .tab-button:hover { filter: brightness(75%); }
        .tab-button.active { font-weight: 700; color: #000; border-left-color: #0d6efd; }
        .tab-button:nth-child(1) { background-color: #e3f2fd; }
        .tab-button:nth-child(2) { background-color: #e8f5e9; }
        .tab-button:nth-child(3) { background-color: #fff3e0; }
        .tab-button:nth-child(4) { background-color: #fce4ec; }
        .tab-button:nth-child(5) { background-color: #ede7f6; }
        .tab-button:nth-child(6) { background-color: #e0f7fa; }
        .tab-button:nth-child(7) { background-color: #e9ecef; }
        .tab-button.active:nth-child(1) { background-color: #cce5ff; }
        .tab-button.active:nth-child(2) { background-color: #d1e7dd; }
        .tab-button.active:nth-child(3) { background-color: #ffe5b4; }
        .tab-button.active:nth-child(4) { background-color: #f8d7da; }
        .tab-button.active:nth-child(5) { background-color: #dcd0ff; }
        .tab-button.active:nth-child(6) { background-color: #b2ebf2; }
        .tab-button.active:nth-child(7) { background-color: #ced4da; }
        
        .tab-pane { display: block; }
        .tab-pane:not(.active) { display: none; }
        .tab-pane.active { display: block; padding-bottom: 2em; }
        .warning-text, p .warning-text, span.warning-text { color: #d93025 !important; font-weight: bold; }
        
        .width-validation-warning {
            color: #d93025; font-weight: 500; font-size: 0.9em; margin-top: 0.5em; display: none;
        }

        #recommendation-box {
            display: none; margin-top: 1em; padding: 1em; background-color: #fffbe6;
            border: 1px solid #ffe58f; border-radius: 4px; color: #d46b08; font-weight: bold;
        }
        .graph-container { margin-top: 1.5em; width: 100%; }
        #axle-cross-section-container, #endplate-graphic-container {
            min-width: 450px; max-width: 550px; margin-left: auto; margin-right: auto;
        }
        .calculation-explainer {
            margin-top: 2em; padding: 1em; background-color: #e9ecef; border: 1px solid #ced4da;
            border-radius: 6px; font-family: monospace; font-size: 0.9em; line-height: 1.6;
        }
        .calculation-explainer h4 { margin-top: 0; color: #495057; }
        .calculation-explainer span { font-weight: bold; color: #0056b3; }
        
        /* SVG Styles */
        .beam-path { stroke: #adb5bd; stroke-width: 2; fill: none; }
        .deflected-path { stroke: #007bff; stroke-width: 4; fill: none; transition: d 0.3s ease-out; }
        .deflected-path.warning { stroke: #d93025; }
        .graph-text { font-family: sans-serif; font-size: 12px; fill: #343a40; text-anchor: middle; }
        .axis-line { stroke: #ced4da; stroke-width: 1; }
        .torque-bar { fill: #007bff; transition: all 0.2s ease-out; }
        .torque-bar:hover { fill: #0056b3; }
        .graph-data-label { font-size: 10px; text-anchor: middle; fill: #495057; }
        
        .support-symbol { fill: #868e96; stroke: #495057; stroke-width: 1; }
        .coil-wrap-graphic { fill: none; stroke: #adb5bd; stroke-width: 0.5; }
        .force-text { font-family: sans-serif; font-size: 11px; text-anchor: middle; }
        .force-text.red { fill: #d93025; font-weight: bold;}
        .force-text.blue { fill: #007bff; font-weight: bold;}
        .dim-text-force-diagram { font-family: sans-serif; font-size: 10px; fill: #343a40; text-anchor: middle;}

        .option-pass { color: #1e8e3e; font-weight: bold; }
        .option-fail { color: #d93025; }

        #shutter-graphic-container, #wicket-graphic-container, #width-graphic-container {
            margin-top: 1.5em; width: 100%; border: 1px solid #e9ecef; border-radius: 4px; background-color: #f8f9fa;
        }
        .shutter-axle-graphic { fill: #6c757d; stroke: #495057; stroke-width: 0.5; }
        .shutter-lath-graphic { fill: #e9ecef; stroke: #adb5bd; stroke-width: 0.5; }
        .shutter-bottomlath-graphic { fill: #ced4da; stroke: #495057; stroke-width: 0.5; }
        .wicket-door-graphic { fill: #a5d6a7; stroke: #388e3c; stroke-width: 1; }
        .shutter-vision-lath-graphic { fill: #a7d8f0; stroke: #6bafd2; stroke-width: 0.5; }
        .endlock-graphic { fill: #000000; }
        .wind-endlock-graphic { fill: #555555; } 
        .endplate-box-graphic {
            fill: rgba(255, 193, 7, 0.2); stroke: #ffc107; stroke-width: 1; stroke-dasharray: 4, 2;
        }
        .axle-centerline-graphic { stroke: #d93025; stroke-width: 1; stroke-dasharray: 4, 2; }
        .dimension-line { stroke: #343a40; stroke-width: 1; }
        .leader-line { stroke: #343a40; stroke-width: 0.5; stroke-dasharray: 2,2; }
        .dimension-text { font-family: sans-serif; font-size: 5px; fill: #343a40; text-anchor: middle; }
        .large-dimension-text { font-family: sans-serif; font-size: 10px; fill: #343a40; text-anchor: middle; }
        .width-graphic-label { font-family: sans-serif; font-size: 14px; fill: #343a40; text-anchor: middle; }
        .width-graphic-value { font-family: sans-serif; font-size: 10px; fill: #555; text-anchor: middle; }
        .dimension-tick { stroke: #343a40; stroke-width: 1; }

        .print-container {
            display: flex; justify-content: flex-end; padding: 0; margin-bottom: 1em;
        }
        #printButton {
            padding: 0.8em 1.5em; font-size: 0.9em; font-weight: 600; color: white;
            background-color: #007bff; border: none; border-radius: 5px; cursor: pointer;
        }
        #printButton:hover { background-color: #0056b3; }

        /* Admin Page Styles */
        .admin-section {
            margin-bottom: 2em; padding: 1.5em; border: 1px solid #dee2e6; border-radius: 6px;
        }
        .admin-section h3 {
            margin-top: 0; border-bottom: 2px solid #007bff; padding-bottom: 0.5em;
        }
        .admin-section h4 {
            margin-top: 1.5em; margin-bottom: 0.5em; color: #495057;
        }
        .admin-controls, .report-filter-container {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1em; margin-top: 1em;
        }
        .admin-control-item label {
            font-weight: 500; display: flex; align-items: center; gap: 8px; cursor: pointer;
        }
        .admin-button-group {
            display: flex; gap: 1em; margin-bottom: 1.5em;
        }
        .admin-button-group button, #importCsvButton, #generateCsvButton {
            padding: 0.5em 1em; font-size: 0.8em; font-weight: 500; color: #fff;
            background-color: #6c757d; border: none; border-radius: 4px; cursor: pointer;
        }
        .admin-button-group button:hover, #importCsvButton:hover, #generateCsvButton:hover {
            background-color: #5a6268;
        }
        #importCsvButton { background-color: #28a745; }
        #importCsvButton:hover { background-color: #218838; }
        #generateCsvButton { background-color: #007bff; font-size: 0.9em; padding: 0.8em 1.2em; }
        #generateCsvButton:hover { background-color: #0056b3; }

        .report-controls-grid {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1em; margin-bottom: 1.5em;
        }
        .report-filter-container {
             max-height: 200px; overflow-y: auto; padding: 1em; border: 1px solid #dee2e6; border-radius: 4px;
        }

        .shape-toggle {
            display: flex; border: 1px solid #ccc; border-radius: 4px; overflow: hidden;
        }
        .shape-toggle input[type="radio"] { display: none; }
        .shape-toggle label {
            flex: 1; text-align: center; padding: 0.8em; margin: 0; cursor: pointer;
            background-color: #f8f9fa; color: #495057; transition: background-color 0.2s; font-weight: 500;
        }
        .shape-toggle input[type="radio"]:checked + label {
            background-color: #007bff; color: white; font-weight: 600;
        }

        @media print {
            body { font-family: Arial, sans-serif; background-color: #fff; padding: 0; margin: 0; }
            @page { size: A4; margin: 15mm; }
            .tabs, .form-group, .print-container, .calculation-explainer, hr, #import-status, #recommendation-box, #admin-content, #logo-image { display: none !important; }
            .tab-pane { display: block !important; padding-top: 1em; }
            .hide-in-print { display: none !important; }
            .page-break-before-print { page-break-before: always; }
            .container { display: block; box-shadow: none; border: none; width: 100%; max-width: 100%; padding: 0; }
            .content-area { padding: 0; border-left: none; }
            * { color: #000 !important; }
            h1 { font-size: 20pt; text-align: center !important; border: none; margin-bottom: 1.5em; }
            h2 { font-size: 15pt; border-bottom: 2px solid #ccc; padding-bottom: 4px; margin-top: 1.5em; margin-bottom: 1em; }
            .tab-pane > h2:first-of-type { margin-top: 0; }
            .results { border: 1px solid #ccc; border-left: none; page-break-inside: avoid; margin-top: 1em; padding: 1em; }
            .graph-container, #shutter-graphic-container, #wicket-graphic-container, #width-graphic-container { width: 100% !important; max-width: 450px; margin-left: auto; margin-right: auto; page-break-inside: avoid; }
            #lath-image-container, #vision-lath-image-container, #safety-brake-image-container { page-break-inside: avoid; text-align: center; padding: 1em 0; }
            #lath-image-container img, #vision-lath-image-container img, #safety-brake-image-container img { max-height: 80px; }
            svg { width: 100% !important; }
        }
    </style>
</head>
<body>
    <img src="https://raw.githubusercontent.com/rob-hyrons/SWS_logic_calculator/main/swslogo.svg" alt="SWS Logo" id="logo-image">
    <div class="container">
        <div class="tabs">
            <button class="tab-button active" data-tab="inputs-content">Inputs</button>
            <button class="tab-button" data-tab="axle-content">Axle</button>
            <button class="tab-button" data-tab="motor-content">Motor</button>
            <button class="tab-button" data-tab="endplate-content">Endplate</button>
            <button class="tab-button" data-tab="safety-brake-content">Safety Brake</button>
            <button class="tab-button" data-tab="wicket-content">Wicket Door</button>
            <button class="tab-button" data-tab="admin-content">Admin</button>
        </div>
        <div class="content-area">
            <h1>Complete Shutter Calculator</h1>
            
            <div class="print-container">
                <button id="printButton">Print Report to PDF</button>
            </div>

            <div class="tab-content">
                <!-- Inputs Tab -->
                <div id="inputs-content" class="tab-pane active">
                    <h2>Shutter Specification</h2>
                    <div class="form-group" data-admin-label="File Import Status">
                         <div id="import-status">Attempting to load data from repository...</div>
                    </div>
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Input Width">
                            <label for="width">Input Width (mm)</label>
                            <input type="number" id="width" placeholder="e.g., 3000">
                            <div id="width-warning" class="width-validation-warning"></div>
                        </div>
                        <div class="form-group form-col" data-admin-label="Width Type">
                            <label for="widthType">Width Type</label>
                            <select id="widthType">
                                <option value="clearOpening">Clear Opening</option>
                                <option value="curtainWidth" selected>Curtain Width</option>
                                <option value="overall">Overall (Reveal)</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Guide Type">
                            <label for="guideType">Guide Type</label>
                            <select id="guideType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div class="form-group form-col" data-admin-label="Curtain Height">
                            <label for="height">Curtain Height (Floor to Axle Centre, mm)</label>
                            <input type="number" id="height" placeholder="e.g., 4000">
                        </div>
                    </div>
                     <div class="form-group" data-admin-label="Additional Axle Width">
                        <label for="additionalLength">Additional Axle Width (Total, mm)</label>
                        <input type="number" id="additionalLength" placeholder="e.g., 100" value="100">
                    </div>
                    <div class="form-row">
                        <div class="form-group form-col" data-admin-label="Lath Type">
                            <label for="lathType">Lath Type</label>
                            <select id="lathType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div class="form-group form-col" data-admin-label="Endlock Type">
                            <label for="endlockType">Endlock Type</label>
                            <select id="endlockType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group" data-admin-label="Custom Lath Option">
                        <label for="useCustomLath" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="useCustomLath" style="width: auto; margin-right: 8px; vertical-align: middle;">Use Custom Lath
                        </label>
                    </div>
                    <div id="custom-lath-options" data-admin-label="Custom Lath Weight" style="display: none; padding-left: 20px; border-left: 3px solid #e9ecef; margin-bottom: 1.5em; margin-top: -1em;">
                        <div class="form-group">
                            <label for="customLathWeight">Custom Lath Weight (kg/m²)</label>
                            <input type="number" id="customLathWeight" placeholder="e.g., 9.5">
                            <small style="font-size: 0.8em; color: #555;">Note: Other properties (thickness, height) will be based on the lath selected above.</small>
                        </div>
                        <div class="form-group">
                            <label for="customTorqueWeight">Custom Curtain Weight for Lift (kg)</label>
                            <input type="number" id="customTorqueWeight" placeholder="e.g., 150.5">
                            <small style="font-size: 0.8em; color: #555;">If a value is entered here, it will override the calculated 'Curtain Weight (for Torque)'.</small>
                        </div>
                    </div>
                    <div id="lath-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                        <img id="lathImageDisplay" src="" alt="Lath Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                    </div>
                    <div class="form-group" data-admin-label="Powder Coated Option">
                        <label for="powderCoated" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="powderCoated" style="width: auto; margin-right: 8px; vertical-align: middle;">Powder Coated (+0.5 kg/m²)
                        </label>
                    </div>
                    <div class="form-group" data-admin-label="Bottom Lath Type">
                        <label for="bottomLathType">Bottom Lath Type</label>
                        <select id="bottomLathType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div class="form-group" data-admin-label="Add Vision Slats Option">
                        <label for="addVision" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="addVision" style="width: auto; margin-right: 8px; vertical-align: middle;">Add Vision Slats
                        </label>
                    </div>
                    <div id="vision-slat-options" data-admin-label="Vision Slat Details" style="display: none; padding-left: 20px; border-left: 3px solid #e9ecef; margin-bottom: 1.5em; margin-top: -1em;">
                        <div class="form-group">
                            <label for="visionLathType">Vision Lath Type</label>
                            <select id="visionLathType" disabled>
                                <option value="">-- Waiting for file import --</option>
                            </select>
                        </div>
                        <div id="vision-lath-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                            <img id="visionLathImageDisplay" src="" alt="Vision Lath Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                        </div>
                        <div class="form-group">
                            <label for="visionStartHeight">Height to Vision Start (from floor, mm)</label>
                            <input type="number" id="visionStartHeight" placeholder="e.g., 1000">
                            <small style="font-size: 0.8em; color: #555;">This will be adjusted to the nearest lath.</small>
                        </div>
                        <div class="form-group">
                            <label for="visionPanelHeight">Vision Panel Height (mm)</label>
                            <input type="number" id="visionPanelHeight" placeholder="e.g., 500">
                            <small style="font-size: 0.8em; color: #555;">This will be adjusted to the nearest lath.</small>
                        </div>
                    </div>

                    <div class="results">
                        <h3>Shutter Details</h3>
						<p>Curtain Width (Calculated): <span id="calculated-curtain-width">0</span> mm</p>
						<p>Clear Opening (Calculated): <span id="calculated-clear-opening">0</span> mm</p>
						<p>Overall Width (Calculated): <span id="calculated-overall-width">0</span> mm</p>
						<hr>
                        <p>Total Shutter Weight: <span id="weight-kg">0.00</span> kgs</p>
                        <p>Curtain Weight (for Torque): <span id="torque-weight-kg">0.00</span> kgs</p>
                        <p>Total Endlock Weight: <span id="endlock-weight">0.00</span> kgs</p>
                        <p>Total Curtain Area (Material): <span id="curtain-area">0.00</span> m²</p>
						<p>Curtain Area to Lift (Coverage): <span id="lifted-curtain-area">0.00</span> m²</p>
                        <p id="vision-area-m2-para" style="display: none;">Total Vision Area: <span id="vision-area-m2">0.00</span> m²</p>
                        <p id="vision-percentage-para" style="display: none;">Overall Vision Percentage: <span id="vision-percentage">0.00</span> %</p>
                        <p>Total Number of Laths: <span id="lath-count">0</span></p>
                        <p>Laths to Lift: <span id="laths-to-lift">0</span></p>
                        <p>Uncompressed Curtain Height: <span id="curtain-height-extended">0</span> mm</p>
                        <p>Compressed Curtain Height: <span id="curtain-height-compressed">0</span> mm</p>
                        <h4 style="margin-top: 1em; margin-bottom: 0.5em; color: #495057;">Motor Recommendation</h4>
                        <p>Max Required Torque: <span id="max-torque-inputs">0.0</span> Nm</p>
                        <p>Selected Motor: <span id="motor-name-inputs">N/A</span></p>
                        <p id="motor-torque-line-inputs">Motor Torque Range: <span id="motor-torque-inputs">0</span> Nm</p>
                    </div>
                    <div id="shutter-graphic-container"></div>
                    <div id="width-graphic-container" class="graph-container"></div>
                </div>

                <!-- Axle Analysis Tab -->
                <div id="axle-content" class="tab-pane">
                    <h2>Axle Deflection Analysis</h2>
                    
                    <div class="form-group" data-admin-label="Axle Shape">
                        <label>Axle Shape</label>
                        <div class="shape-toggle">
                            <input type="radio" id="shapeCircular" name="axleShape" value="circular" checked>
                            <label for="shapeCircular">Circular</label>
                            <input type="radio" id="shapeOctagonal" name="axleShape" value="octagonal">
                            <label for="shapeOctagonal">Octagonal</label>
                        </div>
                    </div>
                    
                    <div class="form-group" data-admin-label="Axle Type Selector">
                        <label for="axleType">Axle Section (Auto-Selected)</label>
                        <select id="axleType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="collar-size-group" data-admin-label="Collar Size" style="display: none;">
                        <label for="collarSize">Collar Size (mm)</label>
                        <input type="number" id="collarSize" placeholder="e.g., 150" value="0">
                    </div>

                    <div id="deflection-graphic-container" class="graph-container" style="height: 150px;"></div>
                    <div id="axle-cross-section-container" class="graph-container" style="height: 250px; margin-top: 2.5em;"></div>
                    <div class="results">
                        <h3>Axle Performance</h3>
                        <p>Total Axle Length: <span id="total-axle-length">0</span> mm</p>
                        <p>Axle Weight: <span id="axle-weight">0.00</span> kgs</p>
                        <p>Total Weight (for Deflection): <span id="total-deflection-weight">0.00</span> kgs</p>
                        <p>Material Grade: <span id="axle-material-grade">N/A</span></p>
                        <p>Moment of Inertia (I): <span id="moment-of-inertia">0.00</span> mm⁴</p>
                        <p>Calculated Deflection: <span id="axle-deflection">0.00</span> mm</p>
                        <p id="ratio-paragraph">Deflection Ratio: <span id="deflection-ratio">N/A</span></p>
                        <p>Safety Factor: <span id="axle-safety-factor">N/A</span></p>
                    </div>
                    <div id="recommendation-box"></div>
                </div>

                <!-- Motor Tab -->
                <div id="motor-content" class="tab-pane">
                    <h2>Motor & Torque Analysis</h2>
                    <div class="form-group" data-admin-label="Motor Usage Type">
                        <label for="motorUsageFilter">Motor Usage Type</label>
                        <select id="motorUsageFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                     <div class="form-group" data-admin-label="Motor Manufacturer">
                        <label for="motorManufacturerFilter">Motor Manufacturer</label>
                        <select id="motorManufacturerFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                     <div class="form-group" data-admin-label="Motor Voltage">
                        <label for="motorVoltageFilter">Motor Voltage</label>
                        <select id="motorVoltageFilter" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Motor Mounting Type">
                        <label for="motorMountingType">Motor Mounting Type</label>
                        <select id="motorMountingType" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="form-group" data-admin-label="Lath Friction Allowance">
                        <label for="friction">Lath Friction Allowance (%)</label>
                        <input type="number" id="friction" value="10" title="Automatically updated from Lath data. Can be overridden.">
                    </div>
                    <div id="torque-graph-container" class="graph-container" style="height: 280px;"></div>
                    <div class="results">
                        <h3>Torque Calculation</h3>
                        <p>Max Required Torque: <span id="max-torque">0.0</span> Nm</p>
                        <p>Total Revolutions: <span id="total-revolutions">0.0</span></p>
                        <hr>
                        <div class="form-group" data-admin-label="Motor Selector">
                            <label for="motorSelector">Select Motor</label>
                            <select id="motorSelector" disabled>
                                <option>-- First select a mounting type --</option>
                            </select>
                        </div>
                        <h3>Selected Motor Details</h3>
                        <p>Motor Name: <span id="motor-name">N/A</span></p>
                        <p id="motor-torque-line">Motor Torque Range: <span id="motor-torque">0</span> Nm</p>
                        <p>Motor Speed: <span id="motor-rpm">0</span> RPM</p>
                        <p>Opening Time: <span id="opening-time">0</span> seconds</p>
                        <p>Power Consumed per Cycle: <span id="power-consumed">0.0000</span> kWh</p>
                    </div>
                </div>
                
                <div id="endplate-content" class="tab-pane page-break-before-print">
                    <h2>Endplate Selection</h2>
                     <div class="form-group" data-admin-label="Endplate Material">
                        <label>Endplate Material</label>
                        <div class="radio-group">
                            <input type="radio" id="matSteel" name="material" value="Steel" checked>
                            <label for="matSteel">Steel</label>
                            <input type="radio" id="matAluminium" name="material" value="Aluminium">
                            <label for="matAluminium">Aluminium</label>
                        </div>
                    </div>
                    <div class="form-group" data-admin-label="Include Deflection in Sizing">
                        <label for="includeDeflectionInSizing" style="display: inline-block; font-weight: 500; cursor: pointer;">
                            <input type="checkbox" id="includeDeflectionInSizing" style="width: auto; margin-right: 8px; vertical-align: middle;">Include Axle Deflection in Coil Sizing
                        </label>
                    </div>
                    <div class="form-group" data-admin-label="Endplate Selector">
                        <label for="endplateSelector">Select Endplate (Auto-Selected)</label>
                        <select id="endplateSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="results" style="border-left-color: #ffc107;">
                        <h3 style="color: #c79100;">Sizing Details</h3>
                        <p>Maximum Coil Diameter: <span id="max-coil-diameter">0.0</span> mm</p>
                        <p id="effective-coil-para" style="display: none;">Effective Sizing Diameter (inc. deflection): <span id="effective-coil-diameter">0.0</span> mm</p>
                        <hr>
                        <h3>Selected Endplate</h3>
                        <p>Name: <span id="endplate-name">N/A</span></p>
                        <p>Size: <span id="endplate-size">0</span> mm</p>
                        <p>Material: <span id="endplate-material">N/A</span></p>
                        <hr>
                        <h4>Curtain Height Limits by Endplate</h4>
                        <p>For Next Size Down (<span id="prev-endplate-name">N/A</span>): <span id="prev-endplate-height">N/A</span> mm</p>
                        <p>For Next Size Up (<span id="next-endplate-name">N/A</span>): <span id="next-endplate-height">N/A</span> mm</p>
                    </div>
                    <div id="endplate-graphic-container" class="graph-container"></div>
                    <div class="results page-break-before-print" style="border-left-color: #6f42c1; margin-top: 2em;">
                        <h3 style="color: #5a32a3;">Fixing Forces Analysis (Per Endplate, inc. 20% Safety Factor)</h3>
                        <p>Total Downward Shear Force: <span id="endplate-downward-force">0</span> N</p>
                        <p>Resultant Pull-out Force (on top fixing): <span id="endplate-pullout-force">0</span> N</p>
                    </div>
                    <div id="endplate-force-diagram-container" class="graph-container" style="height: 250px; margin-top: 1.5em;"></div>
                </div>

                <!-- Safety Brake Tab -->
                <div id="safety-brake-content" class="tab-pane">
                    <h2>Safety Brake Force Analysis</h2>
                    
                    <div class="form-group" data-admin-label="Safety Brake Selector">
                        <label for="safetyBrakeSelector">Available Safety Brakes (Auto-Selected)</label>
                        <select id="safetyBrakeSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    
                    <div id="safety-brake-image-container" style="margin-top: 1em; margin-bottom: 1.5em; text-align: center; display: none;">
                        <img id="safetyBrakeImageDisplay" src="" alt="Safety Brake Image" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #ccc;">
                    </div>

                    <div class="results" style="border-left-color: #d93025;">
                        <h3 style="color: #d93025;">Worst-Case Impact</h3>
                        <p>Selected Safety Brake: <span id="safety-brake-name">N/A</span></p>
                        <p>Brake Max Torque Capacity: <span id="safety-brake-capacity">N/A</span> Nm</p>
                        <p>Driveshaft Diameter: <span id="safety-brake-driveshaft">N/A</span> mm</p>
                        <p>Worst-Case Activation Height (from floor): <span id="sb-activation-height">0.00</span> m</p>
                        <p>Impact Torque on Axle (inc. 20% factor): <span id="safety-brake-torque">0.00</span> Nm</p>
                        <p>Linear Impact Force: <span id="safety-brake-force-kn">0.00</span> kN</p>
                        <p>Equivalent Linear Force: <span id="safety-brake-force-kg">0.00</span> kgf</p>
                    </div>

                    <div class="calculation-explainer">
                        <h4>Calculation Explained</h4>
                        This calculates the shock load if the shutter free-falls from a worst-case height of <strong>1000mm</strong> from the floor. The fall distance before brake engagement is assumed to be <strong>1/8th of the coil's circumference</strong> at that height. A <strong>20% safety factor</strong> is applied to the calculated torque before selecting a brake.
                        <br><br>
                        <strong>Principle:</strong> Potential Energy (from fall) = Work Done (by brake)
                        <br>
                        <code>Force = (Mass × g × Fall Distance) / Stop Distance</code>
                        <br>
                        <code>Torque = Force × Axle Radius</code>
                        <br><br>
                        <strong>Values Used:</strong>
                        <ul>
                            <li>Mass at worst-case height: <span id="sb-mass">0.00</span> kg</li>
                            <li>Fall Distance: <span id="sb-fall-dist">0.000</span> m</li>
                            <li>Gravity (g): <span>9.81</span> m/s²</li>
                            <li>Stop Distance: <span id="sb-stop-dist">0.010</span> m</li>
                        </ul>
                        <span id="sb-activation-height-explainer" style="display: none;"></span>
                    </div>
                </div>
                
                <div id="wicket-content" class="tab-pane">
                    <h2>Wicket Door Selection</h2>
                    <div class="form-group" data-admin-label="Wicket Door Selector">
                        <label for="wicketDoorSelector">Available Wicket Doors</label>
                        <select id="wicketDoorSelector" disabled>
                            <option value="">-- Waiting for file import --</option>
                        </select>
                    </div>
                    <div class="results" style="border-left-color: #00bcd4;">
                        <h3 style="color: #00838f;">Selected Wicket Door</h3>
                        <p>Name: <span id="wicket-door-name">N/A</span></p>
                        <p>Height: <span id="wicket-door-height">0</span> mm</p>
                        <p>Width: <span id="wicket-door-width">0</span> mm</p>
                        <hr>
                        <p>Laths Level with Wicket Door: <span id="laths-at-wicket">0</span></p>
                        <p>Height to Top of Wicket Laths: <span id="wicket-lath-height">0</span> mm</p>
                        <h3 style="margin-top: 1.5em;">Adjusted Motor Torque</h3>
                        <p>Max Required Torque (with Wicket): <span id="wicket-max-torque">0.0</span> Nm</p>
                    </div>
                    <div id="wicket-graphic-container"></div>
                    <div id="wicket-torque-graph-container" class="graph-container" style="height: 280px;"></div>
                </div>

                <!-- Admin Tab -->
                <div id="admin-content" class="tab-pane">
                    <h2>Admin Controls</h2>
                    
                    <div class="admin-section">
                        <h3>Import from CSV</h3>
                        <div class="form-group" style="display: flex; align-items: center; gap: 1em;">
                            <input type="file" id="csvFileInput" accept=".csv" style="flex-grow: 1;">
                            <button id="importCsvButton">Import</button>
                        </div>
                        <div id="import-status-admin" style="font-style: italic; color: #555;"></div>
                    </div>

                    <div class="admin-section">
                        <h3>Tab Visibility</h3>
                        <div class="admin-button-group">
                            <button id="tabsSelectAll">Select All</button>
                            <button id="tabsDeselectAll">Deselect All</button>
                        </div>
                        <div id="tab-controls-container" class="admin-controls"></div>
                    </div>

                    <div class="admin-section">
                        <h3>Input Option Visibility</h3>
                         <div class="admin-button-group">
                            <button id="inputsSelectAll">Select All</button>
                            <button id="inputsDeselectAll">Deselect All</button>
                        </div>
                        <div id="input-controls-container" class="admin-controls"></div>
                    </div>

                    <!-- NEW: AXLE CALCULATION SETTINGS -->
                    <div class="admin-section">
                        <h3>Axle Calculation Settings</h3>
                        <div class="form-group">
                            <label for="axleFixity">Axle Support Condition (%)</label>
                            <input type="number" id="axleFixity" min="0" max="100" value="30">
                            <small style="color: #555; display: block; margin-top: 0.5em;">
                                0% = Simply Supported Beam (Standard, uses 5/384)<br>
                                100% = Fully Fixed/Built-in Beam (Rigid, uses 1/384)<br>
                                Values in between will interpolate the calculation coefficient.
                            </small>
                        </div>
                    </div>

                    <!-- REPORT GENERATION -->
                    <div id="csv-report-section" class="admin-section">
                        <h3>Generate Sizing Report</h3>
                        <p>Configure the report parameters below.</p>
                        
                        <h4>1. Define Size Range (mm)</h4>
                        <div class="report-controls-grid">
                            <div class="form-group">
                                <label for="reportMinWidth">Min Width</label>
                                <input type="number" id="reportMinWidth" value="1000">
                            </div>
                            <div class="form-group">
                                <label for="reportMaxWidth">Max Width</label>
                                <input type="number" id="reportMaxWidth" value="10000">
                            </div>
                             <div class="form-group">
                                <label for="reportInterval">Interval</label>
                                <input type="number" id="reportInterval" value="100">
                            </div>
                            <div class="form-group">
                                <label for="reportMinHeight">Min Height</label>
                                <input type="number" id="reportMinHeight" value="1000">
                            </div>
                            <div class="form-group">
                                <label for="reportMaxHeight">Max Height</label>
                                <input type="number" id="reportMaxHeight" value="10000">
                            </div>
                        </div>

                        <h4>2. Select Shutter Configuration</h4>
                        <div class="form-row">
                            <!-- UPDATED: Primary Lath -->
                            <div class="form-group form-col">
                                <label for="reportLathType">Primary Lath Type</label>
                                <select id="reportLathType">
                                    <option value="">-- Loading... --</option>
                                </select>
                                <small style="color:#666;">Used up to the width limit below.</small>
                            </div>
                            <!-- NEW: Switch Limit -->
                            <div class="form-group form-col">
                                <label for="reportLathLimit">Switch Width (mm)</label>
                                <input type="number" id="reportLathLimit" placeholder="e.g. 4000">
                                <small style="color:#666;">Width to switch to Secondary Lath.</small>
                            </div>
                            <!-- NEW: Secondary Lath -->
                            <div class="form-group form-col">
                                <label for="reportLathType2">Secondary Lath Type</label>
                                <select id="reportLathType2">
                                    <option value="">-- None (Use Primary) --</option>
                                </select>
                                <small style="color:#666;">Used when Width > Switch Width.</small>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group form-col">
                                <label for="reportEndlockType">Endlock Type</label>
                                <select id="reportEndlockType">
                                    <option value="">-- Loading... --</option>
                                </select>
                            </div>
                            <div class="form-group form-col">
                                <label for="reportBottomLathType">Bottom Lath Type</label>
                                <select id="reportBottomLathType">
                                    <option value="">-- Loading... --</option>
                                </select>
                            </div>
                        </div>

                        <h4>3. Select Motor Usage Types</h4>
                        <div class="admin-button-group">
                            <button id="reportUsageSelectAll">Select All</button>
                            <button id="reportUsageDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-usage-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>

                        <h4>4. Select Motor Manufacturers to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportMotorSelectAll">Select All</button>
                            <button id="reportMotorDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>
                        
                        <h4>5. Select Motor Voltages to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportVoltageSelectAll">Select All</button>
                            <button id="reportVoltageDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-voltage-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>

                        <h4>6. Select Motor Mounting Types to Include</h4>
                        <div class="admin-button-group">
                            <button id="reportMountingSelectAll">Select All</button>
                            <button id="reportMountingDeselectAll">Deselect All</button>
                        </div>
                        <div id="report-motor-mounting-filter-container" class="report-filter-container">
                            <p>Loading motor data...</p>
                        </div>

                        <div class="admin-button-group" style="margin-top: 1.5em;">
                            <button id="generateCsvButton">Generate and Download CSV Report</button>
                        </div>
                        <div id="csv-generation-status" style="font-style: italic; color: #555;"></div>
                    </div>
                </div>

            </div>
        </div>
    </div>
    
    <script>
        let lathData = [], axleData = [], motorData = [], bottomLathData = [], safetyBrakeData = [], endplateData = [], wicketData = [], endlockData = [], guideData = [];
        let lathImageMap = new Map();
        let safetyBrakeImageMap = new Map();
        let currentFilteredMotors = [], currentFilteredEndplates = [];
        let calculatedRotations = 0, maxCoilDiameter = 0;
        let lastTorqueProfile = [];
        let userSelectedAxleIndex = null;
        let visionCalcs = null; 
        
        const dom = {};
        ['width', 'widthType', 'guideType', 'additionalLength', 'height', 'lathType', 'bottomLathType', 'axleType', 'friction', 'import-status', 
         'total-axle-length', 'weight-kg', 'axle-deflection', 'deflection-ratio', 'ratio-paragraph', 
         'recommendation-box', 'deflection-graphic-container', 'torque-graph-container', 'lath-count', 'laths-to-lift',
         'max-torque', 'total-revolutions', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'motorUsageFilter', 'motorSelector', 'motor-name', 'motor-torque', 'motor-rpm', 
         'opening-time', 'motor-torque-line', 'axle-weight', 'axle-material-grade', 'moment-of-inertia', 'total-deflection-weight',
         'safety-brake-force-kn', 'safety-brake-force-kg', 'safety-brake-torque', 'safety-brake-name', 'sb-mass', 'sb-fall-dist', 'sb-stop-dist',
         'sb-activation-height', 'sb-activation-height-explainer', 'safetyBrakeSelector', 'shutter-graphic-container', 'safety-brake-driveshaft',
         'curtain-height-extended', 'curtain-height-compressed', 'endplateSelector', 'matSteel', 'matAluminium', 'endplate-name', 'endplate-size',
         'endplate-material', 'max-coil-diameter', 'prev-endplate-name', 'prev-endplate-height', 'next-endplate-name', 'next-endplate-height',
         'width-warning', 'curtain-area', 'lifted-curtain-area', 'printButton', 'wicketDoorSelector', 'wicket-door-name', 'wicket-door-height', 'wicket-door-width',
         'wicket-graphic-container', 'laths-at-wicket', 'wicket-lath-height', 'wicket-max-torque', 'wicket-torque-graph-container',
         'addVision', 'vision-slat-options', 'visionLathType', 'visionStartHeight', 'visionPanelHeight', 'axle-safety-factor', 'power-consumed',
         'powderCoated', 'axle-cross-section-container', 'visionLathImageDisplay', 'safety-brake-capacity', 
         'safety-brake-image-container', 'safetyBrakeImageDisplay', 'endplate-graphic-container', 'endplate-downward-force', 
         'endplate-pullout-force', 'endplate-force-diagram-container', 'includeDeflectionInSizing', 'effective-coil-para', 'effective-coil-diameter', 'collarSize',
         'vision-percentage', 'vision-percentage-para', 'vision-area-m2', 'vision-area-m2-para', 'endlockType', 'endlock-weight',
         'admin-content', 'tab-content', 'importCsvButton', 'shapeCircular', 'shapeOctagonal', 'collar-size-group', 'torque-weight-kg',
         'useCustomLath', 'custom-lath-options', 'customLathWeight', 'customTorqueWeight', 'max-torque-inputs', 'motor-name-inputs', 'motor-torque-inputs', 'motor-torque-line-inputs',
         'width-graphic-container', 'calculated-curtain-width', 'calculated-clear-opening', 'calculated-overall-width', 'axleFixity',
         'reportLathType', 'reportLathLimit', 'reportLathType2'
        ].forEach(id => dom[id] = document.getElementById(id));
        
        const tabButtons = document.querySelectorAll('.tab-button');
        
        ['width', 'widthType', 'guideType', 'additionalLength', 'height', 'friction', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'motorUsageFilter', 'bottomLathType', 'lathType', 'matSteel', 'matAluminium',
         'visionLathType', 'visionStartHeight', 'visionPanelHeight', 'powderCoated', 'includeDeflectionInSizing', 'collarSize', 'endlockType',
         'useCustomLath', 'customLathWeight', 'customTorqueWeight', 'axleFixity'
        ].forEach(id => {
            if (dom[id]) dom[id].addEventListener('input', () => {
                userSelectedAxleIndex = null; 
                if (id === 'useCustomLath') {
                    const isChecked = dom.useCustomLath.checked;
                    dom['custom-lath-options'].style.display = isChecked ? 'block' : 'none';
                    dom.lathType.disabled = isChecked;
                }
                if (id === 'lathType' && lathData.length > 0) {
                    const selectedLath = lathData[dom.lathType.value];
                    if (selectedLath) {
                        if (selectedLath['Friction %'] !== undefined) {
                            dom.friction.value = selectedLath['Friction %'];
                        }
                        const lathName = (selectedLath['Name'] || '').toLowerCase();
                        if (lathName.includes('wind')) {
                           const endlockSelect = dom.endlockType;
                           for (let i = 0; i < endlockSelect.options.length; i++) {
                               if (endlockSelect.options[i].text.toLowerCase().includes('75mm cast')) {
                                   endlockSelect.value = endlockSelect.options[i].value;
                                   break;
                               }
                           }
                        }
                    }
                }
                updateAllCalculations();
            });
        });

        dom.addVision.addEventListener('change', () => {
            dom['vision-slat-options'].style.display = dom.addVision.checked ? 'block' : 'none';
            updateAllCalculations();
        });

        ['shapeCircular', 'shapeOctagonal'].forEach(id => {
            if (dom[id]) dom[id].addEventListener('change', handleShapeChange);
        });

        dom.motorSelector.addEventListener('change', updateSelectedMotorInfo);
        dom.endplateSelector.addEventListener('change', updateSelectedEndplateInfo);
        tabButtons.forEach(button => button.addEventListener('click', () => switchTab(button.dataset.tab)));
        dom.safetyBrakeSelector.addEventListener('input', updateSelectedSafetyBrakeInfo);
        dom.axleType.addEventListener('input', handleAxleOverride);
        dom.wicketDoorSelector.addEventListener('input', updateSelectedWicketInfo);
        dom.printButton.addEventListener('click', () => {
            window.print();
        });
        dom.importCsvButton.addEventListener('click', handleCsvImport);

        function updatePrintStyles() {
            document.querySelectorAll('.tab-pane').forEach(pane => {
                const tabButton = document.querySelector(`.tab-button[data-tab="${pane.id}"]`);
                if (tabButton && tabButton.style.display === 'none') {
                    pane.classList.add('hide-in-print');
                } else {
                    pane.classList.remove('hide-in-print');
                }
            });
        }

        function initializeAdminControls() {
            const tabContainer = document.getElementById('tab-controls-container');
            const inputContainer = document.getElementById('input-controls-container');
            tabContainer.innerHTML = '';
            inputContainer.innerHTML = '';

            document.querySelectorAll('.tab-button').forEach(tab => {
                const tabId = tab.dataset.tab;
                const labelText = tab.textContent.trim();
                const controlItem = document.createElement('div');
                controlItem.className = 'admin-control-item';
                const isChecked = tab.style.display !== 'none';
                controlItem.innerHTML = `<label><input type="checkbox" data-target-tab="${tabId}" ${isChecked ? 'checked' : ''}>${labelText}</label>`;
                tabContainer.appendChild(controlItem);
                controlItem.querySelector('input').addEventListener('change', (e) => {
                    tab.style.display = e.target.checked ? '' : 'none';
                    updatePrintStyles();
                });
            });

            document.querySelectorAll('[data-admin-label]').forEach((inputGroup, index) => {
                const labelText = inputGroup.dataset.adminLabel;
                const groupId = `admin-input-${index}`;
                inputGroup.id = groupId;
                const controlItem = document.createElement('div');
                controlItem.className = 'admin-control-item';
                controlItem.innerHTML = `<label><input type="checkbox" data-target-input="${groupId}" checked>${labelText}</label>`;
                inputContainer.appendChild(controlItem);
                 controlItem.querySelector('input').addEventListener('change', (e) => {
                    inputGroup.style.display = e.target.checked ? '' : 'none';
                });
            });

            const setupBulkActions = (selectAllId, deselectAllId, containerId) => {
                document.getElementById(selectAllId).addEventListener('click', () => {
                    document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(cb => {
                        if (!cb.checked) {
                            cb.checked = true;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });
                });
                document.getElementById(deselectAllId).addEventListener('click', () => {
                    document.querySelectorAll(`#${containerId} input[type="checkbox"]`).forEach(cb => {
                        if (cb.checked) {
                            cb.checked = false;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });
                });
            };

            setupBulkActions('tabsSelectAll', 'tabsDeselectAll', 'tab-controls-container');
            setupBulkActions('inputsSelectAll', 'inputsDeselectAll', 'input-controls-container');
            updatePrintStyles();
        }

        function handleShapeChange() {
            const selectedShape = document.querySelector('input[name="axleShape"]:checked').value;
            const collarGroup = dom['collar-size-group'];
            if (selectedShape === 'octagonal') {
                collarGroup.style.display = 'block';
            } else {
                collarGroup.style.display = 'none';
                dom.collarSize.value = 0; 
            }
            userSelectedAxleIndex = null;
            updateAllCalculations();
        }

        function handleAxleOverride() {
            if (dom.axleType.value !== "") {
                userSelectedAxleIndex = dom.axleType.value; 
                updateAllCalculations(); 
            }
        }
        
        async function processExcelFile(fileData) {
            userSelectedAxleIndex = null; 
            try {
                const workbook = XLSX.read(new Uint8Array(fileData), { type: 'array' });
                const required = {
                    'Lath': ['Name', 'Kgs/ m2', 'Thickness', 'Compressed lath height', 'uncompressed lath height', 'Friction %', 'Max Width', 'Lath image', 'Moment of inertia iy', 'Allowable Bending Stress (MPa)', 'vision percentage', 'min axle diameter'],
                    'Bottom lath': ['Bottom lath name', 'BLath weight / m length', 'BLath height'],
                    'Axles': ['Name', 'Diameter', 'Wall Thickness', 'Material grade', "Density (kg/m3)", 'Shape'],
                    'Motors': ['Name', 'Torque (Nm) min', 'Torque (Nm) max', 'RPM', 'Mounting type', 'Wattage', 'Voltage', 'Manufacturer', 'Usage type'],
                    'SafetyB': ['Name', 'Max Safety Torque (Nm)', 'Driveshaft diameter mm', 'Stop distance', 'SB image'],
                    'Endplate': ['Name', 'Size', 'Material', 'Fixing holes'],
                    'Wicket doors': ['Name', 'Height', 'Width'],
                    'Endlock': ['Description', 'Weight in grams', 'end lock offset'],
                    'Guides': ['Name', 'Width', 'Penetration']
                };

                for (const sheetName in required) {
                    if (!workbook.Sheets[sheetName]) {
                        if (sheetName === 'Wicket doors' || sheetName === 'Endlock') {
                            if(sheetName === 'Wicket doors') wicketData = [];
                            if(sheetName === 'Endlock') endlockData = [];
                            continue;
                        }
                        throw new Error(`Required sheet "${sheetName}" not found or is empty in the Excel file.`);
                    }
                    const objectData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
                    switch (sheetName) {
                        case 'Lath': lathData = objectData; break;
                        case 'Bottom lath': bottomLathData = objectData; break;
                        case 'Axles': axleData = objectData; break;
                        case 'Motors': motorData = objectData; break;
                        case 'SafetyB': safetyBrakeData = objectData; break;
                        case 'Endplate': endplateData = objectData; break;
                        case 'Wicket doors': wicketData = objectData; break;
                        case 'Endlock': endlockData = objectData; break;
                        case 'Guides': guideData = objectData; break;
                    }
                }

                lathImageMap.clear(); safetyBrakeImageMap.clear();
                const exceljsWorkbook = new ExcelJS.Workbook();
                await exceljsWorkbook.xlsx.load(fileData);

                const lathSheet = exceljsWorkbook.getWorksheet('Lath');
                if (lathSheet) await extractImagesFromSheet(exceljsWorkbook, lathSheet, 'name', 'lath image', lathImageMap);
                
                const safetyBrakeSheet = exceljsWorkbook.getWorksheet('SafetyB');
                if (safetyBrakeSheet) await extractImagesFromSheet(exceljsWorkbook, safetyBrakeSheet, 'name', 'sb image', safetyBrakeImageMap);
                
                populateDropdown(dom.lathType, lathData, 'Name');
                populateDropdown(dom.guideType, guideData, 'Name');
                const visionSelect = dom.visionLathType;
                visionSelect.innerHTML = `<option value="">-- Select a vision lath --</option>`;
                lathData.forEach((item, index) => {
                    const visionKey = Object.keys(item).find(k => k.toLowerCase().trim() === 'vision percentage');
                    const visionValue = visionKey ? (parseFloat(item[visionKey]) || 0) : 0;
                    if (visionValue > 0) {
                        const option = document.createElement('option');
                        option.value = index;
                        const nameKey = Object.keys(item).find(k => k.toLowerCase().trim() === 'name');
                        option.textContent = item[nameKey];
                        visionSelect.appendChild(option);
                    }
                });
                populateDropdown(dom.bottomLathType, bottomLathData, 'Bottom lath name');
                populateDropdown(dom.endlockType, endlockData, 'Description');
                populateMotorMountingTypes();
                populateMotorVoltageFilter();
                populateMotorManufacturerFilter();
                populateMotorUsageFilter();
                populateDropdown(dom.wicketDoorSelector, wicketData, 'Name');

                ['lathType', 'guideType', 'bottomLathType', 'visionLathType', 'motorMountingType', 'motorVoltageFilter', 'motorManufacturerFilter', 'motorUsageFilter', 'safetyBrakeSelector', 'axleType', 'endplateSelector', 'wicketDoorSelector', 'endlockType'].forEach(id => {
                    if(dom[id]) dom[id].disabled = false;
                });

                updateSelectedWicketInfo(); 
                dom['import-status'].textContent = 'Successfully loaded data from repository.';
                dom['import-status'].style.color = 'green';
                updateAllCalculations();
                setupReportFilters();

            } catch (error) {
                dom['import-status'].textContent = `Error processing Excel file: ${error.message}`;
                dom['import-status'].style.color = 'red';
                alert(`Error Reading File: ${error.message}`);
                lathData = []; axleData = []; motorData = []; bottomLathData = []; safetyBrakeData = []; endplateData = []; wicketData = []; endlockData = []; guideData = [];
            }
        }

        function handleCsvImport() {
            const csvFileInput = document.getElementById('csvFileInput');
            const statusDiv = document.getElementById('import-status-admin');
            
            if (!csvFileInput.files || csvFileInput.files.length === 0) {
                statusDiv.textContent = 'Please select a CSV file first.';
                statusDiv.style.color = 'red';
                return;
            }
            const file = csvFileInput.files[0];
            statusDiv.textContent = 'Importing...';
            statusDiv.style.color = '#555';

            Papa.parse(file, {
                header: true, skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        statusDiv.textContent = `Error parsing CSV: ${results.errors[0].message}`;
                        statusDiv.style.color = 'red';
                        return;
                    }
                    if (results.data.length === 0) {
                        statusDiv.textContent = 'CSV file is empty or contains only headers.';
                        statusDiv.style.color = 'red';
                        return;
                    }
                    populateFieldsFromCsv(results.data[0]);
                    statusDiv.textContent = `Successfully imported data for "${results.data[0].Calculation_ID || 'N/A'}".`;
                    statusDiv.style.color = 'green';
                },
                error: function(err) {
                     statusDiv.textContent = `An error occurred: ${err}`;
                     statusDiv.style.color = 'red';
                }
            });
        }

        function populateFieldsFromCsv(data) {
            const getVal = (key) => (data[key] || '').trim();
            const mappings = {
                'Curtain_Width_mm': { id: 'width', type: 'number' },
                'Curtain_Height_mm': { id: 'height', type: 'number' },
                'Additional_Axle_Width_mm': { id: 'additionalLength', type: 'number' },
                'Collar_Size_mm': { id: 'collarSize', type: 'number' },
                'Friction_Allowance_Percent': { id: 'friction', type: 'number' },
                'Vision_Start_Height_mm': { id: 'visionStartHeight', type: 'number' },
                'Vision_Panel_Height_mm': { id: 'visionPanelHeight', type: 'number' },
                'Is_Powder_Coated': { id: 'powderCoated', type: 'checkbox' },
                'Has_Vision_Slats': { id: 'addVision', type: 'checkbox' },
                'Include_Deflection_In_Sizing': { id: 'includeDeflectionInSizing', type: 'checkbox' },
                'Lath_Type_Name': { id: 'lathType', type: 'select' },
                'Endlock_Type_Name': { id: 'endlockType', type: 'select' },
                'Bottom_Lath_Name': { id: 'bottomLathType', type: 'select' },
                'Vision_Lath_Name': { id: 'visionLathType', type: 'select' },
                'Motor_Mounting_Type': { id: 'motorMountingType', type: 'select' },
                'Wicket_Door_Name': { id: 'wicketDoorSelector', type: 'select' },
                'Endplate_Material': { name: 'material', type: 'radio' },
            };

            for (const key in mappings) {
                const value = getVal(key);
                if (value === '') continue;
                const config = mappings[key];
                switch (config.type) {
                    case 'number':
                        const numEl = document.getElementById(config.id);
                        if (numEl) numEl.value = value;
                        break;
                    case 'checkbox':
                        const checkEl = document.getElementById(config.id);
                        if (checkEl) checkEl.checked = (value.toLowerCase() === 'true');
                        break;
                    case 'select':
                        const selectEl = document.getElementById(config.id);
                        if (selectEl) {
                            for (let i = 0; i < selectEl.options.length; i++) {
                                if (selectEl.options[i].text.trim() === value.trim()) {
                                    selectEl.value = selectEl.options[i].value;
                                    break;
                                }
                            }
                        }
                        break;
                    case 'radio':
                        const radioEl = document.querySelector(`input[name="${config.name}"][value="${value}"]`);
                        if (radioEl) radioEl.checked = true;
                        break;
                }
            }
            dom.addVision.dispatchEvent(new Event('change'));
            updateAllCalculations();
            switchTab('inputs-content');
        }

        async function extractImagesFromSheet(workbook, sheet, nameColHeader, imageColHeader, imageMap) {
            let nameCol = -1, imageCol = -1;
            const headerRow = sheet.getRow(1);
            headerRow.eachCell((cell, colNumber) => {
                const headerText = cell.value ? cell.value.toString().toLowerCase().trim() : '';
                if (headerText === nameColHeader) nameCol = colNumber;
                if (headerText === imageColHeader) imageCol = colNumber;
            });

            if (nameCol > 0 && imageCol > 0) {
                const images = sheet.getImages();
                images.forEach(image => {
                    const imageRowNumber = image.range.tl.row + 1;
                    const nameCell = sheet.getCell(imageRowNumber, nameCol);
                    if (nameCell && nameCell.value) {
                        const name = nameCell.value.toString();
                        const imgData = workbook.getImage(image.imageId);
                        const base64Image = btoa(new Uint8Array(imgData.buffer).reduce((data, byte) => data + String.fromCharCode(byte), ''));
                        const imageSrc = `data:image/${imgData.extension};base64,${base64Image}`;
                        imageMap.set(name, imageSrc);
                    }
                });
            }
        }

        function populateMotorMountingTypes() {
            const mountingTypes = [...new Set(motorData.map(motor => motor['Mounting type']))];
            const select = dom.motorMountingType;
            select.innerHTML = '<option value="">-- All Types --</option>';
            mountingTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
        }
        
        function populateMotorVoltageFilter() {
            let voltageKey = '';
            if (motorData.length > 0) {
                voltageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'voltage');
            }
            if (!voltageKey) { dom.motorVoltageFilter.parentElement.style.display = 'none'; return; }
            const voltageTypes = [...new Set(motorData.map(motor => motor[voltageKey]).filter(v => v))];
            const select = dom.motorVoltageFilter;
            select.innerHTML = '<option value="">-- All Voltages --</option>';
            voltageTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
            dom.motorVoltageFilter.parentElement.style.display = 'block';
        }

        function populateMotorManufacturerFilter() {
            let manufacturerKey = '';
            if (motorData.length > 0) {
                manufacturerKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manufacturer');
            }
            if (!manufacturerKey) { dom.motorManufacturerFilter.parentElement.style.display = 'none'; return; }
            const manufacturers = [...new Set(motorData.map(motor => motor[manufacturerKey]).filter(m => m))];
            const select = dom.motorManufacturerFilter;
            select.innerHTML = '<option value="">-- All Manufacturers --</option>';
            manufacturers.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
            dom.motorManufacturerFilter.parentElement.style.display = 'block';
        }

        function populateMotorUsageFilter() {
            let usageKey = '';
            if (motorData.length > 0) {
                usageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'usage type');
            }
            if (!usageKey) { dom.motorUsageFilter.parentElement.style.display = 'none'; return; }
            const usageTypes = [...new Set(motorData.map(motor => motor[usageKey]).filter(m => m))];
            const select = dom.motorUsageFilter;
            select.innerHTML = '<option value="">-- All Usage Types --</option>';
            usageTypes.sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type; option.textContent = type; select.appendChild(option);
            });
            dom.motorUsageFilter.parentElement.style.display = 'block';
        }

        function getLathWithCustomWeight() {
            let selectedLath = lathData[dom.lathType.value];
            if (!selectedLath) return null;
            if (dom.useCustomLath.checked) {
                const customWeight = parseFloat(dom.customLathWeight.value);
                if (!isNaN(customWeight) && customWeight > 0) {
                    let customLath = { ...selectedLath };
                    const weightKey = Object.keys(customLath).find(k => k.toLowerCase().trim() === 'kgs/ m2');
                    if (weightKey) { customLath[weightKey] = customWeight; } else { customLath['Kgs/ m2'] = customWeight; }
                    return customLath;
                }
            }
            return selectedLath;
        }

        function getCalculatedWidths() {
            const inputWidth = parseFloat(dom.width.value) || 0;
            const widthType = dom.widthType.value;
            const selectedGuideIndex = dom.guideType.value;
            let curtainWidth = 0, clearOpening = 0, overallWidth = 0;

            if (selectedGuideIndex !== "" && guideData[selectedGuideIndex]) {
                const guide = guideData[selectedGuideIndex];
                const penetrationKey = Object.keys(guide).find(k => k.toLowerCase().trim() === 'penetration');
                const widthKey = Object.keys(guide).find(k => k.toLowerCase().trim() === 'width');
                const guidePenetration = parseFloat(guide[penetrationKey]) || 0;
                const guideWidth = parseFloat(guide[widthKey]) || 0;

                if (widthType === 'curtainWidth') {
                    curtainWidth = inputWidth;
                    clearOpening = curtainWidth - (2 * guidePenetration);
                    overallWidth = clearOpening + (2 * guideWidth);
                } else if (widthType === 'clearOpening') {
                    clearOpening = inputWidth;
                    curtainWidth = clearOpening + (2 * guidePenetration);
                    overallWidth = clearOpening + (2 * guideWidth);
                } else if (widthType === 'overall') {
                    overallWidth = inputWidth;
                    clearOpening = overallWidth - (2 * guideWidth);
                    curtainWidth = clearOpening + (2 * guidePenetration);
                }
            } else {
                curtainWidth = inputWidth; clearOpening = inputWidth; overallWidth = inputWidth;
            }
            dom['calculated-curtain-width'].textContent = curtainWidth.toFixed(0);
            dom['calculated-clear-opening'].textContent = clearOpening.toFixed(0);
            dom['calculated-overall-width'].textContent = overallWidth.toFixed(0);
            return { curtainWidth, clearOpening, overallWidth };
        }

        function updateAllCalculations() {
            if (lathData.length === 0) { return; };
            const calculatedWidths = getCalculatedWidths();
            const curtainWidth = calculatedWidths.curtainWidth;
            const effectiveLath = getLathWithCustomWeight();
            const lathImageContainer = document.getElementById('lath-image-container');
            const lathImageDisplay = document.getElementById('lathImageDisplay');
            
            if (effectiveLath) {
                const selectedLathName = effectiveLath['Name'];
                if (lathImageMap.has(selectedLathName)) {
                    lathImageDisplay.src = lathImageMap.get(selectedLathName);
                    lathImageContainer.style.display = dom.useCustomLath.checked ? 'none' : 'block';
                } else { lathImageContainer.style.display = 'none'; }
            } else { lathImageContainer.style.display = 'none'; }

            const visionLathImageContainer = document.getElementById('vision-lath-image-container');
            const visionLathImageDisplay = document.getElementById('visionLathImageDisplay');
            if (dom.addVision.checked) {
                const selectedVisionLathIndex = dom.visionLathType.value;
                 if (selectedVisionLathIndex && lathData[selectedVisionLathIndex]) {
                    const selectedVisionLathName = lathData[selectedVisionLathIndex]['Name'];
                    if (lathImageMap.has(selectedVisionLathName)) {
                        visionLathImageDisplay.src = lathImageMap.get(selectedVisionLathName);
                        visionLathImageContainer.style.display = 'block';
                    } else { visionLathImageContainer.style.display = 'none'; }
                } else { visionLathImageContainer.style.display = 'none'; }
            } else { visionLathImageContainer.style.display = 'none'; }

            const widthWarningDiv = dom['width-warning'];
            if (effectiveLath) {
                const maxWidthKey = Object.keys(effectiveLath).find(k => k.toLowerCase().trim() === 'max width');
                const maxWidth = maxWidthKey ? parseFloat(effectiveLath[maxWidthKey]) : 0;
                if (maxWidth > 0 && curtainWidth > maxWidth && !dom.useCustomLath.checked) {
                    widthWarningDiv.textContent = `Warning: Calculated curtain width (${curtainWidth.toFixed(0)} mm) exceeds the maximum of ${maxWidth} mm for this lath type.`;
                    widthWarningDiv.style.display = 'block';
                } else { widthWarningDiv.style.display = 'none'; }
            } else { widthWarningDiv.style.display = 'none'; }
            
            if (axleData.length === 0 || safetyBrakeData.length === 0) {
                drawDeflectionGraphic(0, 0); drawAxleCrossSection(null); calculateSafetyBrakeForce(); drawShutterGraphic(); return;
            };
            
            const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
            const estCurtainProps = calculateCurtainProperties(effectiveLath, selectedBottomLath, null, curtainWidth);
            const { bestAxle } = findAndSetBestAxle(estCurtainProps.totalWeight, curtainWidth);

            const finalCurtainProps = calculateCurtainProperties(effectiveLath, selectedBottomLath, bestAxle, curtainWidth);
            const { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData, endlockOffsets } = finalCurtainProps;
            visionCalcs = visionData;
            calculateEndplateRecommendation(); 

            const { deflection, totalLength } = findAndSetBestAxle(totalWeight, curtainWidth);
            drawDeflectionGraphic(totalLength, deflection);
            calculateMotorRecommendation(torqueWeight, effectiveLath, bestAxle, travelHeight, curtainWidth);
            calculateSafetyBrakeForce(totalWeight, effectiveLath, bestAxle, travelHeight, fullCurtainLength);
            
            const selectedEndplateIndex = dom.endplateSelector.value;
            const selectedEndplate = (selectedEndplateIndex !== "" && currentFilteredEndplates[selectedEndplateIndex]) ? currentFilteredEndplates[selectedEndplateIndex] : null;
            drawShutterGraphic(curtainWidth, parseFloat(dom.additionalLength.value), parseInt(dom['lath-count'].textContent), effectiveLath, selectedBottomLath, bestAxle, selectedEndplate, visionData, endlockOffsets);
            const selectedGuide = guideData.length > 0 ? guideData[dom.guideType.value] : null;
            drawTopDownWidthGraphic(calculatedWidths, selectedGuide);
            updateWicketCalculationsAndGraphic(endlockOffsets, curtainWidth);
        }
        
        function findAndSetBestAxle(totalWeightKgs, curtainWidth) {
            const width = curtainWidth || 0;
            const additionalLength = parseFloat(dom.additionalLength.value) || 0;
            const totalLength = width + additionalLength;
            dom['total-axle-length'].textContent = totalLength.toFixed(0);

            const selectedShape = document.querySelector('input[name="axleShape"]:checked')?.value || 'circular';
            if (totalLength <= 0 || axleData.length === 0) {
                 ['axle-deflection', 'deflection-ratio', 'axle-weight', 'moment-of-inertia', 'total-deflection-weight', 'axle-safety-factor'].forEach(id => dom[id].textContent = '0.00');
                dom['axle-material-grade'].textContent = 'N/A'; dom.axleType.innerHTML = '<option>-- No data --</option>'; drawAxleCrossSection(null);
                return { bestAxle: null, deflection: 0, totalLength: 0 };
            }

            // Filter axles by shape AND min axle diameter if present in lath data
            const currentLath = lathData[dom.lathType.value];
            let minAxleDiameter = 0;
            if (currentLath) {
                const minAxleKey = Object.keys(currentLath).find(k => k.toLowerCase().trim() === 'min axle diameter');
                minAxleDiameter = minAxleKey ? (parseFloat(currentLath[minAxleKey]) || 0) : 0;
            }

            const axlesForShape = axleData.map((axle, index) => ({ ...axle, originalIndex: index })).filter(axle => {
                const axleShapeInSheet = (axle.Shape || 'circular').toLowerCase().trim();
                const axleDia = parseFloat(axle['Diameter']) || 0;
                return axleShapeInSheet === selectedShape && axleDia >= minAxleDiameter;
            });

            if (axlesForShape.length === 0) {
                dom.axleType.innerHTML = `<option>-- No suitable ${selectedShape} axles available (Min Dia: ${minAxleDiameter}mm) --</option>`;
                ['axle-deflection', 'deflection-ratio', 'axle-weight', 'moment-of-inertia', 'total-deflection-weight', 'axle-safety-factor'].forEach(id => dom[id].textContent = '0.00');
                dom['axle-material-grade'].textContent = 'N/A'; drawAxleCrossSection(null);
                return { bestAxle: null, deflection: 0, totalLength: 0 };
            }

            let recommendedAxleOriginalIndex = -1;
            const axlePerformances = [];
            axlesForShape.forEach(currentAxle => {
                const perf = performDeflectionCalc(totalWeightKgs, currentAxle, totalLength);
                axlePerformances.push(perf);
                const passesTest = perf.ratio >= 400 && perf.deflection <= 25;
                if (passesTest && recommendedAxleOriginalIndex === -1) {
                    recommendedAxleOriginalIndex = currentAxle.originalIndex;
                }
            });
            if (recommendedAxleOriginalIndex === -1) { recommendedAxleOriginalIndex = axlesForShape.length > 0 ? axlesForShape[0].originalIndex : -1; }
            let finalSelectedOriginalIndex = userSelectedAxleIndex !== null ? userSelectedAxleIndex : recommendedAxleOriginalIndex;
            
            // Verify user selection fits shape and size constraints
            const isUserSelectionValid = axlesForShape.some(axle => axle.originalIndex == finalSelectedOriginalIndex);
            if (userSelectedAxleIndex !== null && !isUserSelectionValid) { 
                // If filtered out, revert to recommended
                finalSelectedOriginalIndex = recommendedAxleOriginalIndex; 
            }

            const select = dom.axleType; select.innerHTML = '';
            axlesForShape.forEach((axle, index) => {
                const perf = axlePerformances[index];
                const option = document.createElement('option');
                option.value = axle.originalIndex;
                let optionText = axle['Name'];
                if (axle['Alternate name']) optionText += ` (${axle['Alternate name']})`;
                option.textContent = optionText;
                const passesTest = perf.ratio >= 400 && perf.deflection <= 25;
                option.classList.toggle('option-pass', passesTest);
                option.classList.toggle('option-fail', !passesTest);
                select.appendChild(option);
            });
            
            if (finalSelectedOriginalIndex > -1) { select.value = finalSelectedOriginalIndex; }
            const selectedAxleData = axleData[select.value];
            if (!selectedAxleData) { drawAxleCrossSection(null); return { bestAxle: null, deflection: 0, totalLength }; }

            const finalPerformance = performDeflectionCalc(totalWeightKgs, selectedAxleData, totalLength);
            dom['axle-weight'].textContent = finalPerformance.axleWeight.toFixed(2);
            const totalDeflectionWeight = totalWeightKgs + finalPerformance.axleWeight;
            dom['total-deflection-weight'].textContent = totalDeflectionWeight.toFixed(2);
            dom['axle-material-grade'].textContent = finalPerformance.materialGradeValue ? `${finalPerformance.materialGradeValue} MPa` : 'N/A';
            dom['moment-of-inertia'].textContent = finalPerformance.inertiaI.toLocaleString(undefined, { maximumFractionDigits: 2 });
            dom['axle-deflection'].textContent = finalPerformance.deflection.toFixed(2);
            dom['deflection-ratio'].textContent = (finalPerformance.ratio !== Infinity) ? `1 : ${Math.round(finalPerformance.ratio)}` : 'N/A';
            dom['axle-safety-factor'].textContent = isFinite(finalPerformance.safetyFactor) ? finalPerformance.safetyFactor.toFixed(2) : 'Very High';

            if (finalPerformance.ratio < 400 || finalPerformance.deflection > 25) {
                dom['ratio-paragraph'].classList.add('warning-text');
                dom['axle-safety-factor'].parentElement.classList.add('warning-text');
                dom['recommendation-box'].style.display = 'block';
                const nextBest = axlesForShape.find(axle => {
                    const perf = performDeflectionCalc(totalWeightKgs, axle, totalLength);
                    return perf.ratio >= 400 && perf.deflection <= 25;
                });
                if (nextBest) { dom['recommendation-box'].innerHTML = `⚠️ <strong>Warning:</strong> Selected axle may fail. Consider using <strong>${nextBest['Name']}</strong>.`; } else { dom['recommendation-box'].innerHTML = `⚠️ <strong>Critical Warning:</strong> No available ${selectedShape} axle passes the deflection test for this specification.`; }
            } else {
                dom['ratio-paragraph'].classList.remove('warning-text');
                dom['axle-safety-factor'].parentElement.classList.remove('warning-text');
                dom['recommendation-box'].style.display = 'none';
            }
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            drawAxleCrossSection(selectedAxleData, collarSize);
            return { bestAxle: selectedAxleData, deflection: finalPerformance.deflection, totalLength };
        }

        function performDeflectionCalc(totalWeightKgs, axle, totalLength) {
            if (!axle) return { deflection: 0, ratio: Infinity, safetyFactor: Infinity, axleWeight: 0, materialGradeValue: 'N/A', inertiaI: 0 };
            
            const outerDia = parseFloat(axle['Diameter']);
            const wallThick = parseFloat(axle['Wall Thickness']);
            const shape = (axle['Shape'] || 'circular').toLowerCase();
            const lengthM = totalLength / 1000;
            const density = parseFloat(axle['Density (kg/m3)']) || 0;
            const materialGradeValue = axle['Material grade'];
            const youngsModulusE = parseFloat(materialGradeValue) || 199000;
            
            let inertiaI = 0, axleWeight = 0;

            if (shape === 'octagonal') {
                const Do = outerDia; const Di = Do - 2 * wallThick;
                inertiaI = ((11 + 8 * Math.sqrt(2)) / 192) * (Math.pow(Do, 4) - Math.pow(Di, 4));
                const outerArea = 2 * (Math.sqrt(2) - 1) * Math.pow(Do, 2);
                const innerArea = 2 * (Math.sqrt(2) - 1) * Math.pow(Di, 2);
                const hollowArea_mm2 = outerArea - innerArea;
                const volume_m3 = (hollowArea_mm2 / 1000000) * lengthM;
                axleWeight = volume_m3 * density;
            } else {
                inertiaI = (Math.PI / 64) * (Math.pow(outerDia, 4) - Math.pow(outerDia - 2 * wallThick, 4));
                const outerRadiusM = outerDia / 2 / 1000;
                const innerRadiusM = (outerDia - 2 * wallThick) / 2 / 1000;
                const volumeM3 = Math.PI * (Math.pow(outerRadiusM, 2) - Math.pow(innerRadiusM, 2)) * lengthM;
                axleWeight = volumeM3 * density;
            }
            
            const totalForceW = (totalWeightKgs + axleWeight) * 9.81;
            
            // --- UPDATE: Use Axle Fixity Input ---
            const fixityInput = document.getElementById('axleFixity');
            const fixityPercent = fixityInput ? (parseFloat(fixityInput.value) || 0) : 0;
            const safePercent = Math.max(0, Math.min(100, fixityPercent));
            // Interpolate: 0% = 5 (Simple), 100% = 1 (Fixed). Formula: 5 - (4 * percent/100)
            const coefficient = 5 - (4 * (safePercent / 100));
            // -------------------------------------

            const deflection = (totalLength > 0 && inertiaI > 0 && youngsModulusE > 0) 
                ? (coefficient * totalForceW * Math.pow(totalLength, 3)) / (384 * youngsModulusE * inertiaI) 
                : 0;
                
            const ratio = (deflection > 0) ? totalLength / deflection : Infinity;
            const safetyFactor = ratio / 400;
            return { deflection, ratio, safetyFactor, axleWeight, materialGradeValue, inertiaI };
        }
        
        function getEffectiveCoilDiameter(axle) {
            if (!axle) return 0;
            const shape = (axle['Shape'] || 'circular').toLowerCase();
            const diameter = parseFloat(axle['Diameter']) || 0;
            if (shape === 'octagonal') { return diameter / Math.cos(Math.PI / 8); }
            return diameter;
        }
        
        function calculateEndplateRecommendation() {
            if (endplateData.length === 0) return;
            dom['max-coil-diameter'].textContent = maxCoilDiameter.toFixed(1);
            const axleDeflection = parseFloat(dom['axle-deflection'].textContent) || 0;
            let effectiveCoilDiameter = maxCoilDiameter;

            if (dom.includeDeflectionInSizing.checked && axleDeflection > 0) {
                effectiveCoilDiameter += axleDeflection;
                dom['effective-coil-diameter'].textContent = effectiveCoilDiameter.toFixed(1);
                dom['effective-coil-para'].style.display = 'block';
            } else { dom['effective-coil-para'].style.display = 'none'; }
            
            const selectedMaterial = dom.matSteel.checked ? 'Steel' : 'Aluminium';
            currentFilteredEndplates = endplateData.filter(plate => plate.Material.toLowerCase() === selectedMaterial.toLowerCase()).sort((a, b) => a.Size - b.Size);
            const select = dom.endplateSelector;
            select.innerHTML = '';

            if (currentFilteredEndplates.length === 0) {
                select.innerHTML = `<option value="">-- No ${selectedMaterial} plates --</option>`;
                updateSelectedEndplateInfo(); return;
            }
            let recommendedPlateIndex = -1;
            currentFilteredEndplates.forEach((plate, index) => {
                const option = document.createElement('option');
                option.value = index; option.textContent = `${plate.Name} (${plate.Size} mm)`;
                if (plate.Size >= effectiveCoilDiameter) {
                    option.classList.add('option-pass');
                    if (recommendedPlateIndex === -1) { recommendedPlateIndex = index; }
                } else {
                    option.classList.add('option-fail'); option.disabled = true;
                }
                select.appendChild(option);
            });

            if (recommendedPlateIndex !== -1) { select.value = recommendedPlateIndex; } else {
                 const noPlateOption = document.createElement('option');
                noPlateOption.value = ""; noPlateOption.textContent = "-- Coil too large for available plates --";
                noPlateOption.selected = true; noPlateOption.disabled = true;
                select.prepend(noPlateOption); drawEndplateGraphic(null, 0, null, null, 0); 
            }
            updateSelectedEndplateInfo();
        }

        function calculateMaxFloorToAxleHeight(endplateSize, lath, bottomLath, axle) {
            if (!lath || !axle || !bottomLath || !endplateSize || endplateSize <= 0) return 0;
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(axle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
            const axleRadius = effectiveStartDiameter / 2;

            const lathThickness = parseFloat(lath['Thickness']);
            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const uncompressedLathHeight = parseFloat(lath['uncompressed lath height']) || lathCompressedHeight;
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;

            if (lathThickness <= 0 || effectiveStartDiameter <= 0 || endplateSize <= effectiveStartDiameter || uncompressedLathHeight <= 0) return 0;
            const maxRevolutions = (endplateSize - effectiveStartDiameter) / (2 * lathThickness);
            if (maxRevolutions <= 0) return 0;
            const maxCurtainLength = Math.PI * lathThickness * Math.pow(maxRevolutions, 2) + Math.PI * effectiveStartDiameter * maxRevolutions;
            const numLaths = (maxCurtainLength - bottomLathHeight) / uncompressedLathHeight;
            const heightToCoverByLaths = numLaths * lathCompressedHeight;
            const maxFloorToAxleHeight = heightToCoverByLaths + bottomLathHeight - axleRadius;
            return maxFloorToAxleHeight > 0 ? maxFloorToAxleHeight : 0;
        }

        function updateSelectedEndplateInfo() {
            const selectedIndex = parseInt(dom.endplateSelector.value, 10);
            const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
            const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
            const selectedBottomLath = bottomLathData.length > 0 ? bottomLathData[dom.bottomLathType.value] : null;
            const numLaths = parseInt(dom['lath-count'].textContent) || 0;

            if (isNaN(selectedIndex) || !currentFilteredEndplates[selectedIndex]) {
                ['endplate-name', 'endplate-size', 'endplate-material'].forEach(id => { dom[id].textContent = 'N/A'; });
                ['prev-endplate-name', 'prev-endplate-height', 'next-endplate-name', 'next-endplate-height'].forEach(id => { dom[id].textContent = 'N/A'; });
                drawEndplateGraphic(null, 0, null, null, 0); calculateEndplateForces(null);
                return;
            }

            const plate = currentFilteredEndplates[selectedIndex];
            dom['endplate-name'].textContent = plate.Name;
            dom['endplate-size'].textContent = plate.Size;
            dom['endplate-material'].textContent = plate.Material;

            drawEndplateGraphic(plate, maxCoilDiameter, selectedAxle, selectedLath, numLaths);
            calculateEndplateForces(plate);
            
            const prevPlate = selectedIndex > 0 ? currentFilteredEndplates[selectedIndex - 1] : null;
            if (prevPlate && selectedLath && selectedAxle && selectedBottomLath) {
                dom['prev-endplate-name'].textContent = `${prevPlate.Name} (${prevPlate.Size}mm)`;
                const maxHeight = calculateMaxFloorToAxleHeight(prevPlate.Size, selectedLath, selectedBottomLath, selectedAxle);
                dom['prev-endplate-height'].textContent = maxHeight > 0 ? maxHeight.toFixed(0) : 'Too small';
            } else { dom['prev-endplate-name'].textContent = 'N/A'; dom['prev-endplate-height'].textContent = 'N/A'; }
            
            const nextPlate = selectedIndex < currentFilteredEndplates.length - 1 ? currentFilteredEndplates[selectedIndex + 1] : null;
            if (nextPlate && selectedLath && selectedAxle && selectedBottomLath) {
                dom['next-endplate-name'].textContent = `${nextPlate.Name} (${nextPlate.Size}mm)`;
                 const maxHeight = calculateMaxFloorToAxleHeight(nextPlate.Size, selectedLath, selectedBottomLath, selectedAxle);
                dom['next-endplate-height'].textContent = maxHeight > 0 ? maxHeight.toFixed(0) : 'N/A';
            } else { dom['next-endplate-name'].textContent = 'N/A'; dom['next-endplate-height'].textContent = 'N/A'; }
        }

        function calculateEndplateForces(selectedPlate) {
            if (!selectedPlate) {
                dom['endplate-downward-force'].textContent = '0'; dom['endplate-pullout-force'].textContent = '0';
                drawEndplateForceDiagram(0, 0, 0, 0, 0); return;
            }
            const fixingHolesKey = Object.keys(selectedPlate).find(k => k.toLowerCase().trim() === 'fixing holes');
            const fixingHoleSeparation = fixingHolesKey ? parseFloat(selectedPlate[fixingHolesKey]) : 0;
            const fixingHoleSeparationM = fixingHoleSeparation / 1000;
            const curtainWeightKgs = parseFloat(dom['weight-kg'].textContent) || 0;
            const axleWeightKgs = parseFloat(dom['axle-weight'].textContent) || 0;
            const totalStaticWeightKgs = curtainWeightKgs + axleWeightKgs;
            const totalStaticWeightN = totalStaticWeightKgs * 9.81;
            const safetyBrakeImpactN = (parseFloat(dom['safety-brake-force-kn'].textContent) || 0) * 1000;
            const offsetDistanceM = (parseFloat(selectedPlate.Size) / 2) / 1000;
            const staticWeightOnPlateN = totalStaticWeightN / 2;
            const impactOnPlateN = safetyBrakeImpactN / 2;
            const totalDownwardForceOnPlate = staticWeightOnPlateN + impactOnPlateN;
            const moment = staticWeightOnPlateN * offsetDistanceM;
            let pulloutForce = 0;
            if (fixingHoleSeparationM > 0) { pulloutForce = moment / fixingHoleSeparationM; }
            const safetyFactor = 1.20;
            const finalDownwardForce = totalDownwardForceOnPlate * safetyFactor;
            const finalPulloutForce = pulloutForce * safetyFactor;
            dom['endplate-downward-force'].textContent = finalDownwardForce.toFixed(0);
            dom['endplate-pullout-force'].textContent = finalPulloutForce.toFixed(0);
            drawEndplateForceDiagram(finalDownwardForce, finalPulloutForce, offsetDistanceM, fixingHoleSeparation, parseFloat(selectedPlate.Size));
        }

        function selectSafetyBrake(impactTorqueNm) {
            if (safetyBrakeData.length === 0) return null;
            const suitableBrakes = safetyBrakeData.map(b => ({ ...b, MaxTorque: parseFloat(b['Max Safety Torque (Nm)']) })).filter(b => b.MaxTorque >= impactTorqueNm).sort((a, b) => a.MaxTorque - b.MaxTorque);
            return suitableBrakes.length > 0 ? suitableBrakes[0] : null;
        }

        function populateSafetyBrakeDropdown(requiredTorque) {
            const select = dom.safetyBrakeSelector;
            select.innerHTML = ''; 
            if (safetyBrakeData.length === 0) { select.innerHTML = '<option>-- No brake data --</option>'; return; }
            safetyBrakeData.forEach((brake, index) => {
                const option = document.createElement('option');
                option.value = index;
                const maxTorque = parseFloat(brake['Max Safety Torque (Nm)']);
                option.textContent = `${brake.Name} (${maxTorque} Nm)`;
                if (maxTorque >= requiredTorque) { option.classList.add('option-pass'); } else { option.classList.add('option-fail'); option.disabled = true; }
                select.appendChild(option);
            });
        }
        
        function calculateSafetyBrakeForce(totalWeight, lath, axle, travelHeight, fullCurtainLength) {
            if (!axle || !lath || totalWeight <= 0 || !travelHeight || travelHeight <= 0) {
                ['safety-brake-force-kn', 'safety-brake-force-kg', 'safety-brake-torque', 'sb-mass', 'sb-activation-height', 'sb-stop-dist', 'safety-brake-capacity'].forEach(id => dom[id].textContent = 'N/A');
                dom['safety-brake-name'].textContent = 'N/A'; dom.safetyBrakeSelector.innerHTML = '<option>-- Run calculation first --</option>'; return;
            }
            let fallDistanceM = 0.1; 
            if (lath && axle && fullCurtainLength > 1000) {
                const collarSize = parseFloat(dom.collarSize.value) || 0;
                const axleCoilDiameter = getEffectiveCoilDiameter(axle);
                const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
                const lathThickness = parseFloat(lath['Thickness']);
                const rolledUpLength = fullCurtainLength - 1000;
                const a = Math.PI * lathThickness;
                const b = Math.PI * effectiveStartDiameter;
                const c = -rolledUpLength;
                const discriminant = (b * b) - (4 * a * c);
                const revolutions = (discriminant < 0 || a === 0) ? 0 : (-b + Math.sqrt(discriminant)) / (2 * a);
                const diameterAtHeight = effectiveStartDiameter + 2 * revolutions * lathThickness;
                const circumference = Math.PI * diameterAtHeight;
                const calculatedFallDistance = (circumference / 8) / 1000;
                if (calculatedFallDistance > 0) fallDistanceM = calculatedFallDistance;
            }
            const activationHeightFromFloorM = 1.0; 
            const heightLiftedM = (travelHeight / 1000) - activationHeightFromFloorM;
            let percentLifted = (heightLiftedM > 0 && travelHeight > 0) ? heightLiftedM / (travelHeight / 1000) : 0;
            percentLifted = Math.max(0, Math.min(1, percentLifted));
            const fallingMass = totalWeight * (1 - percentLifted);
            const axleRadiusM = (parseFloat(axle['Diameter']) || 0) / 2 / 1000;
            const g = 9.81;
            const preliminaryStopDistanceM = 0.010;
            const potentialEnergy = fallingMass * g * fallDistanceM;
            const impactForceN = (preliminaryStopDistanceM > 0) ? potentialEnergy / preliminaryStopDistanceM : 0;
            const impactTorqueNm = impactForceN * axleRadiusM;
            const requiredTorqueWithSafetyFactor = impactTorqueNm * 1.20;

            populateSafetyBrakeDropdown(requiredTorqueWithSafetyFactor);
            const recommendedBrake = selectSafetyBrake(requiredTorqueWithSafetyFactor);
            let finalStopDistanceM = preliminaryStopDistanceM;
            if (recommendedBrake) {
                const stopDistKey = Object.keys(recommendedBrake).find(k => k.toLowerCase().trim() === 'stop distance');
                if (stopDistKey && parseFloat(recommendedBrake[stopDistKey]) > 0) { finalStopDistanceM = parseFloat(recommendedBrake[stopDistKey]) / 1000; }
            }
            const finalPotentialEnergy = fallingMass * g * fallDistanceM;
            const finalImpactForceN = (finalStopDistanceM > 0) ? finalPotentialEnergy / finalStopDistanceM : 0;
            const finalImpactTorqueNm = finalImpactForceN * axleRadiusM;
            dom['sb-activation-height'].textContent = activationHeightFromFloorM.toFixed(2);
            dom['safety-brake-torque'].textContent = (finalImpactTorqueNm * 1.20).toFixed(2);
            dom['safety-brake-force-kn'].textContent = (finalImpactForceN / 1000).toFixed(2);
            dom['safety-brake-force-kg'].textContent = (finalImpactForceN / g).toFixed(2);
            dom['sb-mass'].textContent = fallingMass.toFixed(2);
            dom['sb-fall-dist'].textContent = fallDistanceM.toFixed(3);
            dom['sb-stop-dist'].textContent = finalStopDistanceM.toFixed(3); 
            if (recommendedBrake) {
                const originalIndex = safetyBrakeData.findIndex(b => b.Name === recommendedBrake.Name);
                if (originalIndex > -1) dom.safetyBrakeSelector.value = originalIndex;
            } else { dom.safetyBrakeSelector.value = ""; }
            updateSelectedSafetyBrakeInfo();
        }

        function calculateMotorRecommendation(totalWeightKgs, lath, axle, travelHeight, curtainWidth) {
            if (!lath || !axle || !travelHeight || travelHeight <= 0 || totalWeightKgs <= 0) {
                ['max-torque', 'total-revolutions', 'max-torque-inputs'].forEach(id => { dom[id].textContent = '0.0'; });
                lastTorqueProfile = []; maxCoilDiameter = 0; drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
                dom.motorSelector.innerHTML = '<option>-- First select a mounting type --</option>';
                dom.motorSelector.disabled = true; updateSelectedMotorInfo(); return;
            }
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(axle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
            calculatedRotations = calculateTotalRevolutions(travelHeight, effectiveStartDiameter, parseFloat(lath['Thickness']));
            dom['total-revolutions'].textContent = calculatedRotations.toFixed(1);
            const { profileData, finalCoilDiameter } = getTorqueProfile(totalWeightKgs, lath, travelHeight, effectiveStartDiameter, curtainWidth);
            maxCoilDiameter = finalCoilDiameter;
            const frictionMultiplier = 1 + (parseFloat(dom.friction.value) || 0) / 100;
            lastTorqueProfile = profileData.map(item => ({...item, torque: item.torque * frictionMultiplier}));
            drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
            const requiredTorque = lastTorqueProfile.length > 0 ? Math.max(...lastTorqueProfile.map(p => p.torque)) : 0;
            dom['max-torque'].textContent = requiredTorque.toFixed(1);
            dom['max-torque-inputs'].textContent = requiredTorque.toFixed(1);

            const selectedMountType = dom.motorMountingType.value;
            const selectedVoltage = dom.motorVoltageFilter.value;
            const selectedManufacturer = dom.motorManufacturerFilter.value;
            const selectedUsage = dom.motorUsageFilter.value;

            let voltageKey = '', manufacturerKey = '', usageKey = '';
            if (motorData.length > 0) {
                voltageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'voltage');
                manufacturerKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'manufacturer');
                usageKey = Object.keys(motorData[0]).find(k => k.toLowerCase().trim() === 'usage type');
            }
            currentFilteredMotors = motorData.filter(motor => {
                const mountMatch = !selectedMountType || motor['Mounting type'] === selectedMountType;
                const voltageMatch = !selectedVoltage || !voltageKey || String(motor[voltageKey]) === String(selectedVoltage);
                const manufacturerMatch = !selectedManufacturer || !manufacturerKey || motor[manufacturerKey] === selectedManufacturer;
                const usageMatch = !selectedUsage || !usageKey || motor[usageKey] === selectedUsage;
                return mountMatch && voltageMatch && manufacturerMatch && usageMatch;
            });
            
            const select = dom.motorSelector; select.innerHTML = ''; select.disabled = false;
            if (currentFilteredMotors.length === 0) {
                select.innerHTML = '<option value="">-- No motors for this type --</option>';
                updateSelectedMotorInfo(); return;
            }
            let recommendedMotorIndexInFilteredList = -1;
            currentFilteredMotors.forEach((motor, index) => {
                const option = document.createElement('option');
                option.value = index;
                const motorTorqueMin = parseFloat(motor['Torque (Nm) min']);
                const motorTorqueMax = parseFloat(motor['Torque (Nm) max']);
                option.textContent = `${motor['Name']} (${motorTorqueMin}-${motorTorqueMax} Nm)`;
                const passesTest = requiredTorque >= motorTorqueMin && requiredTorque <= motorTorqueMax;
                if (passesTest) {
                    option.classList.add('option-pass');
                    if (recommendedMotorIndexInFilteredList === -1) { recommendedMotorIndexInFilteredList = index; }
                } else {
                    option.classList.add('option-fail'); 
                    // Removed option.disabled = true; to allow selection of failed motors
                }
                select.appendChild(option);
            });

            if (recommendedMotorIndexInFilteredList !== -1) { select.value = recommendedMotorIndexInFilteredList; } else {
                const noMotorOption = document.createElement('option');
                noMotorOption.value = ""; noMotorOption.textContent = "-- No suitable motor found --";
                noMotorOption.selected = true; noMotorOption.disabled = true;
                select.prepend(noMotorOption);
            }
            updateSelectedMotorInfo();
        }
        
        function updateSelectedSafetyBrakeInfo() {
            const selectedIndex = dom.safetyBrakeSelector.value;
            const imageContainer = dom['safety-brake-image-container'];
            const imageDisplay = dom['safetyBrakeImageDisplay'];
            if (selectedIndex !== "" && safetyBrakeData[selectedIndex]) {
                const selectedBrake = safetyBrakeData[selectedIndex];
                dom['safety-brake-name'].textContent = selectedBrake.Name;
                dom['safety-brake-name'].classList.remove('warning-text');
                const driveshaftKey = Object.keys(selectedBrake).find(k => k.toLowerCase().trim() === 'driveshaft diameter mm');
                dom['safety-brake-driveshaft'].textContent = driveshaftKey ? selectedBrake[driveshaftKey] : 'N/A';
                const maxTorque = parseFloat(selectedBrake['Max Safety Torque (Nm)']);
                dom['safety-brake-capacity'].textContent = isNaN(maxTorque) ? 'N/A' : maxTorque.toFixed(2);
                const brakeName = selectedBrake.Name;
                if (safetyBrakeImageMap.has(brakeName)) {
                    imageDisplay.src = safetyBrakeImageMap.get(brakeName); imageContainer.style.display = 'block';
                } else { imageContainer.style.display = 'none'; }
            } else {
                dom['safety-brake-name'].textContent = "No suitable safety brake found!";
                dom['safety-brake-name'].classList.add('warning-text');
                dom['safety-brake-driveshaft'].textContent = 'N/A';
                dom['safety-brake-capacity'].textContent = 'N/A';
                imageContainer.style.display = 'none';
            }
        }

        function updateSelectedMotorInfo() {
            const selectedMotorIndex = dom.motorSelector.value;
            if (selectedMotorIndex === "" || !currentFilteredMotors[selectedMotorIndex]) {
                 ['motor-name','motor-torque','motor-rpm','opening-time', 'power-consumed', 'motor-name-inputs', 'motor-torque-inputs'].forEach(id => { dom[id].textContent = 'N/A'; });
                 dom['motor-torque-line'].classList.remove('warning-text'); dom['motor-torque-line-inputs'].classList.remove('warning-text'); return;
            }
            const selectedMotor = currentFilteredMotors[selectedMotorIndex];
            const motorTorqueMin = parseFloat(selectedMotor['Torque (Nm) min']);
            const motorTorqueMax = parseFloat(selectedMotor['Torque (Nm) max']);
            const motorRPM = parseFloat(selectedMotor['RPM']);
            const motorWattage = parseFloat(selectedMotor['Wattage']);
            dom['motor-name'].textContent = selectedMotor['Name'];
            dom['motor-torque'].textContent = `${motorTorqueMin} - ${motorTorqueMax}`; 
            dom['motor-rpm'].textContent = motorRPM;
            dom['motor-name-inputs'].textContent = selectedMotor['Name'];
            dom['motor-torque-inputs'].textContent = `${motorTorqueMin} - ${motorTorqueMax}`;
            let openingTimeSec = 0;
            if (motorRPM > 0 && calculatedRotations > 0) {
                openingTimeSec = (calculatedRotations / motorRPM) * 60;
                dom['opening-time'].textContent = openingTimeSec.toFixed(1);
            } else { dom['opening-time'].textContent = '0'; }
            if (motorWattage > 0 && openingTimeSec > 0) {
                const cycleTimeSec = openingTimeSec * 2;
                const wattHours = (motorWattage * cycleTimeSec) / 3600;
                const kiloWattHours = wattHours / 1000;
                dom['power-consumed'].textContent = `${kiloWattHours.toFixed(4)} kWh`;
            } else { dom['power-consumed'].textContent = 'N/A'; }
            const requiredTorque = parseFloat(dom['max-torque'].textContent);
            if (requiredTorque < motorTorqueMin || requiredTorque > motorTorqueMax) {
                dom['motor-torque-line'].classList.add('warning-text'); dom['motor-torque-line-inputs'].classList.add('warning-text');
            } else {
                dom['motor-torque-line'].classList.remove('warning-text'); dom['motor-torque-line-inputs'].classList.remove('warning-text');
            }
        }
        
        function updateSelectedWicketInfo() {
            const selectedIndex = dom.wicketDoorSelector.value;
            if (selectedIndex !== "" && wicketData[selectedIndex]) {
                const selectedDoor = wicketData[selectedIndex];
                dom['wicket-door-name'].textContent = selectedDoor.Name || 'N/A';
                dom['wicket-door-height'].textContent = selectedDoor.Height || '0';
                dom['wicket-door-width'].textContent = selectedDoor.Width || '0';
            } else {
                dom['wicket-door-name'].textContent = 'N/A'; dom['wicket-door-height'].textContent = '0'; dom['wicket-door-width'].textContent = '0';
            }
            const curtainWidth = parseFloat(dom['calculated-curtain-width'].textContent) || 0;
            updateWicketCalculationsAndGraphic({cast:0, wind:0}, curtainWidth);
        }

        function updateWicketCalculationsAndGraphic(endlockOffsets = {cast: 0, wind: 0}, curtainWidth) {
            const selectedWicketIndex = dom.wicketDoorSelector.value;
            const selectedLathIndex = dom.lathType.value;
            const selectedBottomLathIndex = dom.bottomLathType.value;
            const selectedWicket = (wicketData && selectedWicketIndex !== "") ? wicketData[selectedWicketIndex] : null;
            const selectedLath = (lathData && selectedLathIndex !== "") ? lathData[selectedLathIndex] : null;
            const selectedBottomLath = (bottomLathData && selectedBottomLathIndex !== "") ? bottomLathData[selectedBottomLathIndex] : null;
            const selectedAxle = (axleData && dom.axleType.value !== "") ? axleData[dom.axleType.value] : null;
            let lathsAtWicket = 0, wicketLathHeight = 0;
            if (selectedWicket && selectedLath && selectedBottomLath) {
                const wicketHeight = parseFloat(selectedWicket.Height) || 0;
                const bottomLathHeight = parseFloat(selectedBottomLath['BLath height']) || 0;
                const lathCompressedHeight = parseFloat(selectedLath['Compressed lath height']) || 0;
                if (lathCompressedHeight > 0 && wicketHeight > 0) {
                    const wicketGap = 10; 
                    const heightCoveredByWicketZone = wicketHeight + wicketGap;
                    const lathsInZone = Math.ceil(heightCoveredByWicketZone / lathCompressedHeight);
                    lathsAtWicket = lathsInZone;
                    wicketLathHeight = bottomLathHeight + (lathsInZone * lathCompressedHeight);
                }
            }
            dom['laths-at-wicket'].textContent = lathsAtWicket;
            dom['wicket-lath-height'].textContent = wicketLathHeight.toFixed(0);
            const selectedEndplateIndex = dom.endplateSelector.value;
            const selectedEndplate = (selectedEndplateIndex !== "" && currentFilteredEndplates[selectedEndplateIndex]) ? currentFilteredEndplates[selectedEndplateIndex] : null;
            drawWicketGraphic(curtainWidth, parseFloat(dom.additionalLength.value), parseInt(dom['lath-count'].textContent), selectedLath, selectedBottomLath, selectedAxle, selectedEndplate, selectedWicket, wicketLathHeight, endlockOffsets);
            calculateWicketTorque(curtainWidth);
        }

        function calculateWicketTorque(curtainWidth) {
            const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
            const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
            const selectedWicket = wicketData.length > 0 ? wicketData[dom.wicketDoorSelector.value] : null;
            const totalWeightKgs = parseFloat(dom['torque-weight-kg'].textContent) || 0;
            if (!selectedLath || !selectedAxle || !selectedWicket || totalWeightKgs <= 0) {
                dom['wicket-max-torque'].textContent = '0.0'; drawTorqueGraph([], dom['wicket-torque-graph-container']); return;
            }
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            const bottomLathHeight = bottomLathData.length > 0 ? (parseFloat(bottomLathData[dom.bottomLathType.value]['BLath height']) || 0) : 0;
            const travelHeight = floorToAxleCenter - bottomLathHeight;
            const collarSize = parseFloat(dom.collarSize.value) || 0;
            const axleCoilDiameter = getEffectiveCoilDiameter(selectedAxle);
            const effectiveStartDiameter = Math.max(axleCoilDiameter, collarSize);
            const { profileData } = getTorqueProfileWithWicket(totalWeightKgs, selectedLath, travelHeight, selectedWicket, effectiveStartDiameter, curtainWidth);
            const frictionMultiplier = 1 + (parseFloat(dom.friction.value) || 0) / 100;
            const adjustedProfile = profileData.map(item => ({...item, torque: item.torque * frictionMultiplier}));
            const requiredTorque = adjustedProfile.length > 0 ? Math.max(...adjustedProfile.map(p => p.torque)) : 0;
            dom['wicket-max-torque'].textContent = requiredTorque.toFixed(1);
            drawTorqueGraph(adjustedProfile, dom['wicket-torque-graph-container']);
        }

        function getTorqueProfileWithWicket(totalWeightKgs, lath, travelHeight, wicket, effectiveStartDiameter, curtainWidth) {
            const profileData = []; 
            let heightLifted = 0; 
            let currentRollDiameter = effectiveStartDiameter;
            const lathThickness = parseFloat(lath['Thickness']);
            if (travelHeight <= 0 || totalWeightKgs <= 0) return { profileData: [], finalCoilDiameter: currentRollDiameter };
            const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
            const widthM = (curtainWidth || 0) / 1000;
            const bottomLathHeight = parseFloat(selectedBottomLath['BLath height']) || 0;
            const bottomLathWeight = widthM * (parseFloat(selectedBottomLath['BLath weight / m length']) || 0);
            const lathsWeight = totalWeightKgs - bottomLathWeight;
            const wicketWidthM = (parseFloat(wicket.Width) || 0) / 1000;
            const wicketHeightM = (parseFloat(wicket.Height) || 0) / 1000;
            let lathKgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            if (dom.powderCoated.checked) lathKgsPerM2 += 0.5;
            const wicketWeightReduction = wicketWidthM * wicketHeightM * lathKgsPerM2;
            const wicketStartHeightFromBottomM = (bottomLathHeight / 1000) + (10 / 1000);
            const wicketEndHeightFromBottomM = wicketStartHeightFromBottomM + wicketHeightM;

            while (heightLifted < travelHeight) {
                const percentLifted = heightLifted / travelHeight;
                const remainingLathWeight = lathsWeight * (1 - percentLifted);
                let remainingTotalWeight = remainingLathWeight + bottomLathWeight;
                const curtainHangingHeightM = (travelHeight - heightLifted) / 1000;
                let reduction = 0;
                if (curtainHangingHeightM >= wicketEndHeightFromBottomM) {
                    reduction = wicketWeightReduction;
                } else if (curtainHangingHeightM > wicketStartHeightFromBottomM) {
                    const hangingPortionHeight = curtainHangingHeightM - wicketStartHeightFromBottomM;
                    reduction = wicketWeightReduction * (hangingPortionHeight / wicketHeightM);
                }
                remainingTotalWeight -= reduction;
                remainingTotalWeight = Math.max(0, remainingTotalWeight);
                const force = remainingTotalWeight * 9.81; 
                const radiusM = (currentRollDiameter / 2) / 1000;
                profileData.push({ torque: force * radiusM, diameter: currentRollDiameter, heightLifted: heightLifted });
                const circumference = Math.PI * currentRollDiameter; 
                heightLifted += circumference / 2; 
                currentRollDiameter += lathThickness;
            } 
            return { profileData, finalCoilDiameter: currentRollDiameter };
        };

        function calculateTotalRevolutions(travelHeight, initialDiameter, lathThickness) {
            if (travelHeight <= 0 || initialDiameter <= 0 || lathThickness <= 0) return 0;
            const a = Math.PI * lathThickness;
            const b = Math.PI * initialDiameter;
            const c = -travelHeight;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) return 0;
            return (-b + Math.sqrt(discriminant)) / (2 * a);
        }
        
        function getTorqueProfile(totalWeightKgs, lath, travelHeight, effectiveStartDiameter, curtainWidth) {
            const profileData = []; 
            let heightLifted = 0; 
            let currentRollDiameter = effectiveStartDiameter;
            const lathThickness = parseFloat(lath['Thickness']);
            if (travelHeight <= 0 || totalWeightKgs <= 0) return { profileData: [], finalCoilDiameter: currentRollDiameter };
            const selectedBottomLath = bottomLathData[dom.bottomLathType.value];
            const widthM = (curtainWidth || 0) / 1000;
            const bottomLathWeight = widthM * (parseFloat(selectedBottomLath['BLath weight / m length']) || 0);
            const lathsWeight = totalWeightKgs - bottomLathWeight;
            while (heightLifted < travelHeight) {
                const percentLifted = heightLifted / travelHeight;
                const remainingLathWeight = lathsWeight * (1 - percentLifted);
                const remainingTotalWeight = remainingLathWeight + bottomLathWeight;
                const force = remainingTotalWeight * 9.81; 
                const radiusM = (currentRollDiameter / 2) / 1000;
                profileData.push({ torque: force * radiusM, diameter: currentRollDiameter, heightLifted: heightLifted });
                const circumference = Math.PI * currentRollDiameter; 
                heightLifted += circumference / 2; 
                currentRollDiameter += lathThickness;
            } 
            return { profileData, finalCoilDiameter: currentRollDiameter };
        };
        
        function populateDropdown(selectElement, dataArray, nameField) {
            selectElement.innerHTML = `<option value="">-- Select an option --</option>`;
            dataArray.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = index;
                const header = Object.keys(item).find(k => k.toLowerCase().trim() === nameField.toLowerCase().trim());
                option.textContent = item[header];
                selectElement.appendChild(option);
            });
        };
        
        function calculateCurtainProperties(lath, bottomLath, axle, curtainWidth) {
            const visionEnabled = dom.addVision.checked;
            if (visionEnabled) { return calculateVisionCurtainProperties(lath, bottomLath, axle, curtainWidth); }
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            if (!lath || !bottomLath || floorToAxleCenter <= 0) {
                dom['lath-count'].textContent = '0'; dom['laths-to-lift'].textContent = '0';
                dom['weight-kg'].textContent = '0.00'; dom['torque-weight-kg'].textContent = '0.00';
                dom['curtain-height-extended'].textContent = '0'; dom['curtain-height-compressed'].textContent = '0';
                dom['curtain-area'].textContent = '0.00'; dom['lifted-curtain-area'].textContent = '0.00';
                dom['vision-percentage-para'].style.display = 'none'; dom['vision-area-m2-para'].style.display = 'none';
                dom['endlock-weight'].textContent = '0.00';
                return { totalWeight: 0, torqueWeight: 0, travelHeight: 0, fullCurtainLength: 0, visionData: null, endlockOffsets: { cast: 0, wind: 0 } };
            }
            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const uncompressedLathHeight = parseFloat(lath['uncompressed lath height']);
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
            let axleRadius = 0;
            if (axle) {
                 const axleCoilDiameter = getEffectiveCoilDiameter(axle); axleRadius = axleCoilDiameter / 2;
            } else if (axleData.length > 0) { axleRadius = (getEffectiveCoilDiameter(axleData[0])) / 2; }
            const heightToCoverByLaths = (floorToAxleCenter - bottomLathHeight) + axleRadius;
            let numLaths = 0;
            if (lathCompressedHeight > 0 && heightToCoverByLaths > 0) { numLaths = Math.ceil(heightToCoverByLaths / lathCompressedHeight) + 2; }
            dom['lath-count'].textContent = numLaths;
            const numLathsToLift = numLaths >= 3 ? numLaths - 3 : 0;
            dom['laths-to-lift'].textContent = numLathsToLift;
            const compressedCurtainHeight = (numLaths * lathCompressedHeight) + bottomLathHeight;
            const fullCurtainLength = (numLaths * uncompressedLathHeight) + bottomLathHeight;
            dom['curtain-height-extended'].textContent = fullCurtainLength.toFixed(0);
            dom['curtain-height-compressed'].textContent = compressedCurtainHeight.toFixed(0);
            const widthM = (curtainWidth || 0) / 1000;
            let kgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            if (dom.powderCoated.checked) { kgsPerM2 += 0.5; }
            const totalMaterialAreaM2 = widthM * (fullCurtainLength / 1000);
            dom['curtain-area'].textContent = totalMaterialAreaM2.toFixed(2);
			const liftedLathCoverageLength = (numLathsToLift * lathCompressedHeight);
			const liftedCoverageAreaM2 = widthM * (liftedLathCoverageLength / 1000);
			dom['lifted-curtain-area'].textContent = liftedCoverageAreaM2.toFixed(2);
            const lathWeightBasedOnCoverage = widthM * (numLaths * lathCompressedHeight / 1000) * kgsPerM2;
            const bottomLathWeight = widthM * (parseFloat(bottomLath['BLath weight / m length']) || 0);
            let totalEndlockWeight = 0;
            const lathName = (lath['Name'] || '').toLowerCase();
            const isWindLath = lathName.includes('wind');
            let endlockOffsets = { cast: 0, wind: 0 };
            if (numLaths > 0 && endlockData.length > 0) {
                const selectedCastEndlockIndex = dom.endlockType.value;
                let castEndlockWeightG = 0;
                if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const selectedEndlock = endlockData[selectedCastEndlockIndex];
                    const weightKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                    castEndlockWeightG = weightKey ? parseFloat(selectedEndlock[weightKey]) : 0;
                    const offsetKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                    endlockOffsets.cast = offsetKey ? parseFloat(selectedEndlock[offsetKey]) : 0;
                }
                if (isWindLath) {
                    let windEndlockWeightG = 0;
                    const windEndlock = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
                    if (windEndlock) {
                        const weightKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                        windEndlockWeightG = weightKey ? parseFloat(windEndlock[weightKey]) : 0;
                        const offsetKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                        endlockOffsets.wind = offsetKey ? parseFloat(windEndlock[offsetKey]) : 0;
                    }
                    for (let i = 1; i <= numLaths; i++) {
                        if (i % 2 !== 0 && castEndlockWeightG > 0) { totalEndlockWeight += 2 * (castEndlockWeightG / 1000); }
                        const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                        if (isWindLathPosition && windEndlockWeightG > 0) { totalEndlockWeight += 2 * (windEndlockWeightG / 1000); }
                    }
                } else {
                    if (castEndlockWeightG > 0) {
                         const numEndlockPairs = Math.ceil(numLaths / 2); totalEndlockWeight = numEndlockPairs * 2 * (castEndlockWeightG / 1000);
                    }
                }
            }
            dom['endlock-weight'].textContent = totalEndlockWeight.toFixed(2);
            const totalWeight = lathWeightBasedOnCoverage + bottomLathWeight + totalEndlockWeight;
            dom['weight-kg'].textContent = totalWeight.toFixed(2);
            
            let torqueWeight;
            const customTorqueWeightValue = parseFloat(dom.customTorqueWeight.value);
            if (dom.useCustomLath.checked && !isNaN(customTorqueWeightValue) && customTorqueWeightValue > 0) {
                torqueWeight = customTorqueWeightValue;
            } else {
                torqueWeight = totalWeight;
                if (numLaths >= 3) {
                    const bufferLathWeight = 3 * (lathCompressedHeight / 1000) * widthM * kgsPerM2;
                    let bufferEndlockWeight = 0;
                    const selectedCastEndlockIndex = dom.endlockType.value;
                    if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                        const weightKey = Object.keys(endlockData[selectedCastEndlockIndex]).find(k => k.toLowerCase().trim() === 'weight in grams');
                        const castEndlockWeightG = weightKey ? parseFloat(endlockData[selectedCastEndlockIndex][weightKey]) : 0;
                        if (castEndlockWeightG > 0) { bufferEndlockWeight = 4 * (castEndlockWeightG / 1000); }
                    }
                    torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
                }
            }
            dom['torque-weight-kg'].textContent = torqueWeight.toFixed(2);
            const travelHeight = floorToAxleCenter - bottomLathHeight;
            const mainLathVisionKey = Object.keys(lath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const mainLathVisionPercent = mainLathVisionKey ? (parseFloat(lath[mainLathVisionKey]) || 0) : 0;

            if (mainLathVisionPercent > 0) {
                const visionArea = totalMaterialAreaM2 * (mainLathVisionPercent / 100);
                dom['vision-area-m2'].textContent = visionArea.toFixed(2);
                dom['vision-percentage'].textContent = mainLathVisionPercent.toFixed(2);
                dom['vision-percentage-para'].style.display = 'block'; dom['vision-area-m2-para'].style.display = 'block';
            } else {
                dom['vision-percentage-para'].style.display = 'none'; dom['vision-area-m2-para'].style.display = 'none';
            }
            return { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData: null, endlockOffsets };
        };
        
        function calculateVisionCurtainProperties(mainLath, bottomLath, axle, curtainWidth) {
            const visionLath = lathData[dom.visionLathType.value];
            const widthM = (curtainWidth || 0) / 1000;
            const floorToAxleCenter = parseFloat(dom.height.value) || 0;
            const desiredVisionStart = parseFloat(dom.visionStartHeight.value) || 0;
            const desiredVisionPanelHeight = parseFloat(dom.visionPanelHeight.value) || 0;
            let endlockOffsets = { cast: 0, wind: 0 };
            const resetAndReturn = () => {
                dom['lath-count'].textContent = '0'; dom['laths-to-lift'].textContent = '0';
                dom['weight-kg'].textContent = '0.00'; dom['torque-weight-kg'].textContent = '0.00';
                dom['curtain-height-extended'].textContent = '0'; dom['curtain-height-compressed'].textContent = '0';
                dom['curtain-area'].textContent = '0.00'; dom['lifted-curtain-area'].textContent = '0.00';
                dom['vision-percentage-para'].style.display = 'none'; dom['vision-area-m2-para'].style.display = 'none';
                dom['endlock-weight'].textContent = '0.00';
                return { totalWeight: 0, torqueWeight: 0, travelHeight: 0, fullCurtainLength: 0, visionData: null, endlockOffsets };
            };

            if (!mainLath || !bottomLath || !visionLath || !axle || floorToAxleCenter <= 0 || widthM <= 0) { return resetAndReturn(); }
            const mainLathCompressed = parseFloat(mainLath['Compressed lath height']);
            const mainLathUncompressed = parseFloat(mainLath['uncompressed lath height']) || mainLathCompressed;
            let mainLathKgsM2 = parseFloat(mainLath['Kgs/ m2']);
            if (dom.powderCoated.checked) { mainLathKgsM2 += 0.5; }
            const visionLathCompressed = parseFloat(visionLath['Compressed lath height']);
            const visionLathUncompressed = parseFloat(visionLath['uncompressed lath height']) || visionLathCompressed;
            let visionLathKgsM2 = parseFloat(visionLath['Kgs/ m2']);
            if (dom.powderCoated.checked) { visionLathKgsM2 += 0.5; }

            if (isNaN(mainLathCompressed) || isNaN(visionLathCompressed) || mainLathCompressed <= 0 || visionLathCompressed <= 0) { return resetAndReturn(); }

            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
            const bottomLathWeightPerM = parseFloat(bottomLath['BLath weight / m length']) || 0;
            const axleRadius = getEffectiveCoilDiameter(axle) / 2;
            
            let numLathsBelow = 0;
            if (desiredVisionStart > bottomLathHeight) { numLathsBelow = Math.round((desiredVisionStart - bottomLathHeight) / mainLathCompressed); }
            let numLathsVision = 0;
            if (desiredVisionPanelHeight > 0) { numLathsVision = Math.round(desiredVisionPanelHeight / visionLathCompressed); }
            const heightCoveredSoFar_compressed = bottomLathHeight + (numLathsBelow * mainLathCompressed) + (numLathsVision * visionLathCompressed);
            const remainingHeightToCover = (floorToAxleCenter + axleRadius) - heightCoveredSoFar_compressed;
            let numLathsAbove = 0;
            if (remainingHeightToCover > 0) { numLathsAbove = Math.ceil(remainingHeightToCover / mainLathCompressed) + 2; }

            const totalNumLaths = numLathsBelow + numLathsVision + numLathsAbove;
            dom['lath-count'].textContent = totalNumLaths;
            const numLathsToLift = totalNumLaths >= 3 ? totalNumLaths - 3 : 0;
            dom['laths-to-lift'].textContent = numLathsToLift;
            const weightBelow = numLathsBelow * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
            const weightVision = numLathsVision * (visionLathCompressed / 1000) * widthM * visionLathKgsM2;
            const weightAbove = numLathsAbove * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
            const bottomLathWeight = widthM * bottomLathWeightPerM;
            let totalEndlockWeight = 0;
            const lathName = (mainLath['Name'] || '').toLowerCase();
            const isWindLath = lathName.includes('wind');

            if (totalNumLaths > 0 && endlockData.length > 0) {
                const selectedCastEndlockIndex = dom.endlockType.value;
                let castEndlockWeightG = 0;
                if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                    const selectedEndlock = endlockData[selectedCastEndlockIndex];
                    const weightKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                    castEndlockWeightG = weightKey ? parseFloat(selectedEndlock[weightKey]) : 0;
                    const offsetKey = Object.keys(selectedEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                    endlockOffsets.cast = offsetKey ? parseFloat(selectedEndlock[offsetKey]) : 0;
                }
                if (isWindLath) {
                    let windEndlockWeightG = 0;
                    const windEndlock = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
                    if (windEndlock) {
                        const weightKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                        windEndlockWeightG = weightKey ? parseFloat(windEndlock[weightKey]) : 0;
                        const offsetKey = Object.keys(windEndlock).find(k => k.toLowerCase().trim() === 'end lock offset');
                        endlockOffsets.wind = offsetKey ? parseFloat(windEndlock[offsetKey]) : 0;
                    }
                    for (let i = 1; i <= totalNumLaths; i++) {
                        if (i % 2 !== 0 && castEndlockWeightG > 0) { totalEndlockWeight += 2 * (castEndlockWeightG / 1000); }
                        const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                        if (isWindLathPosition && windEndlockWeightG > 0) { totalEndlockWeight += 2 * (windEndlockWeightG / 1000); }
                    }
                } else {
                    if (castEndlockWeightG > 0) { const numEndlockPairs = Math.ceil(totalNumLaths / 2); totalEndlockWeight = numEndlockPairs * 2 * (castEndlockWeightG / 1000); }
                }
            }
            dom['endlock-weight'].textContent = totalEndlockWeight.toFixed(2);
            const totalWeight = weightBelow + weightVision + weightAbove + bottomLathWeight + totalEndlockWeight;
            dom['weight-kg'].textContent = totalWeight.toFixed(2);

            let torqueWeight;
            const customTorqueWeightValue = parseFloat(dom.customTorqueWeight.value);
            if (dom.useCustomLath.checked && !isNaN(customTorqueWeightValue) && customTorqueWeightValue > 0) {
                torqueWeight = customTorqueWeightValue;
            } else {
                torqueWeight = totalWeight;
                if (numLathsAbove >= 3) {
                    const bufferLathWeight = 3 * (mainLathCompressed / 1000) * widthM * mainLathKgsM2;
                    let bufferEndlockWeight = 0;
                    const selectedCastEndlockIndex = dom.endlockType.value;
                     if (selectedCastEndlockIndex !== "" && endlockData[selectedCastEndlockIndex]) {
                        const weightKey = Object.keys(endlockData[selectedCastEndlockIndex]).find(k => k.toLowerCase().trim() === 'weight in grams');
                        const castEndlockWeightG = weightKey ? parseFloat(endlockData[selectedCastEndlockIndex][weightKey]) : 0;
                        if (castEndlockWeightG > 0) { bufferEndlockWeight = 4 * (castEndlockWeightG / 1000); }
                    }
                    torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
                }
            }
            dom['torque-weight-kg'].textContent = torqueWeight.toFixed(2);
            const compressedCurtainHeight = bottomLathHeight + (numLathsBelow * mainLathCompressed) + (numLathsVision * visionLathCompressed) + (numLathsAbove * mainLathCompressed);
            const fullCurtainLength = bottomLathHeight + (numLathsBelow * mainLathUncompressed) + (numLathsVision * visionLathUncompressed) + (numLathsAbove * mainLathUncompressed);
            const areaBelowMaterial = numLathsBelow * (mainLathUncompressed / 1000) * widthM;
            const areaVisionMaterial = numLathsVision * (visionLathUncompressed / 1000) * widthM;
            const areaAboveMaterial = numLathsAbove * (mainLathUncompressed / 1000) * widthM;
            const totalMaterialArea = areaBelowMaterial + areaVisionMaterial + areaAboveMaterial;
            dom['curtain-area'].textContent = totalMaterialArea.toFixed(2);
			const areaBelowCoverage = numLathsBelow * (mainLathCompressed / 1000) * widthM;
			const areaVisionCoverage = numLathsVision * (visionLathCompressed / 1000) * widthM;
			const numLiftedLathsAbove = Math.max(0, numLathsAbove - 3);
			const liftedAreaAboveCoverage = numLiftedLathsAbove * (mainLathCompressed / 1000) * widthM;
			const liftedCoverageArea = areaBelowCoverage + areaVisionCoverage + liftedAreaAboveCoverage;
			dom['lifted-curtain-area'].textContent = liftedCoverageArea.toFixed(2);
            dom['curtain-height-extended'].textContent = fullCurtainLength.toFixed(0);
            dom['curtain-height-compressed'].textContent = compressedCurtainHeight.toFixed(0);
            const travelHeight = floorToAxleCenter - bottomLathHeight;
            const actualVisionStartHeight = bottomLathHeight + (numLathsBelow * mainLathCompressed);
            const actualVisionPanelHeight = numLathsVision * visionLathCompressed;
            const mainLathVisionKey = Object.keys(mainLath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const mainLathVisionPercent = mainLathVisionKey ? (parseFloat(mainLath[mainLathVisionKey]) || 0) : 0;
            const visionLathVisionKey = Object.keys(visionLath).find(k => k.toLowerCase().trim() === 'vision percentage');
            const visionLathVisionPercent = visionLathVisionKey ? (parseFloat(visionLath[visionLathVisionKey]) || 0) : 0;
            const visionAreaFromMain = (areaBelowMaterial + areaAboveMaterial) * (mainLathVisionPercent / 100);
            const visionAreaFromVisionPanel = areaVisionMaterial * (visionLathVisionPercent / 100);
            const totalActualVisionArea = visionAreaFromMain + visionAreaFromVisionPanel;
            const overallVisionPercentage = (totalMaterialArea > 0) ? (totalActualVisionArea / totalMaterialArea) * 100 : 0;
            dom['vision-area-m2'].textContent = totalActualVisionArea.toFixed(2);
            dom['vision-percentage'].textContent = overallVisionPercentage.toFixed(2);
            dom['vision-percentage-para'].style.display = 'block'; dom['vision-area-m2-para'].style.display = 'block';
            const visionData = { visionLath, numLathsBelow, numLathsVision, numLathsAbove, actualVisionStartHeight, actualVisionPanelHeight };
            return { totalWeight, torqueWeight, travelHeight, fullCurtainLength, visionData, endlockOffsets };
        }

        function drawTorqueGraph(profileData, container) {
            container.innerHTML = '';
            if (!profileData || profileData.length === 0) return;
            const svgNS = "http://www.w3.org/2000/svg", svg = document.createElementNS(svgNS, "svg");
            let svgWidth = container.clientWidth; if (svgWidth === 0) svgWidth = 550; 
            let svgHeight = container.clientHeight; if (svgHeight === 0) svgHeight = 280;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const padding = { top: 30, right: 20, bottom: 60, left: 40 }; 
            const graphWidth = svgWidth - padding.left - padding.right;
            const graphHeight = svgHeight - padding.top - padding.bottom;
            const maxTorque = Math.max(...profileData.map(p => p.torque)) * 1.1 || 10;
            const yAxis = document.createElementNS(svgNS, 'line');
            yAxis.setAttribute('x1', padding.left); yAxis.setAttribute('y1', padding.top);
            yAxis.setAttribute('x2', padding.left); yAxis.setAttribute('y2', padding.top + graphHeight);
            yAxis.setAttribute('class', 'axis-line');
            svg.appendChild(yAxis);
            const xLabel = document.createElementNS(svgNS, 'text');
            xLabel.setAttribute('class', 'graph-text');
            xLabel.setAttribute('transform', `translate(${svgWidth/2}, ${svgHeight - 15})`);
            xLabel.textContent = 'Coil Diameter (mm) / Revolutions';
            svg.appendChild(xLabel);
            const barWidth = Math.max(5, graphWidth / profileData.length * 0.8);
            const barSpacing = Math.max(1, graphWidth / profileData.length * 0.2);
            profileData.forEach((item, index) => {
                const barHeight = (item.torque / maxTorque) * graphHeight;
                const x = padding.left + index * (barWidth + barSpacing);
                const y = padding.top + graphHeight - barHeight;
                const revs = (index + 1) * 0.5;
                const bar = document.createElementNS(svgNS, 'rect');
                bar.setAttribute('x', x); bar.setAttribute('y', y); bar.setAttribute('width', barWidth); bar.setAttribute('height', barHeight); bar.setAttribute('class', 'torque-bar');
                const title = document.createElementNS(svgNS, 'title');
                title.textContent = `Rev ${revs.toFixed(1)}: ${item.torque.toFixed(1)} Nm | Dia: ${item.diameter.toFixed(0)} mm`;
                bar.appendChild(title); svg.appendChild(bar);
                const textX = x + barWidth / 2;
                if (barHeight > 15) {
                    const torqueText = document.createElementNS(svgNS, 'text');
                    torqueText.setAttribute('x', textX); torqueText.setAttribute('y', y - 5); torqueText.setAttribute('class', 'graph-data-label'); 
                    torqueText.textContent = `${item.torque.toFixed(1)} Nm`; svg.appendChild(torqueText);
                }
                const showAxisLabel = profileData.length < 15 || index % Math.ceil(profileData.length / 15) === 0;
                if (showAxisLabel) {
                    const diaText = document.createElementNS(svgNS, 'text');
                    diaText.setAttribute('x', textX); diaText.setAttribute('y', padding.top + graphHeight + 15); diaText.setAttribute('class', 'graph-data-label');
                    diaText.textContent = `Ø${item.diameter.toFixed(0)}`; svg.appendChild(diaText);
                    const revText = document.createElementNS(svgNS, 'text');
                    revText.setAttribute('x', textX); revText.setAttribute('y', padding.top + graphHeight + 28); revText.setAttribute('class', 'graph-data-label');
                    revText.textContent = `(${revs.toFixed(1)}r)`; svg.appendChild(revText);
                }
            });
            container.appendChild(svg);
        }
        
        function drawDeflectionGraphic(length, deflection, isWarning = false) {
            const container = dom['deflection-graphic-container']; container.innerHTML = '';
            const svgNS = "http://www.w3.org/2000/svg", svg = document.createElementNS(svgNS, "svg");
            let svgWidth = container.clientWidth; if (svgWidth === 0) svgWidth = 550;
            let svgHeight = container.clientHeight; if (svgHeight === 0) svgHeight = 150;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const padding = 30, beamY = svgHeight / 2 + 10;
            const maxVisualDeflection = svgHeight * 0.3;
            const numericDeflection = parseFloat(deflection) || 0;
            const visualDeflection = Math.min(maxVisualDeflection, numericDeflection * (maxVisualDeflection / 25));
            const startX = padding, endX = svgWidth - padding;
            const refPath = document.createElementNS(svgNS, 'path');
            refPath.setAttribute('d', `M ${startX} ${beamY} H ${endX}`); refPath.setAttribute('class', 'beam-path');
            svg.appendChild(refPath);
            const deflectedPath = document.createElementNS(svgNS, 'path');
            const controlX = svgWidth / 2, controlY = beamY + visualDeflection;
            deflectedPath.setAttribute('d', `M ${startX},${beamY} Q ${controlX},${controlY} ${endX},${beamY}`); deflectedPath.setAttribute('class', 'deflected-path');
            const ratio = (numericDeflection > 0) ? length / numericDeflection : Infinity;
            if (isWarning || numericDeflection > 25 || ratio < 400) { deflectedPath.classList.add('warning'); }
            svg.appendChild(deflectedPath);
            const supportSize = 10;
            const leftSupport = document.createElementNS(svgNS, 'path');
            leftSupport.setAttribute('d', `M ${startX} ${beamY} l -${supportSize/2} ${supportSize} h ${supportSize} z`); leftSupport.setAttribute('class', 'support-symbol');
            svg.appendChild(leftSupport);
            const rightSupport = document.createElementNS(svgNS, 'path');
            rightSupport.setAttribute('d', `M ${endX} ${beamY} l -${supportSize/2} ${supportSize} h ${supportSize} z`); rightSupport.setAttribute('class', 'support-symbol');
            svg.appendChild(rightSupport);
            if (numericDeflection > 0.1) {
                const text = document.createElementNS(svgNS, 'text');
                text.setAttribute('x', controlX); text.setAttribute('y', controlY + 15); text.setAttribute('class', 'graph-text');
                text.textContent = `${numericDeflection.toFixed(2)} mm`; svg.appendChild(text);
            }
            container.appendChild(svg);
        }

        function drawEndplateForceDiagram(downwardForce, pulloutForce, offsetM, fixingSeparation, endplateSize) {
            const container = dom['endplate-force-diagram-container']; container.innerHTML = '';
            if (downwardForce <= 0 && pulloutForce <= 0) return;
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 450; const svgHeight = 250;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const defs = document.createElementNS(svgNS, 'defs');
            const createMarker = (id, color) => {
                const marker = document.createElementNS(svgNS, 'marker');
                marker.setAttribute('id', id); marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '5'); marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '5'); marker.setAttribute('markerHeight', '5');
                marker.setAttribute('orient', 'auto-start-reverse');
                const arrowPath = document.createElementNS(svgNS, 'path');
                arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', color);
                marker.appendChild(arrowPath); return marker;
            };
            defs.appendChild(createMarker('arrow-force-red', '#d93025'));
            defs.appendChild(createMarker('arrow-force-blue', '#007bff'));
            defs.appendChild(createMarker('arrow-dim', '#343a40'));
            svg.appendChild(defs);
            const createElem = (type, attrs) => {
                const el = document.createElementNS(svgNS, type);
                for (const key in attrs) el.setAttribute(key, attrs[key]); return el;
            };
            const wallX = 120; const plateWidth = 20; const plateHeight = 160;
            const plateY = (svgHeight - plateHeight) / 2; const plateCenterX = wallX + plateWidth / 2; const plateCenterY = plateY + plateHeight / 2;
            svg.appendChild(createElem('line', { x1: wallX, y1: 20, x2: wallX, y2: svgHeight - 40, stroke: '#343a40', 'stroke-width': '4' }));
            svg.appendChild(createElem('rect', { x: wallX, y: plateY, width: plateWidth, height: plateHeight, fill: '#adb5bd', stroke: '#495057'}));
            const scaledFixingSep = Math.min(plateHeight * 0.7, fixingSeparation * 0.5); 
            const topFixingY = plateCenterY - scaledFixingSep / 2; const bottomFixingY = plateCenterY + scaledFixingSep / 2;
            svg.appendChild(createElem('circle', { cx: plateCenterX, cy: topFixingY, r: 4, fill: '#495057' }));
            svg.appendChild(createElem('circle', { cx: plateCenterX, cy: bottomFixingY, r: 4, fill: '#495057' }));
            const coilCenterX = wallX + plateWidth + (offsetM * 1000 * 0.5);
            svg.appendChild(createElem('circle', { cx: coilCenterX, cy: plateCenterY, r: 40, fill: '#e9ecef', stroke: '#adb5bd', 'stroke-dasharray': '4,2' }));
            svg.appendChild(createElem('circle', { cx: coilCenterX, cy: plateCenterY, r: 5, fill: '#6c757d' }));
            const arrowStyleRed = { stroke: '#d93025', 'stroke-width': '2', 'marker-end': 'url(#arrow-force-red)' };
            const arrowStyleBlue = { stroke: '#007bff', 'stroke-width': '2', 'marker-start': 'url(#arrow-force-blue)' };
            svg.appendChild(createElem('line', { x1: coilCenterX, y1: plateCenterY + 40, x2: coilCenterX, y2: plateCenterY + 80, ...arrowStyleRed }));
            const mainForceText = createElem('text', { x: coilCenterX, y: plateCenterY + 95, class: 'force-text red' });
            mainForceText.textContent = `Total Shear: ${downwardForce.toFixed(0)} N`;
            svg.appendChild(mainForceText);
            svg.appendChild(createElem('line', { x1: wallX, y1: topFixingY, x2: wallX - 40, y2: topFixingY, ...arrowStyleRed }));
            svg.appendChild(createElem('line', { x1: wallX - 40, y1: bottomFixingY, x2: wallX, y2: bottomFixingY, ...arrowStyleBlue }));
            const pulloutText = createElem('text', { x: wallX - 45, y: topFixingY, class: 'force-text red', 'text-anchor': 'end', 'dominant-baseline': 'middle' });
            pulloutText.textContent = `${pulloutForce.toFixed(0)} N`; svg.appendChild(pulloutText);
            const compText = createElem('text', { x: wallX - 45, y: bottomFixingY, class: 'force-text blue', 'text-anchor': 'end', 'dominant-baseline': 'middle' });
            compText.textContent = `${pulloutForce.toFixed(0)} N`; svg.appendChild(compText);
            const shearForcePerBolt = downwardForce / 2;
            svg.appendChild(createElem('line', { x1: plateCenterX, y1: topFixingY, x2: plateCenterX, y2: topFixingY + 30, ...arrowStyleRed }));
            svg.appendChild(createElem('line', { x1: plateCenterX, y1: bottomFixingY, x2: plateCenterX, y2: bottomFixingY + 30, ...arrowStyleRed }));
            const shearText = createElem('text', { x: plateCenterX + 5, y: bottomFixingY + 45, class: 'force-text red', 'text-anchor': 'start' });
            shearText.textContent = `Shear: ${shearForcePerBolt.toFixed(0)} N (each)`; svg.appendChild(shearText);
            const dimStyle = { class: 'dimension-line', 'marker-start': 'url(#arrow-dim)', 'marker-end': 'url(#arrow-dim)' };
            const fixDimX = wallX + plateWidth + 20;
            svg.appendChild(createElem('line', { x1: fixDimX, y1: topFixingY, x2: fixDimX, y2: bottomFixingY, ...dimStyle }));
            svg.appendChild(createElem('line', { x1: plateCenterX, y1: topFixingY, x2: fixDimX, y2: topFixingY, class: 'leader-line'}));
            svg.appendChild(createElem('line', { x1: plateCenterX, y1: bottomFixingY, x2: fixDimX, y2: bottomFixingY, class: 'leader-line'}));
            const fixText = createElem('text', { x: fixDimX + 4, y: plateCenterY, class: 'dim-text-force-diagram', 'text-anchor':'start', 'dominant-baseline':'middle', transform:`rotate(-90, ${fixDimX+4}, ${plateCenterY})`});
            fixText.textContent = `${fixingSeparation.toFixed(0)} mm`; svg.appendChild(fixText);
            const offsetDimY = 20;
            svg.appendChild(createElem('line', { x1: wallX, y1: offsetDimY, x2: coilCenterX, y2: offsetDimY, ...dimStyle }));
            const offsetText = createElem('text', { x: wallX + (coilCenterX - wallX)/2, y: offsetDimY - 4, class: 'dim-text-force-diagram' });
            offsetText.textContent = `Offset: ${(offsetM * 1000).toFixed(0)} mm`; svg.appendChild(offsetText);
            container.appendChild(svg);
        }

        function drawEndplateGraphic(endplate, coilDiameter, axle, lath, numLaths) {
            const container = dom['endplate-graphic-container']; container.innerHTML = '';
            if (!endplate || !coilDiameter || !axle || !lath || !numLaths || coilDiameter <= 0) { return; }
            const endplateSize = parseFloat(endplate.Size);
            const lathThickness = parseFloat(lath['Thickness']);
            if (isNaN(endplateSize) || isNaN(lathThickness) || endplateSize <= 0) return;
            const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 550; const svgHeight = 250;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', 'arrow-endplate'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '1'); marker.setAttribute('refY', '5'); marker.setAttribute('markerWidth', '5'); marker.setAttribute('markerHeight', '5'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40');
            marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);
            const padding = { top: 20, right: 120, bottom: 40, left: 20 };
            const graphHeight = svgHeight - padding.top - padding.bottom;
            const scale = graphHeight / endplateSize;
            const scaledBoxSize = endplateSize * scale;
            const boxX = padding.left; const boxY = padding.top + (graphHeight - scaledBoxSize) / 2;
            const centerX = boxX + scaledBoxSize / 2; const centerY = boxY + scaledBoxSize / 2;
            const createElem = (type, attrs) => {
                const el = document.createElementNS(svgNS, type); for (const key in attrs) el.setAttribute(key, attrs[key]); return el;
            };
            svg.appendChild(createElem('rect', { x: boxX, y: boxY, width: scaledBoxSize, height: scaledBoxSize, fill: '#f8f9fa', stroke: '#ced4da', 'stroke-width': '1' }));
            const axleDiameter = getEffectiveCoilDiameter(axle); const scaledAxleRadius = (axleDiameter / 2) * scale;
            svg.appendChild(createElem('circle', { cx: centerX, cy: centerY, r: scaledAxleRadius, class: 'shutter-axle-graphic' }));
            for (let i = 1; i <= numLaths; i++) {
                const currentRadius = (axleDiameter / 2) + (i * lathThickness);
                if (currentRadius * 2 > coilDiameter) break; 
                svg.appendChild(createElem('circle', { cx: centerX, cy: centerY, r: currentRadius * scale, class: 'coil-wrap-graphic' }));
            }
            const scaledCoilRadius = (coilDiameter / 2) * scale;
            svg.appendChild(createElem('circle', { cx: centerX, cy: centerY, r: scaledCoilRadius, fill: 'none', stroke: '#007bff', 'stroke-width': '2' }));
            const dimLineX = boxX + scaledBoxSize + 25;
            svg.appendChild(createElem('line', { x1: boxX, y1: boxY, x2: dimLineX, y2: boxY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: boxX, y1: boxY + scaledBoxSize, x2: dimLineX, y2: boxY + scaledBoxSize, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: dimLineX, y1: boxY, x2: dimLineX, y2: boxY + scaledBoxSize, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
            const boxSizeTextX = dimLineX + 12;
            const boxSizeText = createElem('text', { x: boxSizeTextX, y: centerY, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${boxSizeTextX}, ${centerY})` });
            boxSizeText.textContent = `${endplateSize.toFixed(0)} mm`; svg.appendChild(boxSizeText);
            const coilDimY = boxY + scaledBoxSize + 20;
            svg.appendChild(createElem('line', { x1: centerX - scaledCoilRadius, y1: centerY, x2: centerX - scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: centerX + scaledCoilRadius, y1: centerY, x2: centerX + scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: centerX - scaledCoilRadius, y1: coilDimY, x2: centerX + scaledCoilRadius, y2: coilDimY, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
            const coilDimText = createElem('text', { x: centerX, y: coilDimY + 15, class: 'large-dimension-text' });
            coilDimText.textContent = `Ø ${coilDiameter.toFixed(1)} mm`; svg.appendChild(coilDimText);
            const clearance = (endplateSize - coilDiameter) / 2;
            if (clearance > 1) {
                const clearanceDimX = dimLineX + 40; const topY = boxY; const coilTopY = centerY - scaledCoilRadius;
                svg.appendChild(createElem('line', { x1: centerX, y1: topY, x2: clearanceDimX, y2: topY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
                svg.appendChild(createElem('line', { x1: centerX, y1: coilTopY, x2: clearanceDimX, y2: coilTopY, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
                svg.appendChild(createElem('line', { x1: clearanceDimX, y1: topY, x2: clearanceDimX, y2: coilTopY, class: 'dimension-line', 'marker-start': 'url(#arrow-endplate)', 'marker-end': 'url(#arrow-endplate)' }));
                const clearanceTextX = clearanceDimX + 12;
                const clearanceText = createElem('text', { x: clearanceTextX, y: topY + (coilTopY - topY) / 2, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${clearanceTextX}, ${topY + (coilTopY - topY) / 2})` });
                clearanceText.textContent = `${clearance.toFixed(1)} mm`; svg.appendChild(clearanceText);
            }
            container.appendChild(svg);
        }

        function drawAxleCrossSection(axle, collarSize = 0) {
            const container = dom['axle-cross-section-container']; container.innerHTML = '';
            if (!axle) return;
            const outerDia = parseFloat(axle['Diameter']); const wallThick = parseFloat(axle['Wall Thickness']); const shape = (axle['Shape'] || 'circular').toLowerCase();
            if (isNaN(outerDia) || isNaN(wallThick) || outerDia <= 0 || wallThick <= 0) return;
            const innerDia = outerDia - (2 * wallThick);
            const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 550; const svgHeight = 250; svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const padding = { top: 20, right: 100, bottom: 20, left: 100 };
            const graphSize = Math.min(svgWidth - padding.left - padding.right, svgHeight - padding.top - padding.bottom) * 0.75;
            const displayDiameter = collarSize > outerDia ? collarSize : outerDia;
            const scale = graphSize / displayDiameter;
            const cx = svgWidth / 2; const cy = svgHeight / 2;
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker'); marker.setAttribute('id', 'arrow'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '1'); marker.setAttribute('refY', '5'); marker.setAttribute('markerWidth', '5'); marker.setAttribute('markerHeight', '5'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40'); marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);
            if (shape === 'octagonal') {
                const createOctagon = (flatToFlat, style) => {
                    const circumRadius = (flatToFlat / 2) / Math.cos(Math.PI / 8);
                    const points = [];
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 8) + i * (Math.PI / 4);
                        const x = cx + (circumRadius * scale) * Math.cos(angle);
                        const y = cy - (circumRadius * scale) * Math.sin(angle);
                        points.push(`${x},${y}`);
                    }
                    const polygon = document.createElementNS(svgNS, 'polygon'); polygon.setAttribute('points', points.join(' ')); for (const key in style) polygon.setAttribute(key, style[key]); return polygon;
                };
                const polyStyle = { stroke: '#343a40', 'stroke-width': '1', fill: 'none' };
                svg.appendChild(createOctagon(outerDia, polyStyle)); svg.appendChild(createOctagon(innerDia, polyStyle));
            } else { 
                const createCircle = (diameter, style) => {
                    const circle = document.createElementNS(svgNS, 'circle'); circle.setAttribute('cx', cx); circle.setAttribute('cy', cy); circle.setAttribute('r', (diameter / 2) * scale); for (const key in style) circle.setAttribute(key, style[key]); return circle;
                };
                const circleStyle = { stroke: '#343a40', 'stroke-width': '1', fill: 'none' };
                svg.appendChild(createCircle(outerDia, circleStyle)); svg.appendChild(createCircle(innerDia, circleStyle));
            }
            if (collarSize > outerDia) {
                const collarRadius = (collarSize / 2) * scale;
                const collarCircle = document.createElementNS(svgNS, 'circle'); collarCircle.setAttribute('cx', cx); collarCircle.setAttribute('cy', cy); collarCircle.setAttribute('r', collarRadius); collarCircle.setAttribute('stroke', 'black'); collarCircle.setAttribute('stroke-width', '3'); collarCircle.setAttribute('fill', 'none'); svg.appendChild(collarCircle);
            }
            const createElem = (type, attrs) => { const el = document.createElementNS(svgNS, type); for (const key in attrs) el.setAttribute(key, attrs[key]); return el; };
            const outerRadiusScaled = (outerDia / 2) * scale; const innerRadiusScaled = (innerDia / 2) * scale;
            const od_dim_x = cx + outerRadiusScaled + 40;
            svg.appendChild(createElem('line', { x1: cx, y1: cy - outerRadiusScaled, x2: od_dim_x, y2: cy - outerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: cx, y1: cy + outerRadiusScaled, x2: od_dim_x, y2: cy + outerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: od_dim_x, y1: cy - outerRadiusScaled, x2: od_dim_x, y2: cy + outerRadiusScaled, class: 'dimension-line', 'marker-start': 'url(#arrow)', 'marker-end': 'url(#arrow)' }));
            const odTextX = od_dim_x + 15; const odText = createElem('text', { x: odTextX, y: cy, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${odTextX}, ${cy})` }); odText.textContent = `${outerDia.toFixed(1)}`; svg.appendChild(odText);
            const id_dim_x = cx + innerRadiusScaled + 15;
            svg.appendChild(createElem('line', { x1: cx, y1: cy - innerRadiusScaled, x2: id_dim_x, y2: cy - innerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: cx, y1: cy + innerRadiusScaled, x2: id_dim_x, y2: cy + innerRadiusScaled, class: 'dimension-line', 'stroke-dasharray': '2,2' }));
            svg.appendChild(createElem('line', { x1: id_dim_x, y1: cy - innerRadiusScaled, x2: id_dim_x, y2: cy + innerRadiusScaled, class: 'dimension-line', 'marker-start': 'url(#arrow)', 'marker-end': 'url(#arrow)' }));
            const idTextX = id_dim_x + 15; const idText = createElem('text', { x: idTextX, y: cy, class: 'large-dimension-text', 'text-anchor': 'middle', transform: `rotate(-90, ${idTextX}, ${cy})` }); idText.textContent = `${innerDia.toFixed(1)}`; svg.appendChild(idText);
            const angle = 135 * Math.PI / 180; const arrowTipX = cx + outerRadiusScaled * Math.cos(angle); const arrowTipY = cy - outerRadiusScaled * Math.sin(angle); const leaderElbowX = cx - outerRadiusScaled - 20; const leaderElbowY = cy - outerRadiusScaled - 20;
            svg.appendChild(createElem('line', { x1: leaderElbowX, y1: leaderElbowY, x2: arrowTipX, y2: arrowTipY, class: 'dimension-line', 'marker-end': 'url(#arrow)' }));
            const textLineStartX = leaderElbowX - 30; svg.appendChild(createElem('line', { x1: leaderElbowX, y1: leaderElbowY, x2: textLineStartX, y2: leaderElbowY, class: 'dimension-line' }));
            const wtText = createElem('text', { x: textLineStartX + (leaderElbowX - textLineStartX) / 2, y: leaderElbowY - 8, class: 'large-dimension-text' }); wtText.textContent = `${wallThick.toFixed(1)}`; svg.appendChild(wtText);
            container.appendChild(svg);
        }

        function drawShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, visionData = null, endlockOffsets = {cast: 0, wind: 0}) {
            const container = dom['shutter-graphic-container']; container.innerHTML = '';
            const graphic = createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, { visionOptions: visionData, endlockOffsets: endlockOffsets }, 'shutter');
            if(graphic) container.appendChild(graphic);
        }
        
        function drawWicketGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, wicket, wicketLathHeight, endlockOffsets = {cast: 0, wind: 0}) {
            const container = dom['wicket-graphic-container']; container.innerHTML = '';
            const graphic = createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, { wicket: wicket, endlockOffsets: endlockOffsets }, 'wicket');
            if(graphic) container.appendChild(graphic);
        }

        function drawTopDownWidthGraphic(calculatedWidths, guide) {
            const container = dom['width-graphic-container']; container.innerHTML = '';
            const { curtainWidth, clearOpening, overallWidth } = calculatedWidths;
            if (!guide || !overallWidth || overallWidth <= 0) { return; }
            const penetrationKey = Object.keys(guide).find(k => k.toLowerCase().trim() === 'penetration');
            const guideWidthKey = Object.keys(guide).find(k => k.toLowerCase().trim() === 'width');
            const guidePenetration = parseFloat(guide[penetrationKey]) || 0;
            const guideWidth = parseFloat(guide[guideWidthKey]) || 0;
            const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg");
            const svgWidth = 600; const svgHeight = 180; 
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker'); marker.setAttribute('id', 'dim-arrow-width-graphic'); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '5'); marker.setAttribute('refY', '5'); marker.setAttribute('markerWidth', '4'); marker.setAttribute('markerHeight', '4'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40'); marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);
            const padding = { x: 50, y: 30 }; const graphicWidth = svgWidth - 2 * padding.x; const scale = graphicWidth / overallWidth;
            const curtainHeight = 20; const guideDepth = 30; const graphicTopY = padding.y;
            const scaledGuideWidth = guideWidth * scale; const scaledCurtainWidth = curtainWidth * scale; const scaledClearOpening = clearOpening * scale; const scaledPenetration = guidePenetration * scale;
            const overallStartX = padding.x;
            const guideStyle = { fill: 'none', stroke: '#6c757d', 'stroke-width': '2' };
            const leftGuideX = overallStartX; const leftGuideY = graphicTopY - (guideDepth - curtainHeight) / 2;
            const leftGuidePath = document.createElementNS(svgNS, 'path'); leftGuidePath.setAttribute('d', `M ${leftGuideX + scaledGuideWidth},${leftGuideY} L ${leftGuideX},${leftGuideY} L ${leftGuideX},${leftGuideY + guideDepth} L ${leftGuideX + scaledGuideWidth},${leftGuideY + guideDepth}`); Object.keys(guideStyle).forEach(key => leftGuidePath.setAttribute(key, guideStyle[key])); svg.appendChild(leftGuidePath);
            const rightGuideX = overallStartX + graphicWidth - scaledGuideWidth; const rightGuideY = graphicTopY - (guideDepth - curtainHeight) / 2;
            const rightGuidePath = document.createElementNS(svgNS, 'path'); rightGuidePath.setAttribute('d', `M ${rightGuideX},${rightGuideY} L ${rightGuideX + scaledGuideWidth},${rightGuideY} L ${rightGuideX + scaledGuideWidth},${rightGuideY + guideDepth} L ${rightGuideX},${rightGuideY + guideDepth}`); Object.keys(guideStyle).forEach(key => rightGuidePath.setAttribute(key, guideStyle[key])); svg.appendChild(rightGuidePath);
            const curtainX = overallStartX + scaledGuideWidth - scaledPenetration;
            const curtain = document.createElementNS(svgNS, 'rect'); curtain.setAttribute('x', curtainX); curtain.setAttribute('y', graphicTopY); curtain.setAttribute('width', scaledCurtainWidth); curtain.setAttribute('height', curtainHeight); curtain.setAttribute('class', 'shutter-bottomlath-graphic'); svg.appendChild(curtain);
            const endCapWidth = 5; const leftEndCap = document.createElementNS(svgNS, 'rect'); leftEndCap.setAttribute('x', curtainX); leftEndCap.setAttribute('y', graphicTopY); leftEndCap.setAttribute('width', endCapWidth); leftEndCap.setAttribute('height', curtainHeight); leftEndCap.setAttribute('fill', 'black'); svg.appendChild(leftEndCap);
            const rightEndCap = document.createElementNS(svgNS, 'rect'); rightEndCap.setAttribute('x', curtainX + scaledCurtainWidth - endCapWidth); rightEndCap.setAttribute('y', graphicTopY); rightEndCap.setAttribute('width', endCapWidth); rightEndCap.setAttribute('height', curtainHeight); rightEndCap.setAttribute('fill', 'black'); svg.appendChild(rightEndCap);
            const drawDim = (yOffset, startX, endX, label, value) => {
                const lineY = graphicTopY + guideDepth + yOffset; const tickHeight = 8; const textGap = 5;
                const line = document.createElementNS(svgNS, 'line'); line.setAttribute('x1', startX); line.setAttribute('y1', lineY); line.setAttribute('x2', endX); line.setAttribute('y2', lineY); line.setAttribute('class', 'dimension-line'); line.setAttribute('marker-start', 'url(#dim-arrow-width-graphic)'); line.setAttribute('marker-end', 'url(#dim-arrow-width-graphic)'); svg.appendChild(line);
                const tick1 = document.createElementNS(svgNS, 'line'); tick1.setAttribute('x1', startX); tick1.setAttribute('y1', lineY); tick1.setAttribute('x2', startX); tick1.setAttribute('y2', lineY - tickHeight); tick1.setAttribute('class', 'dimension-tick'); svg.appendChild(tick1);
                const tick2 = document.createElementNS(svgNS, 'line'); tick2.setAttribute('x1', endX); tick2.setAttribute('y1', lineY); tick2.setAttribute('x2', endX); tick2.setAttribute('y2', lineY - tickHeight); tick2.setAttribute('class', 'dimension-tick'); svg.appendChild(tick2);
                const labelText = document.createElementNS(svgNS, 'text'); labelText.textContent = label; labelText.setAttribute('class', 'width-graphic-label'); labelText.setAttribute('x', startX + (endX - startX) / 2); labelText.setAttribute('y', lineY - textGap); svg.appendChild(labelText);
                const valueText = document.createElementNS(svgNS, 'text'); valueText.textContent = `(${value.toFixed(0)} mm)`; valueText.setAttribute('class', 'width-graphic-value'); valueText.setAttribute('x', startX + (endX - startX) / 2); valueText.setAttribute('y', lineY + textGap + 10); svg.appendChild(valueText);
            };
            const clearOpeningStartX = overallStartX + scaledGuideWidth; const clearOpeningEndX = clearOpeningStartX + scaledClearOpening;
            drawDim(30, clearOpeningStartX, clearOpeningEndX, 'Clear Opening', clearOpening);
            const curtainEndX = curtainX + scaledCurtainWidth;
            drawDim(65, curtainX, curtainEndX, 'Curtain width', curtainWidth);
            const overallEndX = overallStartX + graphicWidth;
            drawDim(100, overallStartX, overallEndX, 'Overall width', overallWidth);
            container.appendChild(svg);
        }

        function createBaseShutterGraphic(realWidth, additionalLength, numLaths, lath, bottomLath, axle, selectedEndplate, options = {}, idSuffix = 'default') {
            const svgNS = "http://www.w3.org/2000/svg";
            if (!realWidth || !lath || !bottomLath || !axle) { return null; }
            const { wicket = null, visionOptions = null, endlockOffsets = { cast: 0, wind: 0 } } = options;
            const selectedEndlockIndex = dom.endlockType.value; const endlocksSelected = selectedEndlockIndex !== "" && endlockData[selectedEndlockIndex];
            const svg = document.createElementNS(svgNS, "svg");
            const basePadding = { top: 25, right: 120, bottom: 60, left: 120 };
            const topDimClearance = 35; const totalTopPadding = basePadding.top + topDimClearance;
            const svgWidth = 600; const mainLathHeight = parseFloat(lath['Compressed lath height']);
            const bottomLathHeight = parseFloat(bottomLath['BLath height'] || mainLathHeight);
            const axleDiameter = parseFloat(axle['Diameter']);
            let totalRealCompressedHeight = parseFloat(dom['curtain-height-compressed'].textContent) + axleDiameter;
            const totalRealAxleWidth = realWidth + (additionalLength || 0);
            if (totalRealCompressedHeight <= 0 || totalRealAxleWidth <= 0) return null;
            const graphWidth = svgWidth - basePadding.left - basePadding.right; const scale = graphWidth / totalRealAxleWidth;
            const graphHeight = totalRealCompressedHeight * scale; const svgHeight = graphHeight + totalTopPadding + basePadding.bottom;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker'); marker.setAttribute('id', `dim-arrow-${idSuffix}`); marker.setAttribute('viewBox', '0 0 10 10'); marker.setAttribute('refX', '5'); marker.setAttribute('refY', '5'); marker.setAttribute('markerWidth', '5'); marker.setAttribute('markerHeight', '5'); marker.setAttribute('orient', 'auto-start-reverse');
            const arrowPath = document.createElementNS(svgNS, 'path'); arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z'); arrowPath.setAttribute('fill', '#343a40'); marker.appendChild(arrowPath); defs.appendChild(marker); svg.appendChild(defs);
            const scaledTotalAxleWidth = totalRealAxleWidth * scale; const scaledShutterWidth = realWidth * scale;
            const startX = basePadding.left; const lathStartX = startX + (scaledTotalAxleWidth - scaledShutterWidth) / 2;
            const scaledCastOffset = endlockOffsets.cast * scale; const scaledWindOffset = endlockOffsets.wind * scale;
            const createLeaderLine = (x1, y1, x2, y2) => {
                const line = document.createElementNS(svgNS, 'line'); line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2); line.setAttribute('class', 'leader-line'); svg.appendChild(line);
            };
            const drawDimensionLine = (x1, y1, x2, y2, label, orientation = 'horizontal', textSide = 'right') => {
                const line = document.createElementNS(svgNS, 'line'); line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2); line.setAttribute('class', 'dimension-line'); line.setAttribute('marker-start', `url(#dim-arrow-${idSuffix})`); line.setAttribute('marker-end', `url(#dim-arrow-${idSuffix})`); svg.appendChild(line);
                const text = document.createElementNS(svgNS, 'text'); text.textContent = label; text.setAttribute('class', 'dimension-text');
                if (orientation === 'horizontal') { text.setAttribute('x', x1 + (x2 - x1) / 2); text.setAttribute('y', y1 - 4); } else {
                    const textY = y1 + (y2 - y1) / 2; let textX; if (textSide === 'left') { textX = x1 - 4; text.setAttribute('text-anchor', 'end'); } else { textX = x1 + 4; text.setAttribute('text-anchor', 'start'); }
                    text.setAttribute('x', textX); text.setAttribute('y', textY); text.setAttribute('dominant-baseline', 'middle'); text.setAttribute('transform', `rotate(-90, ${textX}, ${textY})`);
                } svg.appendChild(text);
            };
            const drawAnnotation = (startY, endY, label) => {
                const lineX = basePadding.left - 55; const textX = lineX - 8;
                const line = document.createElementNS(svgNS, 'line'); line.setAttribute('x1', lineX); line.setAttribute('y1', startY); line.setAttribute('x2', lineX); line.setAttribute('y2', endY); line.setAttribute('class', 'dimension-line'); line.setAttribute('marker-start', `url(#dim-arrow-${idSuffix})`); line.setAttribute('marker-end', `url(#dim-arrow-${idSuffix})`); svg.appendChild(line);
                const text = document.createElementNS(svgNS, 'text'); text.setAttribute('x', textX); text.setAttribute('class', 'dimension-text'); text.setAttribute('text-anchor', 'end');
                const charLimit = 14; const words = label.split(' '); let currentLine = '';
                words.forEach(word => {
                    if ((currentLine + ' ' + word).length > charLimit && currentLine.length > 0) {
                        const tspan = document.createElementNS(svgNS, 'tspan'); tspan.setAttribute('x', textX); tspan.setAttribute('dy', '1.2em'); tspan.textContent = word; text.appendChild(tspan); currentLine = word;
                    } else {
                        if (currentLine.length > 0) currentLine += ' '; currentLine += word; if (text.childElementCount === 0) { text.textContent = currentLine; } else { text.lastChild.textContent = currentLine; }
                    }
                });
                const numLines = 1 + text.querySelectorAll('tspan').length; const middleY = startY + (endY - startY) / 2; const lineHeight = 6; 
                const startYForBlock = middleY - ((numLines - 1) * lineHeight / 2); text.setAttribute('y', startYForBlock); svg.appendChild(text);
            };
            const scaledAxleHeight = axleDiameter * scale; const axleY = totalTopPadding; const axleCenterlineY = axleY + scaledAxleHeight / 2; const bottomY = totalTopPadding + graphHeight; let currentY = bottomY;
            let endplateTopY = axleY; 
            if (selectedEndplate) { const endplateSize = parseFloat(selectedEndplate.Size) || 0; if (endplateSize > 0) { const scaledEndplateHeight = endplateSize * scale; endplateTopY = axleCenterlineY - (scaledEndplateHeight / 2); } }
            const scaledBottomLathHeight = bottomLathHeight * scale; currentY -= scaledBottomLathHeight;
            const bottomLathRect = document.createElementNS(svgNS, 'rect'); bottomLathRect.setAttribute('x', lathStartX); bottomLathRect.setAttribute('y', currentY); bottomLathRect.setAttribute('width', scaledShutterWidth); bottomLathRect.setAttribute('height', scaledBottomLathHeight); bottomLathRect.setAttribute('class', 'shutter-bottomlath-graphic'); svg.appendChild(bottomLathRect);
            const bottomLathTopY = currentY;
            const drawEndlocks = (lathY, lathH, leftOffset = 0) => {
                const endlockSide = lathH * 0.8; const endlockY = lathY + (lathH - endlockSide) / 2;
                const leftEndlock = document.createElementNS(svgNS, 'rect'); leftEndlock.setAttribute('x', lathStartX + leftOffset - scaledCastOffset); leftEndlock.setAttribute('y', endlockY); leftEndlock.setAttribute('width', endlockSide); leftEndlock.setAttribute('height', endlockSide); leftEndlock.setAttribute('class', 'endlock-graphic'); svg.appendChild(leftEndlock);
                const rightEndlock = document.createElementNS(svgNS, 'rect'); const curtainRightEdge = lathStartX + scaledShutterWidth; rightEndlock.setAttribute('x', curtainRightEdge + scaledCastOffset - endlockSide); rightEndlock.setAttribute('y', endlockY); rightEndlock.setAttribute('width', endlockSide); rightEndlock.setAttribute('height', endlockSide); rightEndlock.setAttribute('class', 'endlock-graphic'); svg.appendChild(rightEndlock);
            };
            const drawWindEndlocks = (lathY, lathH, leftOffset = 0) => {
                const endlockHeight = lathH * 0.8; const endlockWidth = endlockHeight * 2.5; const endlockY = lathY + (lathH - endlockHeight) / 2;
                const leftEndlock = document.createElementNS(svgNS, 'rect'); leftEndlock.setAttribute('x', lathStartX + leftOffset - scaledWindOffset); leftEndlock.setAttribute('y', endlockY); leftEndlock.setAttribute('width', endlockWidth); leftEndlock.setAttribute('height', endlockHeight); leftEndlock.setAttribute('class', 'wind-endlock-graphic'); svg.appendChild(leftEndlock);
                const rightEndlock = document.createElementNS(svgNS, 'rect'); const curtainRightEdge = lathStartX + scaledShutterWidth; rightEndlock.setAttribute('x', curtainRightEdge + scaledWindOffset - endlockWidth); rightEndlock.setAttribute('y', endlockY); rightEndlock.setAttribute('width', endlockWidth); rightEndlock.setAttribute('height', endlockHeight); rightEndlock.setAttribute('class', 'wind-endlock-graphic'); svg.appendChild(rightEndlock);
            };
            let lathVisualCounter = 1; const isWindLath = (lath['Name'] || '').toLowerCase().includes('wind');
            const wicketRealHeight = wicket ? (parseFloat(wicket.Height) || 0) : 0; const scaledWicketHeight = wicketRealHeight * scale;
            const wicketGap = 10; const scaledWicketGap = wicketGap * scale; const wicketTopY = bottomLathTopY - scaledWicketGap - scaledWicketHeight; const scaledWicketWidth = wicket ? (parseFloat(wicket.Width) || 0) * scale : 0;
            if (visionOptions && visionOptions.visionLath) {
                 const vo = visionOptions; const visionLathCompHeight = parseFloat(vo.visionLath['Compressed lath height']); const scaledMainLathHeight = mainLathHeight * scale; const scaledVisionLathHeight = visionLathCompHeight * scale;
                let sectionBottomY = currentY;
                for (let i = 0; i < vo.numLathsBelow; i++) {
                    currentY -= scaledMainLathHeight; const lathRect = document.createElementNS(svgNS, 'rect'); lathRect.setAttribute('x', lathStartX); lathRect.setAttribute('y', currentY); lathRect.setAttribute('width', scaledShutterWidth); lathRect.setAttribute('height', scaledMainLathHeight); lathRect.setAttribute('class', 'shutter-lath-graphic'); svg.appendChild(lathRect);
                    if (isWindLath) {
                        if (lathVisualCounter % 2 !== 0) drawEndlocks(currentY, scaledMainLathHeight);
                        const isWindPos = (lathVisualCounter === 2 || lathVisualCounter === 4 || lathVisualCounter === 6 || lathVisualCounter === 8) || (lathVisualCounter > 8 && lathVisualCounter % 8 === 0);
                        if (isWindPos) drawWindEndlocks(currentY, scaledMainLathHeight);
                    } else if (endlocksSelected && lathVisualCounter % 2 !== 0) { drawEndlocks(currentY, scaledMainLathHeight); }
                    lathVisualCounter++;
                }
                if (vo.numLathsBelow > 0) drawAnnotation(currentY, sectionBottomY, `${lath['Name']} (x${vo.numLathsBelow})`);
                sectionBottomY = currentY;
                for (let i = 0; i < vo.numLathsVision; i++) {
                    currentY -= scaledVisionLathHeight; const lathRect = document.createElementNS(svgNS, 'rect'); lathRect.setAttribute('x', lathStartX); lathRect.setAttribute('y', currentY); lathRect.setAttribute('width', scaledShutterWidth); lathRect.setAttribute('height', scaledVisionLathHeight); lathRect.setAttribute('class', 'shutter-vision-lath-graphic'); svg.appendChild(lathRect);
                    if (isWindLath) {
                        if (lathVisualCounter % 2 !== 0) drawEndlocks(currentY, scaledVisionLathHeight);
                        const isWindPos = (lathVisualCounter === 2 || lathVisualCounter === 4 || lathVisualCounter === 6 || lathVisualCounter === 8) || (lathVisualCounter > 8 && lathVisualCounter % 8 === 0);
                        if (isWindPos) drawWindEndlocks(currentY, scaledVisionLathHeight);
                    } else if (endlocksSelected && lathVisualCounter % 2 !== 0) { drawEndlocks(currentY, scaledVisionLathHeight); }
                    lathVisualCounter++;
                }
                if (vo.numLathsVision > 0) drawAnnotation(currentY, sectionBottomY, `${vo.visionLath['Name']} (x${vo.numLathsVision})`);
                sectionBottomY = currentY;
                for (let i = 0; i < vo.numLathsAbove; i++) {
                    currentY -= scaledMainLathHeight; const lathRect = document.createElementNS(svgNS, 'rect'); lathRect.setAttribute('x', lathStartX); lathRect.setAttribute('y', currentY); lathRect.setAttribute('width', scaledShutterWidth); lathRect.setAttribute('height', scaledMainLathHeight); lathRect.setAttribute('class', 'shutter-lath-graphic'); svg.appendChild(lathRect);
                    if (isWindLath) {
                        if (lathVisualCounter % 2 !== 0) drawEndlocks(currentY, scaledMainLathHeight);
                        const isWindPos = (lathVisualCounter === 2 || lathVisualCounter === 4 || lathVisualCounter === 6 || lathVisualCounter === 8) || (lathVisualCounter > 8 && lathVisualCounter % 8 === 0);
                        if (isWindPos) drawWindEndlocks(currentY, scaledMainLathHeight);
                    } else if (endlocksSelected && lathVisualCounter % 2 !== 0) { drawEndlocks(currentY, scaledMainLathHeight); }
                    lathVisualCounter++;
                }
                if (vo.numLathsAbove > 0) drawAnnotation(currentY, sectionBottomY, `${lath['Name']} (x${vo.numLathsAbove})`);
            } else if (numLaths > 0) {
                 const scaledLathHeight = mainLathHeight * scale;
                 for (let i = 0; i < numLaths; i++) {
                    currentY -= scaledLathHeight; const lathNumber = i + 1; const lathBottomEdgeY = currentY + scaledLathHeight;
                    const lathRect = document.createElementNS(svgNS, 'rect'); lathRect.setAttribute('x', lathStartX); lathRect.setAttribute('y', currentY); lathRect.setAttribute('width', scaledShutterWidth); lathRect.setAttribute('height', scaledLathHeight); lathRect.setAttribute('class', 'shutter-lath-graphic'); svg.appendChild(lathRect);
                    const leftOffset = (wicket && lathBottomEdgeY > wicketTopY) ? scaledWicketWidth : 0;
                    if (isWindLath) {
                        if (lathNumber % 2 !== 0) { drawEndlocks(currentY, scaledLathHeight, leftOffset); }
                        const isWindLathPosition = (lathNumber === 2 || lathNumber === 4 || lathNumber === 6 || lathNumber === 8) || (lathNumber > 8 && lathNumber % 8 === 0);
                        if (isWindLathPosition) { drawWindEndlocks(currentY, scaledLathHeight, leftOffset); }
                    } else if (endlocksSelected && lathNumber % 2 !== 0) { drawEndlocks(currentY, scaledLathHeight, leftOffset); }
                }
                drawAnnotation(currentY, bottomLathTopY, `${lath['Name']} (x${numLaths})`);
            }
            if (selectedEndplate) {
                const endplateSize = parseFloat(selectedEndplate.Size) || 0;
                if (endplateSize > 0) {
                    const scaledEndplateHeight = endplateSize * scale;
                    const endplateBox = document.createElementNS(svgNS, 'rect'); endplateBox.setAttribute('x', startX); endplateBox.setAttribute('y', endplateTopY); endplateBox.setAttribute('width', scaledTotalAxleWidth); endplateBox.setAttribute('height', scaledEndplateHeight); endplateBox.setAttribute('class', 'endplate-box-graphic'); svg.appendChild(endplateBox);
                }
            }
            const axleRect = document.createElementNS(svgNS, 'rect'); axleRect.setAttribute('x', startX); axleRect.setAttribute('y', axleY); axleRect.setAttribute('width', scaledTotalAxleWidth); axleRect.setAttribute('height', scaledAxleHeight); axleRect.setAttribute('class', 'shutter-axle-graphic'); svg.appendChild(axleRect);
            const centerline = document.createElementNS(svgNS, 'line'); centerline.setAttribute('x1', startX); centerline.setAttribute('y1', axleCenterlineY); centerline.setAttribute('x2', startX + scaledTotalAxleWidth); centerline.setAttribute('y2', axleCenterlineY); centerline.setAttribute('class', 'axle-centerline-graphic'); svg.appendChild(centerline);
            if (wicket) {
                const wicketRect = document.createElementNS(svgNS, 'rect'); wicketRect.setAttribute('x', lathStartX); wicketRect.setAttribute('y', wicketTopY); wicketRect.setAttribute('width', scaledWicketWidth); wicketRect.setAttribute('height', scaledWicketHeight); wicketRect.setAttribute('class', 'wicket-door-graphic'); svg.appendChild(wicketRect);
            }
            const totalWidthDimY = basePadding.top;
            drawDimensionLine(startX, totalWidthDimY, startX + scaledTotalAxleWidth, totalWidthDimY, `${totalRealAxleWidth.toFixed(0)} mm Axle Width`, 'horizontal');
            createLeaderLine(startX, totalWidthDimY, startX, axleY); createLeaderLine(startX + scaledTotalAxleWidth, totalWidthDimY, startX + scaledTotalAxleWidth, axleY);
            const widthDimLineY = bottomY + 15;
            drawDimensionLine(lathStartX, widthDimLineY, lathStartX + scaledShutterWidth, widthDimLineY, `${realWidth.toFixed(0)} mm Cut Curtain Width`, 'horizontal');
            createLeaderLine(lathStartX, widthDimLineY, lathStartX, bottomY); createLeaderLine(lathStartX + scaledShutterWidth, widthDimLineY, lathStartX + scaledShutterWidth, bottomY);
            const maxOffset = Math.max(endlockOffsets.cast, endlockOffsets.wind);
            if (maxOffset > 0) {
                const scaledMaxOffset = maxOffset * scale; const endlockWidthDimY = bottomY + 28; const overallWidth = realWidth + (2 * maxOffset); const overallStartX = lathStartX - scaledMaxOffset; const overallEndX = lathStartX + scaledShutterWidth + scaledMaxOffset;
                drawDimensionLine(overallStartX, endlockWidthDimY, overallEndX, endlockWidthDimY, `${overallWidth.toFixed(0)} mm Overall Endlock Width`, 'horizontal');
                createLeaderLine(overallStartX, endlockWidthDimY, overallStartX, bottomY - (scaledBottomLathHeight/2)); createLeaderLine(overallEndX, endlockWidthDimY, overallEndX, bottomY - (scaledBottomLathHeight/2));
            }
            const rightDimX_Inner = startX + scaledTotalAxleWidth + 40; const rightDimX_Outer = rightDimX_Inner - 15;
            if (selectedEndplate) {
                const endplateSize = parseFloat(selectedEndplate.Size) || 0;
                if(endplateSize > 0) {
                    const endplateBottomY = endplateTopY + (endplateSize * scale); const heightToUnderside = parseFloat(dom.height.value) - (endplateSize / 2);
                    drawDimensionLine(rightDimX_Inner, endplateBottomY, rightDimX_Inner, bottomY, `${heightToUnderside.toFixed(0)} mm to underside of box`, 'vertical', 'left');
                    createLeaderLine(rightDimX_Inner, endplateBottomY, startX + scaledTotalAxleWidth, endplateBottomY); createLeaderLine(rightDimX_Inner, bottomY, startX + scaledTotalAxleWidth, bottomY);
                }
            }
            drawDimensionLine(rightDimX_Outer, axleCenterlineY, rightDimX_Outer, bottomY, `${parseFloat(dom.height.value).toFixed(0)} mm to Centre of Axle`, 'vertical', 'left');
            createLeaderLine(rightDimX_Outer, axleCenterlineY, startX + scaledTotalAxleWidth, axleCenterlineY); createLeaderLine(rightDimX_Outer, bottomY, startX + scaledTotalAxleWidth, bottomY);
            const leftDimX_Inner = basePadding.left - 15; const leftDimX_Outer = basePadding.left - 55;
            if (selectedEndplate) {
                 const endplateSize = parseFloat(selectedEndplate.Size) || 0;
                 if (endplateSize > 0) {
                    const scaledEndplateHeight = endplateSize * scale; const endplateBottomY = endplateTopY + scaledEndplateHeight;
                    drawDimensionLine(leftDimX_Inner, endplateTopY, leftDimX_Inner, endplateBottomY, `${endplateSize.toFixed(0)} mm Endplate`, 'vertical', 'left');
                    createLeaderLine(leftDimX_Inner, endplateTopY, startX, endplateTopY); createLeaderLine(leftDimX_Inner, endplateBottomY, startX, endplateBottomY);
                 }
            }
            if (bottomLathHeight > 0) {
                drawDimensionLine(leftDimX_Outer, bottomLathTopY, leftDimX_Outer, bottomY, `${bottomLathHeight.toFixed(0)} mm`, 'vertical', 'left');
                createLeaderLine(leftDimX_Outer, bottomLathTopY, lathStartX, bottomLathTopY); createLeaderLine(leftDimX_Outer, bottomY, lathStartX, bottomY);
            }
            return svg;
        }

        function switchTab(targetTabId) {
            document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
            tabButtons.forEach(b => b.classList.remove('active'));
            document.getElementById(targetTabId).classList.add('active');
            document.querySelector(`.tab-button[data-tab="${targetTabId}"]`).classList.add('active');
            if (targetTabId === 'axle-content') {
                const length = parseFloat(dom['total-axle-length'].textContent) || 0;
                const deflection = parseFloat(dom['axle-deflection'].textContent) || 0;
                drawDeflectionGraphic(length, deflection);
                const selectedAxleIndex = dom.axleType.value;
                if(selectedAxleIndex !== "" && axleData[selectedAxleIndex]) {
                    const collarSize = parseFloat(dom.collarSize.value) || 0;
                    drawAxleCrossSection(axleData[selectedAxleIndex], collarSize);
                } else { drawAxleCrossSection(null); }
            } else if (targetTabId === 'motor-content') { drawTorqueGraph(lastTorqueProfile, dom['torque-graph-container']);
            } else if(targetTabId === 'wicket-content') {
                 const curtainWidth = parseFloat(dom['calculated-curtain-width'].textContent) || 0; updateWicketCalculationsAndGraphic({cast:0, wind:0}, curtainWidth);
            } else if (targetTabId === 'endplate-content') {
                const selectedIndex = parseInt(dom.endplateSelector.value, 10);
                const selectedLath = lathData.length > 0 ? lathData[dom.lathType.value] : null;
                const selectedAxle = axleData.length > 0 ? axleData[dom.axleType.value] : null;
                const numLaths = parseInt(dom['lath-count'].textContent) || 0;
                if (!isNaN(selectedIndex) && currentFilteredEndplates[selectedIndex]) {
                    const plate = currentFilteredEndplates[selectedIndex]; drawEndplateGraphic(plate, maxCoilDiameter, selectedAxle, selectedLath, numLaths); calculateEndplateForces(plate);
                } else { drawEndplateGraphic(null, 0, null, null, 0); calculateEndplateForces(null); }
            }
        };
        
        updateAllCalculations();
    </script>

    <script>
        window.addEventListener('load', () => {
            ['endplate-content', 'safety-brake-content', 'wicket-content'].forEach(tabId => {
                const tabButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
                if(tabButton) { tabButton.style.display = 'none'; }
            });
            initializeAdminControls(); 
            const excelFileUrl = 'https://raw.githubusercontent.com/rob-hyrons/SWS_logic_calculator/main/Calculations%20gfa.xlsx';
            const statusDiv = document.getElementById('import-status');
            statusDiv.textContent = 'Loading data from repository...'; statusDiv.style.color = '#555';
            fetch(excelFileUrl).then(response => {
                if (!response.ok) { throw new Error(`Network response was not ok: ${response.statusText}`); }
                return response.arrayBuffer();
            }).then(fileData => { processExcelFile(fileData); }).catch(error => {
                statusDiv.textContent = 'Failed to fetch the Excel file from the repository. Please check the console for details.'; statusDiv.style.color = 'red'; console.error('There has been a problem with the fetch operation:', error);
            });
        });
    </script>
    
    <script>
        function setupReportFilters() {
            const lathSelect = document.getElementById('reportLathType');
            populateDropdown(lathSelect, lathData, 'Name');

            // NEW: Populate Secondary Lath Dropdown
            const lathSelect2 = document.getElementById('reportLathType2');
            // Add a specific "None" option first
            lathSelect2.innerHTML = `<option value="">-- None (Use Primary) --</option>`;
            lathData.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = item.Name;
                lathSelect2.appendChild(option);
            });

            const endlockSelect = document.getElementById('reportEndlockType');
            populateDropdown(endlockSelect, endlockData, 'Description');
            const bottomLathSelect = document.getElementById('reportBottomLathType');
            populateDropdown(bottomLathSelect, bottomLathData, 'Bottom lath name');
            let manufacturerKey = '', voltageKey = '', mountingKey = '', usageKey = '';
            if (motorData.length > 0) {
                const firstMotor = motorData[0];
                manufacturerKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'manufacturer');
                voltageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'voltage');
                mountingKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'mounting type');
                usageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'usage type');
            }
            const setupFilterGroup = (containerId, key, data, className) => {
                const container = document.getElementById(containerId); container.innerHTML = '';
                if (key) {
                    const uniqueValues = [...new Set(data.map(item => item[key]).filter(val => val))];
                    uniqueValues.sort().forEach(value => {
                        const controlItem = document.createElement('div'); controlItem.className = 'admin-control-item';
                        controlItem.innerHTML = `<label><input type="checkbox" class="${className}" value="${value}" checked> ${value}</label>`;
                        container.appendChild(controlItem);
                    });
                } else { container.innerHTML = `<p><em>Column not found in data.</em></p>`; }
            };
            setupFilterGroup('report-motor-filter-container', manufacturerKey, motorData, 'report-motor-checkbox');
            setupFilterGroup('report-motor-voltage-filter-container', voltageKey, motorData, 'report-voltage-checkbox');
            setupFilterGroup('report-motor-mounting-filter-container', mountingKey, motorData, 'report-mounting-checkbox');
            setupFilterGroup('report-motor-usage-filter-container', usageKey, motorData, 'report-usage-checkbox');

            document.getElementById('reportMotorSelectAll').addEventListener('click', () => document.querySelectorAll('.report-motor-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportMotorDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-motor-checkbox').forEach(cb => cb.checked = false));
            document.getElementById('reportVoltageSelectAll').addEventListener('click', () => document.querySelectorAll('.report-voltage-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportVoltageDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-voltage-checkbox').forEach(cb => cb.checked = false));
            document.getElementById('reportMountingSelectAll').addEventListener('click', () => document.querySelectorAll('.report-mounting-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportMountingDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-mounting-checkbox').forEach(cb => cb.checked = false));
            document.getElementById('reportUsageSelectAll').addEventListener('click', () => document.querySelectorAll('.report-usage-checkbox').forEach(cb => cb.checked = true));
            document.getElementById('reportUsageDeselectAll').addEventListener('click', () => document.querySelectorAll('.report-usage-checkbox').forEach(cb => cb.checked = false));
            
            const genBtn = document.getElementById('generateCsvButton');
            const newBtn = genBtn.cloneNode(true);
            genBtn.parentNode.replaceChild(newBtn, genBtn);
            newBtn.addEventListener('click', generateCsvReport);
        }

        function calculateCurtainPropertiesHeadless(lath, bottomLath, endlock, width_mm, height_mm) {
            if (!lath || !bottomLath || height_mm <= 0) { return { totalWeight: 0, torqueWeight: 0, travelHeight: 0 }; }
            
            const axleRadius = 60; // Standard assumption for reporting if no specific axle selected yet
            const lathCompressedHeight = parseFloat(lath['Compressed lath height']);
            const bottomLathHeight = parseFloat(bottomLath['BLath height']) || 0;
            const heightToCoverByLaths = (height_mm - bottomLathHeight) + axleRadius;
            
            let numLaths = (lathCompressedHeight > 0 && heightToCoverByLaths > 0) ? Math.ceil(heightToCoverByLaths / lathCompressedHeight) + 2 : 0;
            
            const widthM = width_mm / 1000;
            let kgsPerM2 = parseFloat(lath['Kgs/ m2']) || 0;
            const lathWeightBasedOnCoverage = widthM * (numLaths * lathCompressedHeight / 1000) * kgsPerM2;
            const bottomLathWeight = widthM * (parseFloat(bottomLath['BLath weight / m length']) || 0);
            
            // --- UPDATED ENDLOCK WEIGHT CALCULATION ---
            let totalEndlockWeight = 0;
            let bufferEndlockWeight = 0; // For torque calculation later

            const lathName = (lath['Name'] || '').toLowerCase();
            const isWindLath = lathName.includes('wind');

            if (isWindLath) {
                // LOGIC MIRROR: If Wind Lath, switch to Cast + Wind locks regardless of dropdown selection
                
                // 1. Find Cast Endlock (Looking for "75mm cast" in global endlockData)
                const castEndlockObj = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm cast'));
                let castWeightG = 0;
                if (castEndlockObj) {
                    const wKey = Object.keys(castEndlockObj).find(k => k.toLowerCase().trim() === 'weight in grams');
                    castWeightG = wKey ? parseFloat(castEndlockObj[wKey]) : 0;
                }

                // 2. Find Wind Endlock (Looking for "75mm wind" in global endlockData)
                const windEndlockObj = endlockData.find(el => (el['Description'] || '').toLowerCase().includes('75mm wind'));
                let windWeightG = 0;
                if (windEndlockObj) {
                    const wKey = Object.keys(windEndlockObj).find(k => k.toLowerCase().trim() === 'weight in grams');
                    windWeightG = wKey ? parseFloat(windEndlockObj[wKey]) : 0;
                }

                // 3. Apply the specific Wind Loop Formula
                for (let i = 1; i <= numLaths; i++) {
                    // Cast lock on every Odd lath (1, 3, 5...)
                    if (i % 2 !== 0 && castWeightG > 0) { 
                        totalEndlockWeight += 2 * (castWeightG / 1000); 
                    }
                    
                    // Wind lock on specific positions (2, 4, 6, 8, then every 8th)
                    const isWindLathPosition = (i === 2 || i === 4 || i === 6 || i === 8) || (i > 8 && i % 8 === 0);
                    if (isWindLathPosition && windWeightG > 0) { 
                        totalEndlockWeight += 2 * (windWeightG / 1000); 
                    }
                }

                // Calculate buffer for Torque (Mirroring main logic: usually 4 cast locks)
                if (castWeightG > 0) { bufferEndlockWeight = 4 * (castWeightG / 1000); }

            } else {
                // STANDARD LOGIC: Use the selected endlock (e.g., Plastic)
                let endlockWeightG = 0;
                if (endlock) {
                    const weightKey = Object.keys(endlock).find(k => k.toLowerCase().trim() === 'weight in grams');
                    endlockWeightG = weightKey ? parseFloat(endlock[weightKey]) : 0;
                    
                    if (endlockWeightG > 0 && numLaths > 0) {
                        const numEndlockPairs = Math.ceil(numLaths / 2); 
                        totalEndlockWeight = numEndlockPairs * 2 * (endlockWeightG / 1000);
                    }
                }
                
                // Calculate buffer for Torque
                if (endlockWeightG > 0) { bufferEndlockWeight = 4 * (endlockWeightG / 1000); }
            }
            // ------------------------------------------

            const totalWeight = lathWeightBasedOnCoverage + bottomLathWeight + totalEndlockWeight;
            
            let torqueWeight = totalWeight;
            if (numLaths >= 3) {
                const bufferLathWeight = 3 * (lathCompressedHeight / 1000) * widthM * kgsPerM2;
                torqueWeight = totalWeight - bufferLathWeight - bufferEndlockWeight;
            }
            
            const travelHeight = height_mm - bottomLathHeight;
            return { totalWeight, torqueWeight, travelHeight };
        }

        function findBestAxleHeadless(totalWeightKgs, totalLength, lath) {
             if (totalLength <= 0 || axleData.length === 0) { return { name: 'null', deflection: 0, axleObj: null }; }
            
            // Filter for Circular shape AND Min Axle Diameter
            let minAxleDiameter = 0;
            if (lath) {
                const minAxleKey = Object.keys(lath).find(k => k.toLowerCase().trim() === 'min axle diameter');
                minAxleDiameter = minAxleKey ? (parseFloat(lath[minAxleKey]) || 0) : 0;
            }

            const axlesForShape = axleData.filter(axle => {
                const isCircular = (axle.Shape || 'circular').toLowerCase().trim() === 'circular';
                const dia = parseFloat(axle['Diameter']) || 0;
                return isCircular && dia >= minAxleDiameter;
            });

            if (axlesForShape.length === 0) return { name: 'null', deflection: 0, axleObj: null };

            let bestAxle = null;
            let bestDeflection = 0;
            
            for (const axle of axlesForShape) {
                const perf = performDeflectionCalc(totalWeightKgs, axle, totalLength);
                if (perf.ratio >= 400 && perf.deflection <= 25) { 
                    bestAxle = axle; 
                    bestDeflection = perf.deflection;
                    break; 
                }
            }
            
            if (bestAxle) { 
                return { name: bestAxle.Name, deflection: bestDeflection, axleObj: bestAxle }; 
            } else { 
                let bestFailAxle = axlesForShape[0];
                let minDeflection = Infinity;

                axlesForShape.forEach(axle => {
                     const perf = performDeflectionCalc(totalWeightKgs, axle, totalLength);
                     if(perf.deflection < minDeflection) {
                         minDeflection = perf.deflection;
                         bestFailAxle = axle;
                     }
                });
                return { name: bestFailAxle.Name, deflection: minDeflection, axleObj: bestFailAxle }; 
            }
        }
        
        function calculateTorqueHeadless(torqueWeight, lath, travelHeight, axle, width_mm, bottomLath, friction_percent) {
            // Simulate the lift just like getTorqueProfile to account for diameter increase
            if (!lath || !axle || !bottomLath || travelHeight <= 0 || torqueWeight <= 0) return 0;
            
            const lathThickness = parseFloat(lath['Thickness']) || 0;
            const effectiveStartDiameter = getEffectiveCoilDiameter(axle);
            const bottomLathWeight = (width_mm / 1000) * (parseFloat(bottomLath['BLath height']) || 0); // Using BLath height here as a proxy for weight if 'weight' field is missing or separate, check standard logic
            const bottomLathWeightActual = (width_mm / 1000) * (parseFloat(bottomLath['BLath weight / m length']) || 0);
            const lathsWeight = torqueWeight - bottomLathWeightActual;

            let heightLifted = 0;
            let currentRollDiameter = effectiveStartDiameter;
            let maxTorqueFound = 0;

            // Iterate through the lift
            while (heightLifted < travelHeight) {
                const percentLifted = heightLifted / travelHeight;
                // Remaining weight decreases as curtain lifts
                const remainingLathWeight = lathsWeight * (1 - percentLifted);
                const remainingTotalWeight = remainingLathWeight + bottomLathWeightActual;
                
                const force = remainingTotalWeight * 9.81;
                // Radius increases as curtain rolls up
                const radiusM = (currentRollDiameter / 2) / 1000;
                
                const currentTorque = force * radiusM;
                if (currentTorque > maxTorqueFound) {
                    maxTorqueFound = currentTorque;
                }

                // Advance simulation by one wrap
                const circumference = Math.PI * currentRollDiameter;
                heightLifted += circumference / 2; // Matches getTorqueProfile logic step
                currentRollDiameter += lathThickness;
            }

            const frictionMultiplier = 1 + (friction_percent || 0) / 100;
            return maxTorqueFound * frictionMultiplier;
        }

        async function generateCsvReport() {
            const statusDiv = document.getElementById('csv-generation-status');
            statusDiv.textContent = 'Starting report generation...'; statusDiv.style.color = 'blue';
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const minWidth = parseInt(document.getElementById('reportMinWidth').value);
            const maxWidth = parseInt(document.getElementById('reportMaxWidth').value);
            const minHeight = parseInt(document.getElementById('reportMinHeight').value);
            const maxHeight = parseInt(document.getElementById('reportMaxHeight').value);
            const interval = parseInt(document.getElementById('reportInterval').value);
            
            // Inputs
            const lathIndex1 = document.getElementById('reportLathType').value;
            const lathIndex2 = document.getElementById('reportLathType2').value;
            const rawLimit = document.getElementById('reportLathLimit').value;
            const switchLimit = rawLimit ? parseInt(rawLimit) : Infinity; 

            const endlockIndex = document.getElementById('reportEndlockType').value;
            const bottomLathIndex = document.getElementById('reportBottomLathType').value;

            if (lathIndex1 === "" || endlockIndex === "" || bottomLathIndex === "") {
                statusDiv.textContent = 'Error: Please select Primary Lath, Endlock, and Bottom Lath types.'; statusDiv.style.color = 'red'; return;
            }

            const primaryLath = lathData[lathIndex1];
            const secondaryLath = (lathIndex2 !== "") ? lathData[lathIndex2] : primaryLath; 
            const selectedEndlock = endlockData[endlockIndex];
            const selectedBottomLath = bottomLathData[bottomLathIndex];

            const getSelectedValues = (className) => Array.from(document.querySelectorAll(`.${className}:checked`)).map(cb => cb.value);
            const selectedManufacturers = getSelectedValues('report-motor-checkbox');
            const selectedVoltages = getSelectedValues('report-voltage-checkbox');
            const selectedMountings = getSelectedValues('report-mounting-checkbox');
            const selectedUsageTypes = getSelectedValues('report-usage-checkbox');
            
            if (selectedManufacturers.length === 0 || selectedVoltages.length === 0 || selectedMountings.length === 0 || selectedUsageTypes.length === 0) {
                statusDiv.textContent = 'Error: Please select at least one option from each motor filter category (including Usage Type).'; statusDiv.style.color = 'red'; return;
            }
            
            let manufacturerKey = '', voltageKey = '', mountingKey = '', usageKey = '';
            if (motorData.length > 0) {
                const firstMotor = motorData[0];
                manufacturerKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'manufacturer');
                voltageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'voltage');
                mountingKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'mounting type');
                usageKey = Object.keys(firstMotor).find(k => k.toLowerCase().trim() === 'usage type');
            }
            
            const calculationCache = {};
            const defaultAdditionalLength = 100;
            let calculationCount = 0;
            
            statusDiv.textContent = `Step 1 of 2: Calculating configuration...`;
            
            for (let width = minWidth; width <= maxWidth; width += interval) {
                calculationCache[width] = {};
                
                const currentLath = (width > switchLimit) ? secondaryLath : primaryLath;

                for (let height = minHeight; height <= maxHeight; height += interval) {
                    calculationCount++;
                    if (calculationCount % 50 === 0) { statusDiv.textContent = `Step 1 of 2: Calculating... (${calculationCount} sizes processed)`; await new Promise(resolve => setTimeout(resolve, 0)); }
                    
                    const props = calculateCurtainPropertiesHeadless(currentLath, selectedBottomLath, selectedEndlock, width, height);
                    const totalLength = width + defaultAdditionalLength;
                    
                    const axleResult = findBestAxleHeadless(props.totalWeight, totalLength, currentLath);
                    
                    const defaultFriction = parseFloat(currentLath['Friction %']) || 10;
                    const requiredTorque = calculateTorqueHeadless(props.torqueWeight, currentLath, props.travelHeight, axleResult.axleObj, width, selectedBottomLath, defaultFriction);
                    
                    const result = {
                        'Lath Type Used': currentLath.Name, 
                        'Total Weight (kg)': props.totalWeight.toFixed(2),
                        'Required Axle Name': axleResult.name,
                        'Axle Deflection (mm)': axleResult.deflection.toFixed(2), 
                        'Max Required Torque (Nm)': requiredTorque > 0 ? requiredTorque.toFixed(1) : 'null'
                    };

                    // Iterate Usage Types first
                    for (const usage of selectedUsageTypes) {
                        for (const man of selectedManufacturers) {
                            for (const vol of selectedVoltages) {
                                for (const mou of selectedMountings) {
                                    const scenarioName = `${usage} - ${man} (${vol}, ${mou})`;
                                    const scenarioKey = `Motor: ${scenarioName}`;
                                    const suitableMotors = motorData.filter(m => 
                                            m[usageKey] == usage &&
                                            m[manufacturerKey] == man &&
                                            String(m[voltageKey]) == String(vol) &&
                                            m[mountingKey] == mou &&
                                            requiredTorque > 0 && 
                                            requiredTorque >= parseFloat(m['Torque (Nm) min']) && 
                                            requiredTorque <= parseFloat(m['Torque (Nm) max'])
                                        ).sort((a,b) => parseFloat(a['Torque (Nm) max']) - parseFloat(b['Torque (Nm) max']));
                                    
                                    if (suitableMotors.length > 0) {
                                        const selectedMotor = suitableMotors[0];
                                        result[scenarioKey] = selectedMotor.Name;
                                        let effectiveDiameter = 0;
                                        if(axleResult.axleObj) { effectiveDiameter = getEffectiveCoilDiameter(axleResult.axleObj); }
                                        const rotations = calculateTotalRevolutions(props.travelHeight, effectiveDiameter, parseFloat(currentLath['Thickness']));
                                        const rpm = parseFloat(selectedMotor['RPM']) || 0;
                                        const timeSeconds = (rpm > 0) ? (rotations / rpm) * 60 : 0;
                                        const timeKey = `Opening Time (sec): ${scenarioName}`;
                                        result[timeKey] = timeSeconds > 0 ? timeSeconds.toFixed(1) : 'N/A';
                                    } else {
                                        result[scenarioKey] = 'null';
                                        const timeKey = `Opening Time (sec): ${scenarioName}`;
                                        result[timeKey] = 'N/A';
                                    }
                                }
                            }
                        }
                    }
                    calculationCache[width][height] = result;
                }
            }
            statusDiv.textContent = 'Step 2 of 2: Assembling CSV file...';
            await new Promise(resolve => setTimeout(resolve, 0));
            const csvData = [];
            const widthHeaders = ['Height \\ Width'];
            for (let w = minWidth; w <= maxWidth; w += interval) { widthHeaders.push(w); }
            
            const firstEntry = calculationCache[minWidth][minHeight];
            const tableTypes = Object.keys(firstEntry);
            
            tableTypes.sort((a, b) => {
                if (a === 'Lath Type Used') return -1;
                if (b === 'Lath Type Used') return 1;
                return a.localeCompare(b);
            });

            let headerInfo = `Primary Lath: ${primaryLath.Name}`;
            if (lathIndex2 !== "" && rawLimit) {
                headerInfo += ` | Secondary Lath (>${rawLimit}mm): ${secondaryLath.Name}`;
            }
            headerInfo += ` | Endlock: ${selectedEndlock['Description']} | Bottom Lath: ${selectedBottomLath['Bottom lath name']}`;

            for (const tableType of tableTypes) {
                csvData.push([headerInfo]);
                csvData.push([`Data: ${tableType}`]);
                csvData.push(widthHeaders);
                for (let height = minHeight; height <= maxHeight; height += interval) {
                    const row = [height];
                    for (let width = minWidth; width <= maxWidth; width += interval) {
                        const value = calculationCache[width]?.[height]?.[tableType] || 'N/A'; row.push(value);
                    }
                    csvData.push(row);
                }
                csvData.push([]); csvData.push([]);
            }
            downloadCsv(csvData);
            statusDiv.textContent = 'Report generation complete. Download has started.'; statusDiv.style.color = 'green';
        }

        function downloadCsv(data) {
            let csvContent = "data:text/csv;charset=utf-8,";
            data.forEach(function(rowArray) {
                let row = rowArray.map(item => `"${String(item).replace(/"/g, '""')}"`).join(",");
                csvContent += row + "\r\n";
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "shutter_calculator_report.csv");
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        }
    </script>
</body>
</html>
